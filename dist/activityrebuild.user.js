// ==UserScript==
// @name       activityrebuild
// @namespace  npm/vite-plugin-monkey
// @version    0.0.0
// @icon       https://vitejs.dev/logo.svg
// @match      https://bitrix.triline.kz/crm/activity/*
// @grant      GM.addElement
// @grant      GM.addStyle
// @grant      GM.addValueChangeListener
// @grant      GM.audio
// @grant      GM.cookie
// @grant      GM.deleteValue
// @grant      GM.deleteValues
// @grant      GM.download
// @grant      GM.getResourceText
// @grant      GM.getResourceUrl
// @grant      GM.getTab
// @grant      GM.getTabs
// @grant      GM.getValue
// @grant      GM.getValues
// @grant      GM.info
// @grant      GM.listValues
// @grant      GM.log
// @grant      GM.notification
// @grant      GM.openInTab
// @grant      GM.registerMenuCommand
// @grant      GM.removeValueChangeListener
// @grant      GM.saveTab
// @grant      GM.setClipboard
// @grant      GM.setValue
// @grant      GM.setValues
// @grant      GM.unregisterMenuCommand
// @grant      GM.webRequest
// @grant      GM.xmlHttpRequest
// @grant      GM_addElement
// @grant      GM_addStyle
// @grant      GM_addValueChangeListener
// @grant      GM_audio
// @grant      GM_cookie
// @grant      GM_deleteValue
// @grant      GM_deleteValues
// @grant      GM_download
// @grant      GM_getResourceText
// @grant      GM_getResourceURL
// @grant      GM_getTab
// @grant      GM_getTabs
// @grant      GM_getValue
// @grant      GM_getValues
// @grant      GM_info
// @grant      GM_listValues
// @grant      GM_log
// @grant      GM_notification
// @grant      GM_openInTab
// @grant      GM_registerMenuCommand
// @grant      GM_removeValueChangeListener
// @grant      GM_saveTab
// @grant      GM_setClipboard
// @grant      GM_setValue
// @grant      GM_setValues
// @grant      GM_unregisterMenuCommand
// @grant      GM_webRequest
// @grant      GM_xmlhttpRequest
// @grant      unsafeWindow
// @grant      window.close
// @grant      window.focus
// @grant      window.onurlchange
// ==/UserScript==

(function () {
  'use strict';

  function _mergeNamespaces$1(n, m) {
    for (var i = 0; i < m.length; i++) {
      const e = m[i];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k in e) {
          if (k !== "default" && !(k in n)) {
            const d = Object.getOwnPropertyDescriptor(e, k);
            if (d) {
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production = {};
  var hasRequiredReactJsxRuntime_production;
  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    {
      jsxRuntime.exports = requireReactJsxRuntime_production();
    }
    return jsxRuntime.exports;
  }
  var jsxRuntimeExports = requireJsxRuntime();
  var react = { exports: {} };
  var react_production = {};
  var hasRequiredReact_production;
  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, assign2 = Object.assign, emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign2(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop2() {
    }
    var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match2) {
        return escaperLookup[match2];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    react_production.Activity = REACT_ACTIVITY_TYPE;
    react_production.Children = Children;
    react_production.Component = Component;
    react_production.Fragment = REACT_FRAGMENT_TYPE;
    react_production.Profiler = REACT_PROFILER_TYPE;
    react_production.PureComponent = PureComponent;
    react_production.StrictMode = REACT_STRICT_MODE_TYPE;
    react_production.Suspense = REACT_SUSPENSE_TYPE;
    react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    react_production.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size2) {
        return ReactSharedInternals.H.useMemoCache(size2);
      }
    };
    react_production.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    react_production.cacheSignal = function() {
      return null;
    };
    react_production.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign2({}, element.props), key = element.key;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    react_production.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    react_production.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, props);
    };
    react_production.createRef = function() {
      return { current: null };
    };
    react_production.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    react_production.isValidElement = isValidElement;
    react_production.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    react_production.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    react_production.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    react_production.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    react_production.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    react_production.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    react_production.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    react_production.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    react_production.useDebugValue = function() {
    };
    react_production.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    react_production.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    react_production.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    react_production.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    react_production.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    react_production.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    react_production.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    react_production.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    react_production.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    react_production.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    react_production.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    react_production.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    react_production.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    react_production.version = "19.2.1";
    return react_production;
  }
  var hasRequiredReact;
  function requireReact() {
    if (hasRequiredReact) return react.exports;
    hasRequiredReact = 1;
    {
      react.exports = requireReact_production();
    }
    return react.exports;
  }
  var reactExports = requireReact();
  const React = getDefaultExportFromCjs(reactExports);
  const React$1 = _mergeNamespaces$1({
    __proto__: null,
    default: React
  }, [reactExports]);
  var client = { exports: {} };
  var reactDomClient_production = {};
  var scheduler = { exports: {} };
  var scheduler_production = {};
  var hasRequiredScheduler_production;
  function requireScheduler_production() {
    if (hasRequiredScheduler_production) return scheduler_production;
    hasRequiredScheduler_production = 1;
    (function(exports$1) {
      function push(heap, node2) {
        var index = heap.length;
        heap.push(node2);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node2))
            heap[parentIndex] = node2, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek2(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first2 = heap[0], last2 = heap.pop();
        if (last2 !== first2) {
          heap[0] = last2;
          a: for (var index = 0, length2 = heap.length, halfLength = length2 >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
            if (0 > compare(left, last2))
              rightIndex < length2 && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last2, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last2, index = leftIndex);
            else if (rightIndex < length2 && 0 > compare(right, last2))
              heap[index] = right, heap[rightIndex] = last2, index = rightIndex;
            else break a;
          }
        }
        return first2;
      }
      function compare(a, b2) {
        var diff2 = a.sortIndex - b2.sortIndex;
        return 0 !== diff2 ? diff2 : a.id - b2.id;
      }
      exports$1.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var localPerformance = performance;
        exports$1.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports$1.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek2(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek2(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek2(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek2(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports$1.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek2(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports$1.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek2(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek2(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek2(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports$1.unstable_now());
        }, ms);
      }
      exports$1.unstable_IdlePriority = 5;
      exports$1.unstable_ImmediatePriority = 1;
      exports$1.unstable_LowPriority = 4;
      exports$1.unstable_NormalPriority = 3;
      exports$1.unstable_Profiling = null;
      exports$1.unstable_UserBlockingPriority = 2;
      exports$1.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports$1.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports$1.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports$1.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports$1.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout = -1;
            break;
          case 2:
            timeout = 250;
            break;
          case 5:
            timeout = 1073741823;
            break;
          case 4:
            timeout = 1e4;
            break;
          default:
            timeout = 5e3;
        }
        timeout = options + timeout;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek2(taskQueue) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports$1.unstable_shouldYield = shouldYieldToHost;
      exports$1.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    })(scheduler_production);
    return scheduler_production;
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    if (hasRequiredScheduler) return scheduler.exports;
    hasRequiredScheduler = 1;
    {
      scheduler.exports = requireScheduler_production();
    }
    return scheduler.exports;
  }
  var reactDom = { exports: {} };
  var reactDom_production = {};
  var hasRequiredReactDom_production;
  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var React2 = requireReact();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop2() {
    }
    var Internals = {
      d: {
        f: noop2,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    reactDom_production.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    reactDom_production.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    reactDom_production.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    reactDom_production.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    reactDom_production.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    reactDom_production.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    reactDom_production.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    reactDom_production.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    reactDom_production.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    reactDom_production.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    reactDom_production.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    reactDom_production.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    reactDom_production.version = "19.2.1";
    return reactDom_production;
  }
  var hasRequiredReactDom;
  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom.exports;
    hasRequiredReactDom = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = requireReactDom_production();
    }
    return reactDom.exports;
  }
  var hasRequiredReactDomClient_production;
  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node2) {
      return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node2 = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
      else {
        fiber = node2;
        do
          node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
        while (fiber);
      }
      return 3 === node2.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b2 = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b2 = parentA.return;
          if (null !== b2) {
            a = b2;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b2) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b2.return) a = parentA, b2 = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b2 = parentB;
              break;
            }
            if (child$0 === b2) {
              didFindChild = true;
              b2 = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b2 = parentA;
                break;
              }
              if (child$0 === b2) {
                didFindChild = true;
                b2 = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b2) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node2) {
      var tag = node2.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
      for (node2 = node2.child; null !== node2; ) {
        tag = findCurrentHostFiberImpl(node2);
        if (null !== tag) return tag;
        node2 = node2.sibling;
      }
      return null;
    }
    var assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {
            }
        }
      return null;
    }
    var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, valueStack = [], index = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor2) {
      0 > index || (cursor2.current = valueStack[index], valueStack[index] = null, index--);
    }
    function push(cursor2, value) {
      index++;
      valueStack[index] = cursor2.current;
      cursor2.current = value;
    }
    var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var prefix2, suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix2)
        try {
          throw Error();
        } catch (x2) {
          var match2 = x2.stack.trim().match(/\n( *(at )?)/);
          prefix2 = match2 && match2[1] || "";
          suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix2 + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    var control = x2;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame2 = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame2.includes("<anonymous>") && (frame2 = frame2.replace("<anonymous>", fn.displayName));
                    return frame2;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do
          info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x2) {
        return "\nError generating stack: " + x2.message + "\n" + x2.stack;
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now2 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x2) {
      x2 >>>= 0;
      return 0 === x2 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
    }
    var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root3.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
      root3 = root3.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root3, renderLanes2) {
      return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root3, updateLane) {
      root3.pendingLanes |= updateLane;
      268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
    }
    function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root3.pendingLanes;
      root3.pendingLanes = remainingLanes;
      root3.suspendedLanes = 0;
      root3.pingedLanes = 0;
      root3.warmLanes = 0;
      root3.expiredLanes &= remainingLanes;
      root3.entangledLanes &= remainingLanes;
      root3.errorRecoveryDisabledLanes &= remainingLanes;
      root3.shellSuspendCounter = 0;
      var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
      root3.pendingLanes |= spawnedLane;
      root3.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root3.entangledLanes |= spawnedLane;
      root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root3, entangledLanes) {
      var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
      for (root3 = root3.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root3[index$8] & entangledLanes && (root3[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root3, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node2) {
      delete node2[internalInstanceKey];
      delete node2[internalPropsKey];
      delete node2[internalEventHandlersKey];
      delete node2[internalEventHandlerListenersKey];
      delete node2[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node2) {
      if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
        var tag = node2.tag;
        if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node2;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root3) {
      var resources = root3[internalRootNodeResourcesKey];
      resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: new Map(), hoistableScripts: new Map() });
      return resources;
    }
    function markNodeAsHoistable(node2) {
      node2[internalHoistableMarker] = true;
    }
    var allNativeEvents = new Set(), registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node2, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node2.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node2.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node2.removeAttribute(name);
                return;
              }
          }
          node2.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node2, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node2, namespace, name, value) {
      if (null === value) node2.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node2.removeAttribute(name);
            return;
        }
        node2.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node2, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node2.constructor.prototype,
        valueField
      );
      if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node2, valueField, {
          configurable: true,
          get: function() {
            return get.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node2, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node2._valueTracker = null;
            delete node2[valueField];
          }
        };
      }
    }
    function track(node2) {
      if (!node2._valueTracker) {
        var valueField = isCheckable(node2) ? "checked" : "value";
        node2._valueTracker = trackValueOnNode(
          node2,
          valueField,
          "" + node2[valueField]
        );
      }
    }
    function updateValueIfChanged(node2) {
      if (!node2) return false;
      var tracker = node2._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
      node2 = value;
      return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
    }
    function getActiveElement2(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
          track(element);
          return;
        }
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      track(element);
    }
    function setDefaultValue(node2, type, value) {
      "number" === type && getActiveElement2(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
    }
    function updateOptions(node2, multiple, propValue, setDefaultSelected) {
      node2 = node2.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0; propValue < node2.length; propValue++)
          i = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i && (node2[propValue].selected = i), i && setDefaultSelected && (node2[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node2.length; i++) {
          if (node2[i].value === propValue) {
            node2[i].selected = true;
            setDefaultSelected && (node2[i].defaultSelected = true);
            return;
          }
          null !== multiple || node2[i].disabled || (multiple = node2[i]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
      track(element);
    }
    function setTextContent(node2, text) {
      if (text) {
        var firstChild = node2.firstChild;
        if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node2.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty3 = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty3 ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty3 ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    function setValueForStyles(node2, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node2 = node2.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node2, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node2, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function noop$12() {
    }
    var currentReplayingEvent = null;
    function getEventTarget2(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b2) {
      if (isInsideEventHandler) return fn(a, b2);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var root2 = null, startText = null, fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign2(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign2({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
      newState: 0,
      oldState: 0
    }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null, activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM) {
      var JSCompiler_inline_result$jscomp$286;
      if (canUseDOM) {
        var isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          var element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
    }
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget2(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x2, y) {
      return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node2) {
      for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
      return node2;
    }
    function getNodeForCharacterOffset(root3, offset2) {
      var node2 = getLeafNode(root3);
      root3 = 0;
      for (var nodeEnd; node2; ) {
        if (3 === node2.nodeType) {
          nodeEnd = root3 + node2.textContent.length;
          if (root3 <= offset2 && nodeEnd >= offset2)
            return { node: node2, offset: offset2 - root3 };
          root3 = nodeEnd;
        }
        a: {
          for (; node2; ) {
            if (node2.nextSibling) {
              node2 = node2.nextSibling;
              break a;
            }
            node2 = node2.parentNode;
          }
          node2 = void 0;
        }
        node2 = getLeafNode(node2);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement2(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement2(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement2(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_TYPE:
            return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_LIST_TYPE:
            return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    var CapturedStacks = new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index2) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index2 += 1;
      var length2 = 32 - clz32(totalChildren) + baseLength;
      if (30 < length2) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length2 + workInProgress2;
      } else
        treeContextId = 1 << length2 | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$12), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache3() {
      return {
        controller: new AbortControllerLocal(),
        data: new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache2) {
      cache2.refCount--;
      0 === cache2.refCount && scheduleCallback$2(NormalPriority, function() {
        cache2.controller.abort();
      });
    }
    var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now2();
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState2, thenable, index2) {
      index2 = thenableState2[index2];
      void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$12, noop$12), thenable = index2);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$12, noop$12);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        var init = lazyType._init;
        return init(lazyType._payload);
      } catch (x2) {
        if (null !== x2 && "object" === typeof x2 && "function" === typeof x2.then)
          throw suspendedThenable = x2, SuspenseException;
        throw x2;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    var thenableState$1 = null, thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index2 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index2);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x2) {
          if (x2 === SuspenseException || x2 === SuspenseActionException) throw x2;
          var fiber = createFiberImplClass(29, x2, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root3, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone2 = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign2({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node2 = row; null !== node2; ) {
        if (13 === node2.tag) {
          var state2 = node2.memoizedState;
          if (null !== state2 && (state2 = state2.dehydrated, null === state2 || isSuspenseInstancePending(state2) || isSuspenseInstanceFallback(state2)))
            return node2;
        } else if (19 === node2.tag && ("forwards" === node2.memoizedProps.revealOrder || "backwards" === node2.memoizedProps.revealOrder || "unstable_legacy-backwards" === node2.memoizedProps.revealOrder || "together" === node2.memoizedProps.revealOrder)) {
          if (0 !== (node2.flags & 128)) return node2;
        } else if (null !== node2.child) {
          node2.child.return = node2;
          node2 = node2.child;
          continue;
        }
        if (node2 === row) break;
        for (; null === node2.sibling; ) {
          if (null === node2.return || node2.return === row) return null;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return;
        node2 = node2.sibling;
      }
      return null;
    }
    var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index2 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index2);
      index2 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size2) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size2), current = 0; current < size2; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state2, action) {
      return "function" === typeof action ? action(state2) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root3 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node2) {
      var action = node2.action, payload = node2.payload, prevState = actionQueue.state;
      if (node2.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node2, returnValue);
        } catch (error) {
          onActionError(actionQueue, node2, error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node2, prevTransition);
        } catch (error$66) {
          onActionError(actionQueue, node2, error$66);
        }
    }
    function handleActionReturnValue(actionQueue, node2, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node2, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node2, error);
        }
      ) : onActionSuccess(actionQueue, node2, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last2 = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last2) {
        last2 = last2.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last2);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state2 = useThenable(currentStateHook);
        } catch (x2) {
          if (x2 === SuspenseException) throw SuspenseActionException;
          throw x2;
        }
      else state2 = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        { destroy: void 0 },
        actionStateActionEffect.bind(null, actionQueue, action),
        null
      ));
      return [state2, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      ));
    }
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function updateImperativeHandle(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    }
    function noop2() {
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop2 : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane()
      );
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache3() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root3, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        mountEffectImpl(4, 2, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      },
      useState: function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
          subscribe
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "_";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache,
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      },
      useEffectEvent: function(callback) {
        var hook = mountWorkInProgressHook(), ref = { impl: callback };
        hook.memoizedState = ref;
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
    }, HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign2({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign2({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root3, errorInfo) {
      try {
        var onUncaughtError = root3.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    function logCaughtError(root3, boundary, errorInfo) {
      try {
        var onCaughtError = root3.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root3, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root3, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root3, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root3, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root3.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root3,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextProps = workInProgress2.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            prevState,
            renderLanes2,
            nextProps
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2,
            nextProps
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current, workInProgress2) {
      null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress2.mode
      );
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
      workInProgress2.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (null !== workInProgress2.memoizedState)
            workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else throw Error(formatProdErrorMessage(558));
        else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
            throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children
      });
      current.ref = workInProgress2.ref;
      workInProgress2.child = current;
      current.return = workInProgress2;
      return current;
    }
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(
        current,
        workInProgress2,
        Component,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            showFallback
          ), nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
          JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
          digest,
          nextPrimaryChildren
        ) : (nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      nextProps = isHydrating ? treeForkCount : 0;
      if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode,
            nextProps
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode,
            nextProps
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress2,
            false,
            null,
            null,
            void 0,
            nextProps
          );
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 31:
          if (null !== workInProgress2.memoizedState)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          var state$102 = workInProgress2.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state$102 || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            var props = workInProgress2.pendingProps;
            current = resolveLazy(workInProgress2.elementType);
            workInProgress2.type = current;
            if ("function" === typeof current)
              shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              ));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
            props,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            props,
            $$typeof,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, props, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress2, CacheContext, props);
            props !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: props,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError($$typeof);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  props,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, props, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if ($$typeof = props = nextHydratableInstance)
              props = canHydrateInstance(
                props,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
            $$typeof || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          $$typeof = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = $$typeof);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, props, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            props,
            renderLanes2
          ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
        case 9:
          return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache3(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if (type = 0 !== (workInProgress2.mode & 32)) type = false;
      if (type) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
      else
        for (child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
          null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            null,
            newProps,
            renderLanes2
          ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            current,
            newProps,
            renderLanes2
          ));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script><\/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                        is: newProps.is
                      }) : ownerDocument.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress2) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress2.stateNode = nextResource;
              a: switch (setInitialProperties(nextResource, type, newProps), type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            workInProgress2.type,
            null === current ? null : current.memoizedProps,
            workInProgress2.pendingProps,
            renderLanes2
          );
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2, true);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress2);
            if (null !== renderLanes2) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress2.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              current = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
            if (!current) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if (0 !== (workInProgress2.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress2.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress2.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress2), null;
          type = 0 !== (workInProgress2.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail && now2() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current = findFirstSuspended(nextResource), null !== current) {
                if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now2() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (null !== newProps.tail)
            return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now2(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
              suspenseStackCursor,
              type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
            ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (null !== workInProgress2.memoizedState) {
            popSuspenseHandler(workInProgress2);
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node2, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node2), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
      else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode, before = null), node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
    }
    function insertOrAppendPlacementNode(node2, before, parent) {
      var tag = node2.tag;
      if (5 === tag || 6 === tag)
        node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
      else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode), node2 = node2.child, null !== node2))
        for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
          insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
    function commitBeforeMutationEffects(root3, firstChild) {
      root3 = root3.containerInfo;
      eventsEnabled = _enabled;
      root3 = getActiveElementDeep(root3);
      if (hasSelectionCapabilities(root3)) {
        if ("selectionStart" in root3)
          var JSCompiler_temp = {
            start: root3.selectionStart,
            end: root3.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode2 = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode2.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length2 = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root3, parentNode = null;
              b: for (; ; ) {
                for (var next2; ; ) {
                  node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start = length2 + anchorOffset);
                  node2 !== focusNode2 || 0 !== selection && 3 !== node2.nodeType || (end = length2 + selection);
                  3 === node2.nodeType && (length2 += node2.nodeValue.length);
                  if (null === (next2 = node2.firstChild)) break;
                  parentNode = node2;
                  node2 = next2;
                }
                for (; ; ) {
                  if (node2 === root3) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length2);
                  parentNode === focusNode2 && ++indexWithinFocus === selection && (end = length2);
                  if (null !== (next2 = node2.nextSibling)) break;
                  node2 = parentNode;
                  parentNode = node2.parentNode;
                }
                node2 = next2;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
          root3.return = firstChild, nextEffect = root3;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode2 = firstChild.alternate;
            root3 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (0 !== (root3 & 4) && (root3 = firstChild.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                  for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                    anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root3 & 1024) && null !== focusNode2) {
                  root3 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode2.memoizedProps;
                  focusNode2 = focusNode2.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset
                    );
                    root3 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode2
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root3;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root3 & 1024)) {
                  if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root3);
                  else if (1 === JSCompiler_temp)
                    switch (root3.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root3);
                        break;
                      default:
                        root3.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root3 = firstChild.sibling;
            if (null !== root3) {
              root3.return = firstChild.return;
              nextEffect = root3;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null, hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root3 = childToDelete.alternate;
          null !== root3 && (root3.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root3) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root3.containerInfo);
          recursivelyTraverseMutationEffects(root3, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root3.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now2());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
              if (5 === root3.tag || 26 === root3.tag) {
                if (null === current) {
                  wasHidden = current = root3;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                root3.child.return = root3;
                root3 = root3.child;
                continue;
              }
              if (root3 === finishedWork) break a;
              for (; null === root3.sibling; ) {
                if (null === root3.return || root3.return === finishedWork) break a;
                current === root3 && (current = null);
                root3 = root3.return;
              }
              current === root3 && (current = null);
              root3.sibling.return = root3.return;
              root3 = root3.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root3, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root3,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id2,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id2 = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256) || false
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            suspendedState,
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i = deletions.stateNode;
            i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache2 = fiber.memoizedState.cachePool.pool;
              null != cache2 && cache2.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache2 = fiber.child;
        if (null !== cache2) cache2.return = fiber, nextEffect = cache2;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache2 = nextEffect;
            var sibling = cache2.sibling, returnFiber = cache2.return;
            detachFiberAfterEffects(cache2);
            if (cache2 === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache2 = readContext(CacheContext), cacheForType = cache2.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache2.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      }
    }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root3, fiber, lane) {
      if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        prepareFreshStack(root3, 0), markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root3, lane);
      if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
        root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root3);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root3 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root3,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now2(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root3.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$12
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason
        );
        var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now2() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now2() : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root3.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root3,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root3,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node2 = finishedWork; ; ) {
        var tag = node2.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node2.child;
        if (node2.subtreeFlags & 16384 && null !== tag)
          tag.return = node2, node2 = tag;
        else {
          if (node2 === finishedWork) break;
          for (; null === node2.sibling; ) {
            if (null === node2.return || node2.return === finishedWork) return true;
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root3.suspendedLanes |= suspendedLanes;
      root3.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root3.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root3, lanes) {
      var timeoutHandle = root3.timeoutHandle;
      -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root3.cancelPendingCommit;
      null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root3;
      workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root3.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root3[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root3, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root3,
        createCapturedValueAtFiber(thrownValue, root3.current)
      ));
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root3, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root3, thrownValue$165);
        }
      while (1);
      lanes && root3.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root3, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now2() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root3,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root3);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root3, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next2 = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next2 = unitOfWork;
      var current = next2.alternate;
      switch (next2.tag) {
        case 15:
        case 0:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next2 = replayFunctionComponent(
            current,
            next2,
            next2.pendingProps,
            next2.type.render,
            next2.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next2);
        default:
          unwindInterruptedWork(current, next2), next2 = workInProgress = resetWorkInProgress(next2, entangledRenderLanes), next2 = beginWork(current, next2, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
    }
    function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root3,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root3 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root3 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root3);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next2 = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next2) {
          workInProgress = next2;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next2) {
          next2.flags &= 32767;
          workInProgress = next2;
          return;
        }
        next2 = unitOfWork.return;
        null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next2;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root3.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root3,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root3;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root3.callbackNode = null, root3.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root3, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root3);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length2 = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length2), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length2);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root3.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
        var remainingLanes = root3.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root3.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root3);
        remainingLanes = root3.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0);
      }
    }
    function releaseRootPooledCache(root3, remainingLanes) {
      0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root3, wakeable, lanes) {
      var pingCache = root3.pingCache;
      if (null === pingCache) {
        pingCache = root3.pingCache = new PossiblyWeakMap();
        var threadIDs = new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
    }
    function pingSuspendedRoot(root3, wakeable, pingedLanes) {
      var pingCache = root3.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
      root3.warmLanes &= ~pingedLanes;
      workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now2() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root3);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root3) {
      root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (0 !== syncTransitionLanes) {
              var pendingLanes = root$170.pendingLanes;
              if (0 === pendingLanes) var JSCompiler_inline_result = 0;
              else {
                var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
              }
              0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            } else
              JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
              ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now2(), prev2 = null, root3 = firstScheduledRoot; null !== root3; ) {
        var next2 = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
        if (0 === nextLanes)
          root3.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
        else if (prev2 = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root3 = next2;
      }
      0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
      for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root3,
        root3 === currentTime ? suspendedLanes : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      pingedLanes = root3.callbackNode;
      if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root3.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root3.callbackPriority = currentTime;
        root3.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root3.callbackPriority = 2;
      root3.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root3.callbackNode = null, root3.callbackPriority = 0, null;
      var originalCallbackNode = root3.callbackNode;
      if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root3,
        root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root3, now2());
      return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
    }
    function performSyncWorkOnRoot(root3, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root3, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
      var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580
      );
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget2(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                      lastHostComponent++;
                    _instance = 0;
                    for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (; 0 < _instance - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance--;
                    for (; lastHostComponent--; ) {
                      if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$12);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$184, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
              switch (propKey$201) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$201,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$201 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(
                    domElement,
                    tag,
                    type,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$201 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
          for (checked in nextProps)
            if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
            for (defaultChecked in nextProps)
              propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$232 in lastProps)
        propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
      for (lastProp in nextProps)
        propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
          var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
          if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
    }
    var eventsEnabled = null, selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node2 = hydrationInstance, depth = 0;
      do {
        var nextNode = node2.nextSibling;
        parentInstance.removeChild(node2);
        if (nextNode && 8 === nextNode.nodeType)
          if (node2 = nextNode.data, "/$" === node2 || "/&" === node2) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if ("$" === node2 || "$?" === node2 || "$~" === node2 || "$!" === node2 || "&" === node2)
            depth++;
          else if ("html" === node2)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if ("head" === node2) {
            node2 = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node2);
            for (var node$jscomp$0 = node2.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node2.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node2 && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node2 = nextNode;
      } while (node2);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node2 = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node2.nextSibling;
        1 === node2.nodeType ? isHidden ? (node2._stashedDisplay = node2.style.display, node2.style.display = "none") : (node2.style.display = node2._stashedDisplay || "", "" === node2.getAttribute("style") && node2.removeAttribute("style")) : 3 === node2.nodeType && (isHidden ? (node2._stashedText = node2.nodeValue, node2.nodeValue = "") : node2.nodeValue = node2._stashedText || "");
        if (nextNode && 8 === nextNode.nodeType)
          if (node2 = nextNode.data, "/$" === node2)
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            "$" !== node2 && "$?" !== node2 && "$~" !== node2 && "$!" !== node2 || suspenseInstance++;
        node2 = nextNode;
      } while (node2);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node2 = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node2.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node2);
            detachDeletedInstance(node2);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node2.rel.toLowerCase()) continue;
        }
        container.removeChild(node2);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node2) {
      for (; null != node2; node2 = node2.nextSibling) {
        var nodeType = node2.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node2.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node2;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if ("/$" === data || "/&" === data) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" !== data && "/&" !== data || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = new Map(), preconnectsSet = new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign2(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state2 = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state2.loading = 5;
          else {
            href = assign2(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state2.loading |= 1;
            });
            link.addEventListener("error", function() {
              state2.loading |= 2;
            });
            state2.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state: state2
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$244 = styles$243.get(type);
            resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type)
            )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
              JSCompiler_inline_result,
              type,
              pendingProps,
              resource$244.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign2({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state2) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state2.loading = 1 : (key = ownerDocument.createElement("link"), state2.preload = key, key.addEventListener("load", function() {
        return state2.loading |= 1;
      }), key.addEventListener("error", function() {
        return state2.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign2({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$249)
              return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return resource.instance = instance$249;
          case "script":
            instance$249 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$249)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$249))
              instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root3) {
      for (var nodes = root3.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last2 = nodes.length ? nodes[nodes.length - 1] : null, prior = last2, i = 0; i < nodes.length; i++) {
        var node2 = nodes[i];
        if (node2.dataset.precedence === precedence) prior = node2;
        else if (prior !== last2) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache2 = new Map();
        var caches = tagCaches = new Map();
        caches.set(ownerDocument, cache2);
      } else
        caches = tagCaches, cache2 = caches.get(ownerDocument), cache2 || (cache2 = new Map(), caches.set(ownerDocument, cache2));
      if (cache2.has(type)) return cache2;
      cache2.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node2 = ownerDocument[caches];
        if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type && "stylesheet" === node2.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node2.namespaceURI) {
          var nodeKey = node2.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache2.get(nodeKey);
          existing ? existing.push(node2) : cache2.set(nodeKey, [node2]);
        }
      }
      return cache2;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type = props.disabled, "string" === typeof props.precedence && null == type;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    function suspendResource(state2, hoistableRoot, resource, props) {
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state2.count++, state2 = onUnsuspend.bind(state2), hoistableRoot.then(state2, state2));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state2.stylesheets && (state2.stylesheets = new Map());
        state2.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state2.count++, resource = onUnsuspend.bind(state2), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state2, timeoutOffset) {
      state2.stylesheets && 0 === state2.count && insertSuspendedStylesheets(state2, state2.stylesheets);
      return 0 < state2.count || 0 < state2.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state2.stylesheets && insertSuspendedStylesheets(state2, state2.stylesheets);
          if (state2.unsuspend) {
            var unsuspend = state2.unsuspend;
            state2.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state2.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function() {
            state2.waitingForImages = false;
            if (0 === state2.count && (state2.stylesheets && insertSuspendedStylesheets(state2, state2.stylesheets), state2.unsuspend)) {
              var unsuspend = state2.unsuspend;
              state2.unsuspend = null;
              unsuspend();
            }
          },
          (state2.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
        );
        state2.unsuspend = commit;
        return function() {
          state2.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state2, resources) {
      state2.stylesheets = null;
      null !== state2.unsuspend && (state2.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state2), precedencesByRoot = null, onUnsuspend.call(state2));
    }
    function insertStylesheetIntoRoot(root3, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root3);
        if (precedences) var last2 = precedences.get(null);
        else {
          precedences = new Map();
          precedencesByRoot.set(root3, precedences);
          for (var nodes = root3.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i = 0; i < nodes.length; i++) {
            var node2 = nodes[i];
            if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
              precedences.set(node2.dataset.precedence, node2), last2 = node2;
          }
          last2 && precedences.set(null, last2);
        }
        nodes = resource.instance;
        node2 = nodes.getAttribute("data-precedence");
        i = precedences.get(node2) || last2;
        i === last2 && precedences.set(null, nodes);
        precedences.set(node2, nodes);
        this.count++;
        last2 = onUnsuspend.bind(this);
        nodes.addEventListener("load", last2);
        nodes.addEventListener("error", last2);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache3();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root3 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root3 = fiber;
                      root3.pendingLanes |= 2;
                      for (root3.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root3.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now2() + 500, flushSyncWorkAcrossRoots_impl(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget2(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = new Map(), queuedPointerCaptures = new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i = 0; i < formReplayingQueue.length; i += 3) {
            var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
        attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && "react-transition" === event.info && event.intercept({
          handler: function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root3 = this._internalRoot;
      if (null === root3) throw Error(formatProdErrorMessage(409));
      var current = root3.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root3, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root3 = this._internalRoot;
      if (null !== root3) {
        this._internalRoot = null;
        var container = root3.containerInfo;
        updateContainerImpl(root3.current, 2, null, root3, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
    if ("19.2.1" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.1"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.1",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.1"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347
          ), injectedHook = hook$jscomp$inline_2348;
        } catch (err) {
        }
    }
    reactDomClient_production.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    reactDomClient_production.version = "19.2.1";
    return reactDomClient_production;
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client.exports;
    hasRequiredClient = 1;
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      client.exports = requireReactDomClient_production();
    }
    return client.exports;
  }
  var clientExports = requireClient();
  const ReactDOM = getDefaultExportFromCjs(clientExports);
  var compilerRuntime = { exports: {} };
  var reactCompilerRuntime_production = {};
  var hasRequiredReactCompilerRuntime_production;
  function requireReactCompilerRuntime_production() {
    if (hasRequiredReactCompilerRuntime_production) return reactCompilerRuntime_production;
    hasRequiredReactCompilerRuntime_production = 1;
    var ReactSharedInternals = requireReact().__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    reactCompilerRuntime_production.c = function(size2) {
      return ReactSharedInternals.H.useMemoCache(size2);
    };
    return reactCompilerRuntime_production;
  }
  var hasRequiredCompilerRuntime;
  function requireCompilerRuntime() {
    if (hasRequiredCompilerRuntime) return compilerRuntime.exports;
    hasRequiredCompilerRuntime = 1;
    {
      compilerRuntime.exports = requireReactCompilerRuntime_production();
    }
    return compilerRuntime.exports;
  }
  var compilerRuntimeExports = requireCompilerRuntime();
  const getInitTasks = () => {
    return new Promise((resolve, reject) => {
      const BX = window.BX;
      if (!BX?.CrmActivityEditor) {
        reject("BX.CrmActivityEditor is not available");
        return;
      }
      if (BX.CrmActivityEditor.__subscribed) {
        const existingItems = BX.CrmActivityEditor.items;
        const tasksArray = Object.values(existingItems).flatMap((editor) => editor._items.map((item) => item["_settings"]));
        resolve(tasksArray);
        return;
      }
    });
  };
  const getTaskCount = async () => {
    const urlBase = "/bitrix/components/bitrix/crm.activity.list/list.ajax.php";
    const siteID = window.BX.message("SITE_ID");
    const sessionId = window.BX.bitrix_sessid();
    const fullUrl = `${urlBase}?siteID=${siteID}&sessid=${sessionId}`;
    const result = new Promise((resolve, reject) => {
      window.BX.ajax({
        url: fullUrl,
        method: "POST",
        dataType: "json",
        data: {
          ACTION: "GET_ROW_COUNT",
          PARAMS: {
            GRID_ID: "CRM_ACTIVITY_LIST_MY_ACTIVITIES"
          }
        },
        onsuccess: (result2) => {
          resolve(result2.DATA.TEXT.match(/\d+/) ? parseInt(result2.DATA.TEXT.match(/\d+/)[0], 10) : 0);
        },
        onfailure: (result2) => {
          reject(result2);
        }
      });
    });
    return result;
  };
  const LoadPages = async (page = 2) => {
    const btn = document.querySelector(".main-grid-more-btn");
    if (!btn) return false;
    const raw = btn.getAttribute("onclick");
    if (!raw) return false;
    console.log("Raw onclick:", raw);
    const match2 = raw.match(/BX\.ajax\.insertToNode\(([^)]+)\)/);
    if (!match2) return false;
    const args = match2[1].split(",").map((s) => s.trim().replace(/^['"]|['"]$/g, ""));
    const [baseUrl, insertTarget] = args;
    if (!baseUrl) return false;
    const urlObj = new URL(baseUrl, window.location.origin);
    console.log("Next page URL:", urlObj.href);
    console.log("Params:", Object.fromEntries(urlObj.searchParams.entries()));
    for (let i = 2; i <= page; i++) {
      const nextUrl = baseUrl.replace(/page=\d+/, `page=${i}`);
      console.log(`Loading page ${i}:`, nextUrl);
      setTimeout(() => window.BX.ajax.insertToNode(nextUrl, insertTarget), 2500 * i);
    }
    return false;
  };
  function SubscribeBitrixFunc(targetObj, methodName, handler) {
    if (!targetObj || typeof targetObj[methodName] !== "function") {
      console.warn("SubscribeBitrixFunc:   ", methodName);
      return;
    }
    if (targetObj[methodName].__patchedHays) return;
    targetObj[methodName].__patchedHays = true;
    const original = targetObj[methodName];
    targetObj[methodName] = function(...args) {
      const result = original.apply(this, args);
      try {
        const patched = handler.apply(this, [result, ...args]);
        return patched !== void 0 ? patched : result;
      } catch (e) {
        console.error("  SubscribeBitrixFunc handler:", e);
        return result;
      }
    };
    console.log(`SubscribeBitrixFunc:   ${methodName}`);
  }
  const useGetTaskList = () => {
    const $ = compilerRuntimeExports.c(5);
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = new Map();
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    const [deals, setDeals] = reactExports.useState(t0);
    let t1;
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = () => {
        const BX = window.BX;
        if (!BX?.CrmActivityEditor) {
          return;
        }
        if (BX.CrmActivityEditor.__subscribed) {
          return;
        }
        BX.CrmActivityEditor.__subscribed = true;
        getInitTasks().then((tasks) => {
          const newDeals = new Map(tasks.map(_temp$2));
          setDeals(newDeals);
        });
        getTaskCount().then(_temp2$2);
        SubscribeBitrixFunc(BX.CrmActivityEditor, "create", function(originalResult, id2, settings, items) {
          setDeals((prevDeals) => {
            const newDeals_0 = new Map(prevDeals);
            items.forEach((item) => {
              newDeals_0.set(item.ID, item);
            });
            return newDeals_0;
          });
          return originalResult;
        });
      };
      t2 = [];
      $[1] = t1;
      $[2] = t2;
    } else {
      t1 = $[1];
      t2 = $[2];
    }
    reactExports.useEffect(t1, t2);
    let t3;
    if ($[3] !== deals) {
      t3 = [deals, setDeals];
      $[3] = deals;
      $[4] = t3;
    } else {
      t3 = $[4];
    }
    return t3;
  };
  function _temp$2(task) {
    return [task.ID, task];
  }
  function _temp2$2(count) {
    if (count > 100) {
      const pages = Math.ceil(count / 100);
      console.log("Pages:", pages);
      LoadPages(pages);
      return;
    }
  }
  function SubscribeBitrixUI(classNames, handler) {
    const clickListener = (event) => {
      const target = event.target;
      if (!target) return;
      const button = target.closest("button");
      if (!button) return;
      if (classNames.some((cls) => button.classList.contains(cls))) {
        handler(button, event);
      }
    };
    document.addEventListener("click", clickListener);
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node2) => {
          if (!(node2 instanceof HTMLElement)) return;
          const buttons = node2.querySelectorAll("button");
          buttons.forEach((button) => {
            if (classNames.some((cls) => button.classList.contains(cls))) ;
          });
        });
      });
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    return () => {
      document.removeEventListener("click", clickListener);
      observer.disconnect();
    };
  }
  function nextDay(cursor2) {
    const {
      year,
      month,
      weekIndex,
      dayIndex
    } = cursor2;
    const dayOfYear = getDayOfYear(new Date(year, month, dayIndex));
    const daysInYear = getDaysInYear(year);
    if (dayOfYear + 1 <= daysInYear) {
      const date = fromDayOfYear(year, dayOfYear + 1);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    } else {
      const date = fromDayOfYear(year + 1, 1);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    }
  }
  function prevDay(cursor2) {
    const {
      year,
      month,
      weekIndex,
      dayIndex
    } = cursor2;
    const dayOfYear = getDayOfYear(new Date(year, month, dayIndex));
    if (dayOfYear - 1 > 1) {
      const date = fromDayOfYear(year, dayOfYear - 1);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    } else {
      const daysInYear = getDaysInYear(year - 1);
      const date = fromDayOfYear(year - 1, daysInYear);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    }
  }
  const isWeekend = (year, month, day) => {
    if (day < 1) return false;
    const date = new Date(year, month, day);
    const dow = date.getDay();
    return dow === 0 || dow === 6;
  };
  function fromDayOfYear(year, dayOfYear) {
    const date = new Date(year, 0);
    date.setDate(dayOfYear);
    return date;
  }
  function getDayOfYear(date) {
    const start = new Date(date.getFullYear(), 0, 0);
    const diff2 = date.getTime() - start.getTime() + (start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1e3;
    const oneDay = 1e3 * 60 * 60 * 24;
    return Math.floor(diff2 / oneDay);
  }
  const getDaysInYear = (year = ( new Date()).getFullYear()) => new Date(year, 1, 29).getMonth() === 1 ? 366 : 365;
  function nextMonth(year, month) {
    const newMonth = month === 11 ? 0 : month + 1;
    const newYear = month === 11 ? year + 1 : year;
    return {
      year: newYear,
      month: newMonth,
      weekIndex: 0,
      dayIndex: 0
    };
  }
  function prevMonth(year, month) {
    const newMonth = month === 0 ? 11 : month - 1;
    const newYear = month === 0 ? year - 1 : year;
    return {
      year: newYear,
      month: newMonth,
      weekIndex: 0,
      dayIndex: 0
    };
  }
  function getWeeksInMonth(year, month) {
    const first2 = new Date(year, month, 1).getDay();
    const days = new Date(year, month + 1, 0).getDate();
    return Math.ceil((first2 + days) / 7);
  }
  function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }
  function nextWeek(cursor2) {
    const {
      year,
      month,
      weekIndex,
      dayIndex
    } = cursor2;
    const weeks = getWeeksInMonth(year, month);
    const days = new Date(year, month, dayIndex + 7).getDate();
    if (weekIndex + 1 < weeks) {
      return {
        year,
        month,
        weekIndex: weekIndex + 1,
        dayIndex: days
      };
    }
    const next2 = nextMonth(year, month);
    getWeeksInMonth(next2.year, next2.month);
    return {
      year: next2.year,
      month: next2.month,
      weekIndex: 0,
      dayIndex: 0
    };
  }
  function prevWeek(cursor2) {
    const {
      year,
      month,
      weekIndex,
      dayIndex
    } = cursor2;
    const dayOfYear = getDayOfYear(new Date(year, month, dayIndex));
    if (dayOfYear > 7) {
      const date = fromDayOfYear(year, dayOfYear - 7);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    } else {
      const date = fromDayOfYear(year - 1, dayOfYear - 7);
      return {
        year: date.getFullYear(),
        month: date.getMonth(),
        weekIndex: 0,
        dayIndex: date.getDate()
      };
    }
  }
  function getDaysInWeekUnderCursor(cursor2) {
    const days0 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex);
    const daysOffset1 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 1);
    const daysOffset2 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 2);
    const daysOffset3 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 3);
    const daysOffset4 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 4);
    const daysOffset5 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 5);
    const daysOffset6 = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 6);
    return [days0, daysOffset1, daysOffset2, daysOffset3, daysOffset4, daysOffset5, daysOffset6];
  }
  function getNextState(view, cursor2) {
    if (view === "month") {
      return nextMonth(cursor2.year, cursor2.month);
    }
    if (view === "week") {
      return nextWeek(cursor2);
    }
    if (view === "day") {
      return nextDay(cursor2);
    }
    return cursor2;
  }
  function getPrevState(view, cursor2) {
    if (view === "month") {
      return prevMonth(cursor2.year, cursor2.month);
    }
    if (view === "week") {
      return prevWeek(cursor2);
    }
    if (view === "day") {
      const d = prevDay(cursor2);
      if (cursor2.dayIndex > 0) {
        return {
          ...cursor2,
          ...d
        };
      }
      const week = prevWeek(cursor2);
      return {
        ...week,
        dayIndex: 6
      };
    }
    return cursor2;
  }
  function useCalendarNavigator() {
    const $ = compilerRuntimeExports.c(25);
    const today = new Date();
    const [view, setView] = reactExports.useState("month");
    const t0 = today.getFullYear();
    const t1 = today.getMonth();
    const t2 = 0;
    const t3 = today.getDay();
    let t4;
    if ($[0] !== t0 || $[1] !== t1 || $[2] !== t3) {
      t4 = {
        year: t0,
        month: t1,
        weekIndex: t2,
        dayIndex: t3
      };
      $[0] = t0;
      $[1] = t1;
      $[2] = t3;
      $[3] = t4;
    } else {
      t4 = $[3];
    }
    const [cursor2, setCursor] = reactExports.useState(t4);
    let t5;
    if ($[4] !== setView) {
      t5 = (year, month) => {
        reactExports.startTransition(() => {
          setView("month");
          setCursor((c) => ({
            ...c,
            year,
            month,
            weekIndex: 0,
            dayIndex: 0
          }));
        });
      };
      $[4] = setView;
      $[5] = t5;
    } else {
      t5 = $[5];
    }
    const goToMonth = t5;
    let t6;
    if ($[6] !== setView) {
      t6 = (weekIndex, year_0, month_0) => {
        reactExports.startTransition(() => {
          setView("week");
          setCursor((c_0) => ({
            ...c_0,
            year: year_0 ?? c_0.year,
            month: month_0 ?? c_0.month,
            weekIndex,
            dayIndex: 0
          }));
        });
      };
      $[6] = setView;
      $[7] = t6;
    } else {
      t6 = $[7];
    }
    const goToWeek = t6;
    let t7;
    if ($[8] !== setView) {
      t7 = (dayIndex, y, m) => {
        reactExports.startTransition(() => {
          console.log("goToDay", dayIndex, y, m);
          setView("day");
          setCursor((c_1) => ({
            ...c_1,
            year: y ?? c_1.year,
            month: m ?? c_1.month,
            dayIndex
          }));
        });
      };
      $[8] = setView;
      $[9] = t7;
    } else {
      t7 = $[9];
    }
    const goToDay = t7;
    let t8;
    if ($[10] !== view) {
      t8 = () => {
        reactExports.startTransition(() => {
          setCursor((c_2) => getNextState(view, c_2));
        });
      };
      $[10] = view;
      $[11] = t8;
    } else {
      t8 = $[11];
    }
    const next2 = t8;
    let t9;
    if ($[12] !== view) {
      t9 = () => {
        reactExports.startTransition(() => {
          setCursor((c_3) => getPrevState(view, c_3));
        });
      };
      $[12] = view;
      $[13] = t9;
    } else {
      t9 = $[13];
    }
    const prev2 = t9;
    let t10;
    if ($[14] !== setView) {
      t10 = (view_0) => reactExports.startTransition(() => {
        setView(view_0);
      });
      $[14] = setView;
      $[15] = t10;
    } else {
      t10 = $[15];
    }
    let t11;
    if ($[16] !== cursor2 || $[17] !== goToDay || $[18] !== goToMonth || $[19] !== goToWeek || $[20] !== next2 || $[21] !== prev2 || $[22] !== t10 || $[23] !== view) {
      t11 = {
        view,
        cursor: cursor2,
        setView: t10,
        next: next2,
        prev: prev2,
        goToMonth,
        goToWeek,
        goToDay
      };
      $[16] = cursor2;
      $[17] = goToDay;
      $[18] = goToMonth;
      $[19] = goToWeek;
      $[20] = next2;
      $[21] = prev2;
      $[22] = t10;
      $[23] = view;
      $[24] = t11;
    } else {
      t11 = $[24];
    }
    return t11;
  }
  function memoize(fn) {
    var cache2 = Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid$1 = memoize(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
);
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = (function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert3(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  })();
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs$1 = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match$3(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace$1(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char() {
    return character;
  }
  function prev$1() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next$1() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
case 59:
      case 123:
      case 125:
        return 4;
case 58:
        return 3;
case 34:
      case 39:
      case 40:
      case 91:
        return 2;
case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next$1();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next$1())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next$1() == 32));
  }
  function delimiter(type) {
    while (next$1())
      switch (character) {
case type:
          return position;
case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
case 40:
          if (type === 41)
            delimiter(type);
          break;
case 92:
          next$1();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next$1())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next$1());
  }
  function identifier(index) {
    while (!token(peek()))
      next$1();
    return slice(index, position);
  }
  function compile(value) {
    return dealloc(parse$1("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse$1(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next$1()) {
case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next$1(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
case 0:
            case 125:
              scanning = 0;
case 59 + offset2:
              if (ampersand == -1) characters2 = replace$1(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
case 59:
              characters2 += ";";
default:
              append(reference = ruleset(characters2, root2, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse$1(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
case 64:
              if (peek() === 45)
                characters2 += delimit(next$1());
              atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size2 = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index; ++i)
      for (var x2 = 0, y = substr(value, post + 1, post = abs$1(j = points[i])), z2 = value; x2 < size2; ++x2)
        if (z2 = trim(j > 0 ? rule[x2] + " " + y : replace$1(y, /&\f/g, rule[x2])))
          props[k++] = z2;
    return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize$1(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  function middleware(collection2) {
    var length2 = sizeof(collection2);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection2[i](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next$1();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
default:
          parsed[index] += from(character2);
      }
    } while (character2 = next$1());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent ||

element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
value.charCodeAt(0) === 108 &&
value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
case 5103:
        return WEBKIT + "print-" + value + value;
case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
case 5187:
        return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
case 5548:
        return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
case 5292:
        return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
case 6060:
        return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
case 4554:
        return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
case 6187:
        return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
case 5495:
      case 3959:
        return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
case 4968:
        return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
case 109:
            if (charat(value, length2 + 4) !== 45) break;
case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
case 115:
            return ~indexof(value, "stretch") ? prefix(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
case 4949:
        if (charat(value, length2 + 1) !== 115) break;
case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
case 107:
            return replace$1(value, ":", ":" + WEBKIT) + value;
case 101:
            return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
case 5936:
        switch (charat(value, length2 + 11)) {
case 114:
            return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
case 108:
            return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
case 45:
            return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize$1([copy(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match$3(value, /(::plac\w+|:read-\w+)/)) {
case ":read-only":
              case ":read-write":
                return serialize$1([copy(element, {
                  props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
case "::placeholder":
                return serialize$1([copy(element, {
                  props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call(

document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles) {
        return serialize$1(compile(styles), serializer);
      };
      _insert = function insert3(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache2.inserted[serialized.name] = true;
        }
      };
    }
    var cache2 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache2.sheet.hydrate(nodesToHydrate);
    return cache2;
  };
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  var hasRequiredReactIs_production_min;
  function requireReactIs_production_min() {
    if (hasRequiredReactIs_production_min) return reactIs_production_min;
    hasRequiredReactIs_production_min = 1;
    var b2 = "function" === typeof Symbol && Symbol.for, c = b2 ? Symbol.for("react.element") : 60103, d = b2 ? Symbol.for("react.portal") : 60106, e = b2 ? Symbol.for("react.fragment") : 60107, f = b2 ? Symbol.for("react.strict_mode") : 60108, g = b2 ? Symbol.for("react.profiler") : 60114, h = b2 ? Symbol.for("react.provider") : 60109, k = b2 ? Symbol.for("react.context") : 60110, l = b2 ? Symbol.for("react.async_mode") : 60111, m = b2 ? Symbol.for("react.concurrent_mode") : 60111, n = b2 ? Symbol.for("react.forward_ref") : 60112, p = b2 ? Symbol.for("react.suspense") : 60113, q = b2 ? Symbol.for("react.suspense_list") : 60120, r = b2 ? Symbol.for("react.memo") : 60115, t = b2 ? Symbol.for("react.lazy") : 60116, v = b2 ? Symbol.for("react.block") : 60121, w = b2 ? Symbol.for("react.fundamental") : 60117, x2 = b2 ? Symbol.for("react.responder") : 60118, y = b2 ? Symbol.for("react.scope") : 60119;
    function z2(a) {
      if ("object" === typeof a && null !== a) {
        var u = a.$$typeof;
        switch (u) {
          case c:
            switch (a = a.type, a) {
              case l:
              case m:
              case e:
              case g:
              case f:
              case p:
                return a;
              default:
                switch (a = a && a.$$typeof, a) {
                  case k:
                  case n:
                  case t:
                  case r:
                  case h:
                    return a;
                  default:
                    return u;
                }
            }
          case d:
            return u;
        }
      }
    }
    function A(a) {
      return z2(a) === m;
    }
    reactIs_production_min.AsyncMode = l;
    reactIs_production_min.ConcurrentMode = m;
    reactIs_production_min.ContextConsumer = k;
    reactIs_production_min.ContextProvider = h;
    reactIs_production_min.Element = c;
    reactIs_production_min.ForwardRef = n;
    reactIs_production_min.Fragment = e;
    reactIs_production_min.Lazy = t;
    reactIs_production_min.Memo = r;
    reactIs_production_min.Portal = d;
    reactIs_production_min.Profiler = g;
    reactIs_production_min.StrictMode = f;
    reactIs_production_min.Suspense = p;
    reactIs_production_min.isAsyncMode = function(a) {
      return A(a) || z2(a) === l;
    };
    reactIs_production_min.isConcurrentMode = A;
    reactIs_production_min.isContextConsumer = function(a) {
      return z2(a) === k;
    };
    reactIs_production_min.isContextProvider = function(a) {
      return z2(a) === h;
    };
    reactIs_production_min.isElement = function(a) {
      return "object" === typeof a && null !== a && a.$$typeof === c;
    };
    reactIs_production_min.isForwardRef = function(a) {
      return z2(a) === n;
    };
    reactIs_production_min.isFragment = function(a) {
      return z2(a) === e;
    };
    reactIs_production_min.isLazy = function(a) {
      return z2(a) === t;
    };
    reactIs_production_min.isMemo = function(a) {
      return z2(a) === r;
    };
    reactIs_production_min.isPortal = function(a) {
      return z2(a) === d;
    };
    reactIs_production_min.isProfiler = function(a) {
      return z2(a) === g;
    };
    reactIs_production_min.isStrictMode = function(a) {
      return z2(a) === f;
    };
    reactIs_production_min.isSuspense = function(a) {
      return z2(a) === p;
    };
    reactIs_production_min.isValidElementType = function(a) {
      return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x2 || a.$$typeof === y || a.$$typeof === v);
    };
    reactIs_production_min.typeOf = z2;
    return reactIs_production_min;
  }
  var hasRequiredReactIs;
  function requireReactIs() {
    if (hasRequiredReactIs) return reactIs.exports;
    hasRequiredReactIs = 1;
    {
      reactIs.exports = requireReactIs_production_min();
    }
    return reactIs.exports;
  }
  var hoistNonReactStatics_cjs;
  var hasRequiredHoistNonReactStatics_cjs;
  function requireHoistNonReactStatics_cjs() {
    if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
    hasRequiredHoistNonReactStatics_cjs = 1;
    var reactIs2 = requireReactIs();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs2.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    hoistNonReactStatics_cjs = hoistNonReactStatics;
    return hoistNonReactStatics_cjs;
  }
  requireHoistNonReactStatics_cjs();
  var isBrowser$2 = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
    var className = cache2.key + "-" + serialized.name;
    if (




(isStringTag === false ||



isBrowser$2 === false) && cache2.registered[className] === void 0
    ) {
      cache2.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
    registerStyles(cache2, serialized, isStringTag);
    var className = cache2.key + "-" + serialized.name;
    if (cache2.inserted[serialized.name] === void 0) {
      var current = serialized;
      do {
        cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
        current = current.next;
      } while (current !== void 0);
    }
  };
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^=
k >>> 24;
      h =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^
(h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h =
(h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h =
(h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor$1 = {
              name: p1,
              styles: p2,
              next: cursor$1
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor$1 = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor$1
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor$1 = {
                name: next2.name,
                styles: next2.styles,
                next: cursor$1
              };
              next2 = next2.next;
            }
          }
          var styles = serializedStyles.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor$1;
          var result = interpolation(mergedProps);
          cursor$1 = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor$1;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor$1 = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor$1
    };
  }
  var syncFallback$1 = function syncFallback(create) {
    return create();
  };
  var useInsertionEffect$1 = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback$1 = useInsertionEffect$1 || syncFallback$1;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect$1 || reactExports.useLayoutEffect;
  var EmotionCacheContext = reactExports.createContext(





typeof HTMLElement !== "undefined" ? createCache({
      key: "css"
    }) : null
  );
  EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return reactExports.forwardRef(function(props, ref) {
      var cache2 = reactExports.useContext(EmotionCacheContext);
      return func(props, cache2, ref);
    });
  };
  var ThemeContext = reactExports.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type;
    return newProps;
  };
  var Insertion$1 = function Insertion(_ref) {
    var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
    registerStyles(cache2, serialized, isStringTag);
    useInsertionEffectAlwaysWithSyncFallback$1(function() {
      return insertStyles(cache2, serialized, isStringTag);
    });
    return null;
  };
  var Emotion = withEmotionCache(function(props, cache2, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
      cssProp = cache2.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
    className += cache2.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion$1, {
      cache: cache2,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), reactExports.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;
  var jsx = function jsx2(type, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return reactExports.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);
    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = args[i];
    }
    return reactExports.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx) {
    var JSX;
(function(_JSX) {
    })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
  })(jsx || (jsx = {}));
  var Global = withEmotionCache(function(props, cache2) {
    var styles = props.styles;
    var serialized = serializeStyles([styles], void 0, reactExports.useContext(ThemeContext));
    var sheetRef = reactExports.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache2.key + "-global";
      var sheet = new cache2.sheet.constructor({
        key,
        nonce: cache2.sheet.nonce,
        container: cache2.sheet.container,
        speedy: cache2.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache2.sheet.tags.length) {
        sheet.before = cache2.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache2]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache2, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache2.insert("", serialized, sheet, false);
    }, [cache2, serialized.name]);
    return null;
  });
  var syncFallback2 = function syncFallback3(create) {
    return create();
  };
  var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback2;
  function callAll$1(...fns) {
    return function mergedFn(...args) {
      fns.forEach((fn) => fn?.(...args));
    };
  }
  const clsx$1 = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
  const eventRegex = /^on[A-Z]/;
  function mergeProps$1(...args) {
    let result = {};
    for (let props of args) {
      for (let key in result) {
        if (eventRegex.test(key) && typeof result[key] === "function" && typeof props[key] === "function") {
          result[key] = callAll$1(result[key], props[key]);
          continue;
        }
        if (key === "className" || key === "class") {
          result[key] = clsx$1(result[key], props[key]);
          continue;
        }
        if (key === "style") {
          result[key] = Object.assign({}, result[key] ?? {}, props[key] ?? {});
          continue;
        }
        result[key] = props[key] !== void 0 ? props[key] : result[key];
      }
      for (let key in props) {
        if (result[key] === void 0) {
          result[key] = props[key];
        }
      }
    }
    return result;
  }
  const majorVersion = parseInt(reactExports.version.split(".")[0], 10);
  const shouldReturnCleanup = majorVersion >= 19;
  function assignRef(ref, value) {
    if (ref == null) return;
    if (typeof ref === "function") {
      return ref(value);
    }
    try {
      ref.current = value;
    } catch (error) {
      throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
    }
  }
  function mergeRefs(...refs) {
    const availableRefs = refs.filter((ref) => ref != null);
    if (shouldReturnCleanup) {
      const cleanupMap = new Map();
      return (node2) => {
        availableRefs.forEach((ref) => {
          const cleanup = assignRef(ref, node2);
          if (cleanup) {
            cleanupMap.set(ref, cleanup);
          }
        });
        return () => {
          availableRefs.forEach((ref) => {
            const cleanup = cleanupMap.get(ref);
            if (cleanup && typeof cleanup === "function") {
              cleanup();
            } else {
              assignRef(ref, null);
            }
          });
          cleanupMap.clear();
        };
      };
    } else {
      return (node2) => {
        availableRefs.forEach((ref) => {
          assignRef(ref, node2);
        });
      };
    }
  }
  function compact$1(object) {
    const clone2 = Object.assign({}, object);
    for (let key in clone2) {
      if (clone2[key] === void 0) delete clone2[key];
    }
    return clone2;
  }
  const isObject$3 = (v) => v != null && typeof v === "object" && !Array.isArray(v);
  const isString$1 = (v) => typeof v === "string";
  const isFunction$1 = (v) => typeof v === "function";
  const cx = (...classNames) => {
    const classes = [];
    for (let i = 0; i < classNames.length; i++) {
      const className = classNames[i];
      if (!isString$1(className)) continue;
      const trimmed = className.trim();
      if (trimmed) classes.push(trimmed);
    }
    return classes.join(" ");
  };
  function interopDefault(mod2) {
    return mod2.default || mod2;
  }
  function getElementRef(el) {
    const version = reactExports.version;
    if (!isString$1(version)) return el?.ref;
    if (version.startsWith("18.")) return el?.ref;
    return el?.props?.ref;
  }
  const uniq$1 = (...items) => {
    const set = items.reduce((acc, curr) => {
      if (curr != null) curr.forEach((item) => acc.add(item));
      return acc;
    }, new Set([]));
    return Array.from(set);
  };
  function getErrorMessage$1(hook, provider) {
    return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
  }
  function createContext$1(options = {}) {
    const {
      name,
      strict = true,
      hookName = "useContext",
      providerName = "Provider",
      errorMessage,
      defaultValue
    } = options;
    const Context = reactExports.createContext(defaultValue);
    Context.displayName = name;
    function useContext$1() {
      const context = reactExports.useContext(Context);
      if (!context && strict) {
        const error = new Error(
          errorMessage ?? getErrorMessage$1(hookName, providerName)
        );
        error.name = "ContextError";
        Error.captureStackTrace?.(error, useContext$1);
        throw error;
      }
      return context;
    }
    return [Context.Provider, useContext$1, Context];
  }
  const [ChakraContextProvider, useChakraContext] = createContext$1({
    name: "ChakraContext",
    strict: true,
    providerName: "<ChakraProvider />"
  });
  function ChakraProvider(props) {
    const { value: sys, children } = props;
    return jsxRuntimeExports.jsxs(ChakraContextProvider, { value: sys, children: [
      !sys._config.disableLayers && jsxRuntimeExports.jsx(Global, { styles: sys.layers.atRule }),
jsxRuntimeExports.jsx(Global, { styles: sys._global }),
      children
    ] });
  }
  const splitPropFn = (props, predicate) => {
    const rest = {};
    const result = {};
    const allKeys = Object.keys(props);
    for (const key of allKeys) {
      if (predicate(key)) {
        result[key] = props[key];
      } else {
        rest[key] = props[key];
      }
    }
    return [result, rest];
  };
  const splitProps = (props, keys) => {
    const predicate = isFunction$1(keys) ? keys : (key) => keys.includes(key);
    return splitPropFn(props, predicate);
  };
  const htmlProps = new Set([
    "htmlWidth",
    "htmlHeight",
    "htmlSize",
    "htmlTranslate"
  ]);
  function isHtmlProp(prop) {
    return typeof prop === "string" && htmlProps.has(prop);
  }
  function useResolvedProps(inProps, cvaRecipe, shouldForwardProps) {
    const { css: css2, isValidProperty } = useChakraContext();
    const { children, ...props } = inProps;
    const result = reactExports.useMemo(() => {
      const [forwardedProps, restProps_B] = splitProps(
        props,
        (key) => shouldForwardProps(key, cvaRecipe.variantKeys)
      );
      const [variantProps2, restProps_C] = splitProps(
        restProps_B,
        cvaRecipe.variantKeys
      );
      const [styleProps, elementProps] = splitProps(restProps_C, isValidProperty);
      return {
        forwardedProps,
        variantProps: variantProps2,
        styleProps,
        elementProps
      };
    }, [cvaRecipe.variantKeys, shouldForwardProps, props, isValidProperty]);
    const { css: cssStyles, ...propStyles } = result.styleProps;
    const cvaStyles = reactExports.useMemo(() => {
      const variantProps2 = { ...result.variantProps };
      const hasColorPalette = cvaRecipe.variantKeys.includes("colorPalette");
      const hasOrientation = cvaRecipe.variantKeys.includes("orientation");
      if (!hasColorPalette) {
        variantProps2.colorPalette = props.colorPalette;
      }
      if (!hasOrientation) {
        variantProps2.orientation = props.orientation;
      }
      return cvaRecipe(variantProps2);
    }, [cvaRecipe, result.variantProps, props.colorPalette, props.orientation]);
    const styles = reactExports.useMemo(() => {
      return css2(cvaStyles, ...toArray$1(cssStyles), propStyles);
    }, [css2, cvaStyles, cssStyles, propStyles]);
    return {
      styles,
      props: {
        ...result.forwardedProps,
        ...result.elementProps,
        children
      }
    };
  }
  const toArray$1 = (val) => {
    const res = Array.isArray(val) ? val : [val];
    return res.filter(Boolean).flat();
  };
  const isPropValid = interopDefault(isPropValid$1);
  const testOmitPropsOnStringTag = isPropValid;
  const testOmitPropsOnComponent = (key) => key !== "theme";
  const composeShouldForwardProps = (tag, options, isReal) => {
    let shouldForwardProp;
    if (options) {
      const optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? (propName) => tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName) : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp !== "function" && isReal) {
      shouldForwardProp = tag.__emotion_forwardProp;
    }
    return shouldForwardProp;
  };
  let isBrowser$1 = typeof document !== "undefined";
  const Insertion2 = ({ cache: cache2, serialized, isStringTag }) => {
    registerStyles(cache2, serialized, isStringTag);
    const rules = useInsertionEffectAlwaysWithSyncFallback(
      () => insertStyles(cache2, serialized, isStringTag)
    );
    if (!isBrowser$1 && rules !== void 0) {
      let serializedNames = serialized.name;
      let next2 = serialized.next;
      while (next2 !== void 0) {
        serializedNames = cx(serializedNames, next2.name);
        next2 = next2.next;
      }
      return jsxRuntimeExports.jsx(
        "style",
        {
          ...{
            [`data-emotion`]: cx(cache2.key, serializedNames),
            dangerouslySetInnerHTML: { __html: rules },
            nonce: cache2.sheet.nonce
          }
        }
      );
    }
    return null;
  };
  const exceptionPropMap = {
    path: ["d"],
    text: ["x", "y"],
    circle: ["cx", "cy", "r"],
    rect: ["width", "height", "x", "y", "rx", "ry"],
    ellipse: ["cx", "cy", "rx", "ry"],
    g: ["transform"],
    stop: ["offset", "stopOpacity"]
  };
  const hasProp$1 = (obj, prop) => {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  const createStyled = (tag, configOrCva = {}, options = {}) => {
    if (hasProp$1(exceptionPropMap, tag)) {
      options.forwardProps || (options.forwardProps = []);
      const props = exceptionPropMap[tag];
      options.forwardProps = uniq$1([...options.forwardProps, ...props]);
    }
    const isReal = tag.__emotion_real === tag;
    const baseTag = isReal && tag.__emotion_base || tag;
    let identifierName;
    let targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    let styles = [];
    const Styled = withEmotionCache((inProps, cache2, ref) => {
      const { cva, isValidProperty } = useChakraContext();
      const cvaFn = configOrCva.__cva__ ? configOrCva : cva(configOrCva);
      const cvaRecipe = mergeCva$1(tag.__emotion_cva, cvaFn);
      const createShouldForwardProps = (props2) => {
        return (prop, variantKeys) => {
          if (props2.includes(prop)) return true;
          return !variantKeys?.includes(prop) && !isValidProperty(prop);
        };
      };
      if (!options.shouldForwardProp && options.forwardProps) {
        options.shouldForwardProp = createShouldForwardProps(options.forwardProps);
      }
      const fallbackShouldForwardProp = (prop, variantKeys) => {
        const emotionSfp = typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
        const chakraSfp = !variantKeys?.includes(prop) && !isValidProperty(prop);
        return emotionSfp(prop) && chakraSfp;
      };
      const shouldForwardProp = composeShouldForwardProps(tag, options, isReal) || fallbackShouldForwardProp;
      const propsWithDefault = reactExports.useMemo(
        () => Object.assign({}, options.defaultProps, compact$1(inProps)),
        [inProps]
      );
      const { props, styles: styleProps } = useResolvedProps(
        propsWithDefault,
        cvaRecipe,
        shouldForwardProp
      );
      let className = "";
      let classInterpolations = [styleProps];
      let mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (let key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(
          cache2.registered,
          classInterpolations,
          props.className
        );
      } else if (props.className != null) {
        className = cx(className, props.className);
      }
      const serialized = serializeStyles(
        styles.concat(classInterpolations),
        cache2.registered,
        mergedProps
      );
      if (serialized.styles) {
        className = cx(className, `${cache2.key}-${serialized.name}`);
      }
      if (targetClassName !== void 0) {
        className = cx(className, targetClassName);
      }
      const shouldUseAs = !shouldForwardProp("as");
      let FinalTag = shouldUseAs && props.as || baseTag;
      let finalProps = {};
      for (let prop in props) {
        if (shouldUseAs && prop === "as") continue;
        if (isHtmlProp(prop)) {
          const nativeProp = prop.replace("html", "").toLowerCase();
          finalProps[nativeProp] = props[prop];
          continue;
        }
        if (shouldForwardProp(prop)) {
          finalProps[prop] = props[prop];
        }
      }
      let classNameToUse = className.trim();
      if (classNameToUse) {
        finalProps.className = classNameToUse;
      } else {
        Reflect.deleteProperty(finalProps, "className");
      }
      finalProps.ref = ref;
      const forwardAsChild = options.forwardAsChild || options.forwardProps?.includes("asChild");
      if (props.asChild && !forwardAsChild) {
        const child = reactExports.isValidElement(props.children) ? reactExports.Children.only(props.children) : reactExports.Children.toArray(props.children).find(reactExports.isValidElement);
        if (!child) {
          throw new Error("[chakra-ui > factory] No valid child found");
        }
        FinalTag = child.type;
        finalProps.children = null;
        Reflect.deleteProperty(finalProps, "asChild");
        finalProps = mergeProps$1(finalProps, child.props);
        finalProps.ref = mergeRefs(ref, getElementRef(child));
      }
      if (finalProps.as && forwardAsChild) {
        finalProps.as = void 0;
        return jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
jsxRuntimeExports.jsx(
            Insertion2,
            {
              cache: cache2,
              serialized,
              isStringTag: typeof FinalTag === "string"
            }
          ),
jsxRuntimeExports.jsx(FinalTag, { asChild: true, ...finalProps, children: jsxRuntimeExports.jsx(props.as, { children: finalProps.children }) })
        ] });
      }
      return jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
jsxRuntimeExports.jsx(
          Insertion2,
          {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }
        ),
jsxRuntimeExports.jsx(FinalTag, { ...finalProps })
      ] });
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : `chakra(${typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component"})`;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_forwardProp = options.shouldForwardProp;
    Styled.__emotion_cva = configOrCva;
    Object.defineProperty(Styled, "toString", {
      value() {
        return `.${targetClassName}`;
      }
    });
    return Styled;
  };
  const styledFn = createStyled.bind();
  const cache = new Map();
  const chakraImpl = new Proxy(styledFn, {
    apply(_2, __, args) {
      return styledFn(...args);
    },
    get(_2, el) {
      if (!cache.has(el)) {
        cache.set(el, styledFn(el));
      }
      return cache.get(el);
    }
  });
  const chakra = chakraImpl;
  const mergeCva$1 = (cvaA, cvaB) => {
    if (cvaA && !cvaB) return cvaA;
    if (!cvaA && cvaB) return cvaB;
    return cvaA.merge(cvaB);
  };
  const Box = chakra("div");
  Box.displayName = "Box";
  const Square = reactExports.forwardRef(
    function Square2(props, ref) {
      const { size: size2, ...rest } = props;
      return jsxRuntimeExports.jsx(
        Box,
        {
          ...rest,
          ref,
          boxSize: size2,
          css: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flexShrink: 0,
            flexGrow: 0,
            ...props.css
          }
        }
      );
    }
  );
  Square.displayName = "Square";
  const Circle = reactExports.forwardRef(
    function Circle2(props, ref) {
      const { size: size2, ...rest } = props;
      return jsxRuntimeExports.jsx(Square, { size: size2, ref, borderRadius: "9999px", ...rest });
    }
  );
  Circle.displayName = "Circle";
  const EMPTY_STYLES = Object.freeze({});
  const EMPTY_SLOT_STYLES = Object.freeze(
    {}
  );
  function useRecipe(options) {
    const { key, recipe: recipeProp } = options;
    const sys = useChakraContext();
    return reactExports.useMemo(() => {
      const recipe = recipeProp || (key != null ? sys.getRecipe(key) : {});
      return sys.cva(structuredClone(recipe));
    }, [key, recipeProp, sys]);
  }
  const upperFirst$1 = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  function createRecipeContext(options) {
    const { key: recipeKey, recipe: recipeConfig } = options;
    const contextName = upperFirst$1(
      recipeKey || recipeConfig.className || "Component"
    );
    const [PropsProvider, usePropsContext2] = createContext$1({
      strict: false,
      name: `${contextName}PropsContext`,
      providerName: `${contextName}PropsContext`
    });
    function useRecipeResult2(props) {
      const { unstyled, ...restProps } = props;
      const recipe = useRecipe({
        key: recipeKey,
        recipe: restProps.recipe || recipeConfig
      });
      const [variantProps2, otherProps] = reactExports.useMemo(
        () => recipe.splitVariantProps(restProps),
        [recipe, restProps]
      );
      const styles = unstyled ? EMPTY_STYLES : recipe(variantProps2);
      return {
        styles,
        className: recipe.className,
        props: otherProps
      };
    }
    const withContext2 = (Component, options2) => {
      const SuperComponent = chakra(Component, {}, options2);
      const StyledComponent = reactExports.forwardRef((inProps, ref) => {
        const propsContext = usePropsContext2();
        const props = reactExports.useMemo(
          () => mergeProps$1(propsContext, inProps),
          [inProps, propsContext]
        );
        const { styles, className, props: localProps } = useRecipeResult2(props);
        return jsxRuntimeExports.jsx(
          SuperComponent,
          {
            ...localProps,
            ref,
            css: [styles, props.css],
            className: cx(className, props.className)
          }
        );
      });
      StyledComponent.displayName = Component.displayName || Component.name;
      return StyledComponent;
    };
    function withPropsProvider() {
      return PropsProvider;
    }
    return {
      withContext: withContext2,
      PropsProvider,
      withPropsProvider,
      usePropsContext: usePropsContext2,
      useRecipeResult: useRecipeResult2
    };
  }
  function toArray(v) {
    if (v == null) return [];
    return Array.isArray(v) ? v : [v];
  }
  var first = (v) => v[0];
  var last = (v) => v[v.length - 1];
  var has = (v, t) => v.indexOf(t) !== -1;
  var add$1 = (v, ...items) => v.concat(items);
  var remove$1 = (v, ...items) => v.filter((t) => !items.includes(t));
  var removeAt = (v, i) => v.filter((_2, idx) => idx !== i);
  var uniq = (v) => Array.from(new Set(v));
  var diff$1 = (a, b2) => {
    const set = new Set(b2);
    return a.filter((t) => !set.has(t));
  };
  var addOrRemove = (v, item) => has(v, item) ? remove$1(v, item) : add$1(v, item);
  function nextIndex(v, idx, opts = {}) {
    const { step = 1, loop = true } = opts;
    const next2 = idx + step;
    const len = v.length;
    const last2 = len - 1;
    if (idx === -1) return step > 0 ? 0 : last2;
    if (next2 < 0) return loop ? last2 : 0;
    if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
    return next2;
  }
  function next(v, idx, opts = {}) {
    return v[nextIndex(v, idx, opts)];
  }
  function prevIndex(v, idx, opts = {}) {
    const { step = 1, loop = true } = opts;
    return nextIndex(v, idx, { step: -step, loop });
  }
  function prev(v, index, opts = {}) {
    return v[prevIndex(v, index, opts)];
  }
  function partition(arr, fn) {
    return arr.reduce(
      ([pass, fail], value) => {
        if (fn(value)) pass.push(value);
        else fail.push(value);
        return [pass, fail];
      },
      [[], []]
    );
  }
  var isArrayLike = (value) => value?.constructor.name === "Array";
  var isArrayEqual = (a, b2) => {
    if (a.length !== b2.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!isEqual(a[i], b2[i])) return false;
    }
    return true;
  };
  var isEqual = (a, b2) => {
    if (Object.is(a, b2)) return true;
    if (a == null && b2 != null || a != null && b2 == null) return false;
    if (typeof a?.isEqual === "function" && typeof b2?.isEqual === "function") {
      return a.isEqual(b2);
    }
    if (typeof a === "function" && typeof b2 === "function") {
      return a.toString() === b2.toString();
    }
    if (isArrayLike(a) && isArrayLike(b2)) {
      return isArrayEqual(Array.from(a), Array.from(b2));
    }
    if (!(typeof a === "object") || !(typeof b2 === "object")) return false;
    const keys = Object.keys(b2 ?? Object.create(null));
    const length2 = keys.length;
    for (let i = 0; i < length2; i++) {
      const hasKey = Reflect.has(a, keys[i]);
      if (!hasKey) return false;
    }
    for (let i = 0; i < length2; i++) {
      const key = keys[i];
      if (!isEqual(a[key], b2[key])) return false;
    }
    return true;
  };
  var isArray = (v) => Array.isArray(v);
  var isBoolean = (v) => v === true || v === false;
  var isObjectLike = (v) => v != null && typeof v === "object";
  var isObject$2 = (v) => isObjectLike(v) && !isArray(v);
  var isString = (v) => typeof v === "string";
  var isFunction = (v) => typeof v === "function";
  var isNull = (v) => v == null;
  var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  var baseGetTag = (v) => Object.prototype.toString.call(v);
  var fnToString = Function.prototype.toString;
  var objectCtorString = fnToString.call(Object);
  var isPlainObject = (v) => {
    if (!isObjectLike(v) || baseGetTag(v) != "[object Object]" || isFrameworkElement(v)) return false;
    const proto = Object.getPrototypeOf(v);
    if (proto === null) return true;
    const Ctor = hasProp(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;
  };
  var isReactElement = (x2) => typeof x2 === "object" && x2 !== null && "$$typeof" in x2 && "props" in x2;
  var isVueElement = (x2) => typeof x2 === "object" && x2 !== null && "__v_isVNode" in x2;
  var isFrameworkElement = (x2) => isReactElement(x2) || isVueElement(x2);
  var identity = (v) => v();
  var noop$2 = () => {
  };
  var callAll = (...fns) => (...a) => {
    fns.forEach(function(fn) {
      fn?.(...a);
    });
  };
  function match$2(key, record, ...args) {
    if (key in record) {
      const fn = record[key];
      return isFunction(fn) ? fn(...args) : fn;
    }
    const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
    Error.captureStackTrace?.(error, match$2);
    throw error;
  }
  var tryCatch = (fn, fallback2) => {
    try {
      return fn();
    } catch (error) {
      if (error instanceof Error) {
        Error.captureStackTrace?.(error, tryCatch);
      }
      return fallback2?.();
    }
  };
  var { floor: floor$1, abs, round: round$1, min: min$1, max: max$1, pow, sign } = Math;
  var isNaN$1 = (v) => Number.isNaN(v);
  var nan = (v) => isNaN$1(v) ? 0 : v;
  var mod = (v, m) => (v % m + m) % m;
  var wrap$2 = (v, vmax) => (v % vmax + vmax) % vmax;
  var isValueAtMax = (v, vmax) => nan(v) >= vmax;
  var isValueAtMin = (v, vmin) => nan(v) <= vmin;
  var isValueWithinRange = (v, vmin, vmax) => {
    const value = nan(v);
    const minCheck = vmin == null || value >= vmin;
    const maxCheck = vmax == null || value <= vmax;
    return minCheck && maxCheck;
  };
  var roundValue = (v, vmin, step) => round$1((nan(v) - vmin) / step) * step + vmin;
  var clampValue = (v, vmin, vmax) => min$1(max$1(nan(v), vmin), vmax);
  var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
  var getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);
  var roundToStepPrecision = (v, step) => {
    let rv = v;
    let ss = step.toString();
    let pi = ss.indexOf(".");
    let p = pi >= 0 ? ss.length - pi : 0;
    if (p > 0) {
      let pw = pow(10, p);
      rv = round$1(rv * pw) / pw;
    }
    return rv;
  };
  var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor$1(v * dpr + 0.5) / dpr : round$1(v);
  var snapValueToStep = (v, vmin, vmax, step) => {
    const min2 = vmin != null ? Number(vmin) : 0;
    const max2 = Number(vmax);
    const remainder = (v - min2) % step;
    let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;
    snapped = roundToStepPrecision(snapped, step);
    if (!isNaN$1(min2) && snapped < min2) {
      snapped = min2;
    } else if (!isNaN$1(max2) && snapped > max2) {
      const stepsInRange = floor$1((max2 - min2) / step);
      const largestValidStep = min2 + stepsInRange * step;
      snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;
    }
    return roundToStepPrecision(snapped, step);
  };
  var toFixedNumber = (v, d = 0, b2 = 10) => {
    const pow2 = Math.pow(b2, d);
    return round$1(v * pow2) / pow2;
  };
  var countDecimals = (value) => {
    if (!Number.isFinite(value)) return 0;
    let e = 1, p = 0;
    while (Math.round(value * e) / e !== value) {
      e *= 10;
      p += 1;
    }
    return p;
  };
  var decimalOp = (a, op, b2) => {
    let result = op === "+" ? a + b2 : a - b2;
    if (a % 1 !== 0 || b2 % 1 !== 0) {
      const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b2));
      a = Math.round(a * multiplier);
      b2 = Math.round(b2 * multiplier);
      result = op === "+" ? a + b2 : a - b2;
      result /= multiplier;
    }
    return result;
  };
  var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
  var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
  var toPx$1 = (v) => typeof v === "number" ? `${v}px` : v;
  function compact(obj) {
    if (!isPlainObject(obj) || obj === void 0) return obj;
    const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
    const filtered = {};
    for (const key of keys) {
      const value = obj[key];
      if (value !== void 0) {
        filtered[key] = compact(value);
      }
    }
    return filtered;
  }
  function createStore(initialState, compare = Object.is) {
    let state2 = { ...initialState };
    const listeners = new Set();
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const publish = () => {
      listeners.forEach((listener) => listener());
    };
    const get = (key) => {
      return state2[key];
    };
    const set = (key, value) => {
      if (!compare(state2[key], value)) {
        state2[key] = value;
        publish();
      }
    };
    const update = (updates) => {
      let hasChanges = false;
      for (const key in updates) {
        const value = updates[key];
        if (value !== void 0 && !compare(state2[key], value)) {
          state2[key] = value;
          hasChanges = true;
        }
      }
      if (hasChanges) {
        publish();
      }
    };
    const snapshot = () => ({ ...state2 });
    return {
      subscribe,
      get,
      set,
      update,
      snapshot
    };
  }
  function warn(...a) {
    a.length === 1 ? a[0] : a[1];
    a.length === 2 ? a[0] : true;
  }
  function ensure(c, m) {
    if (c == null) throw new Error(m());
  }
  function ensureProps(props, keys, scope) {
    let missingKeys = [];
    for (const key of keys) {
      if (props[key] == null) missingKeys.push(key);
    }
    if (missingKeys.length > 0)
      throw new Error(`[zag-js${""}] missing required props: ${missingKeys.join(", ")}`);
  }
  function getErrorMessage(hook, provider) {
    return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
  }
  function createContext(options = {}) {
    const {
      name,
      strict = true,
      hookName = "useContext",
      providerName = "Provider",
      errorMessage,
      defaultValue
    } = options;
    const Context = reactExports.createContext(defaultValue);
    Context.displayName = name;
    function useContext$1() {
      const context = reactExports.useContext(Context);
      if (!context && strict) {
        const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
        error.name = "ContextError";
        if (hasProp(Error, "captureStackTrace") && isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(error, useContext$1);
        }
        throw error;
      }
      return context;
    }
    return [Context.Provider, useContext$1, Context];
  }
  const [EnvironmentContextProvider, useEnvironmentContext] = createContext({
    name: "EnvironmentContext",
    hookName: "useEnvironmentContext",
    providerName: "<EnvironmentProvider />",
    strict: false,
    defaultValue: {
      getRootNode: () => document,
      getDocument: () => document,
      getWindow: () => window
    }
  });
  var __defProp$4 = Object.defineProperty;
  var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  function isCaretAtStart(input) {
    if (!input) return false;
    try {
      return input.selectionStart === 0 && input.selectionEnd === 0;
    } catch {
      return input.value === "";
    }
  }
  function setCaretToEnd(input) {
    if (!input) return;
    const start = input.selectionStart ?? 0;
    const end = input.selectionEnd ?? 0;
    if (Math.abs(end - start) !== 0) return;
    if (start !== 0) return;
    input.setSelectionRange(input.value.length, input.value.length);
  }
  var clamp$2 = (value) => Math.max(0, Math.min(1, value));
  var wrap$1 = (v, idx) => {
    return v.map((_2, index) => v[(Math.max(idx, 0) + index) % v.length]);
  };
  var noop$1 = () => void 0;
  var isObject$1 = (v) => typeof v === "object" && v !== null;
  var MAX_Z_INDEX = 2147483647;
  var dataAttr$1 = (guard) => guard ? "" : void 0;
  var ELEMENT_NODE = 1;
  var DOCUMENT_NODE = 9;
  var DOCUMENT_FRAGMENT_NODE = 11;
  var isHTMLElement$2 = (el) => isObject$1(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
  var isDocument = (el) => isObject$1(el) && el.nodeType === DOCUMENT_NODE;
  var isWindow = (el) => isObject$1(el) && el === el.window;
  var getNodeName$1 = (node2) => {
    if (isHTMLElement$2(node2)) return node2.localName || "";
    return "#document";
  };
  function isRootElement(node2) {
    return ["html", "body", "#document"].includes(getNodeName$1(node2));
  }
  var isNode$1 = (el) => isObject$1(el) && el.nodeType !== void 0;
  var isShadowRoot$1 = (el) => isNode$1(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
  var isInputElement = (el) => isHTMLElement$2(el) && el.localName === "input";
  var isAnchorElement = (el) => !!el?.matches("a[href]");
  var isElementVisible = (el) => {
    if (!isHTMLElement$2(el)) return false;
    return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
  };
  function isActiveElement(element) {
    if (!element) return false;
    const rootNode = element.getRootNode();
    return getActiveElement(rootNode) === element;
  }
  var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
  function isEditableElement(el) {
    if (el == null || !isHTMLElement$2(el)) return false;
    try {
      return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
    } catch {
      return false;
    }
  }
  function contains(parent, child) {
    if (!parent || !child) return false;
    if (!isHTMLElement$2(parent) || !isHTMLElement$2(child)) return false;
    const rootNode = child.getRootNode?.();
    if (parent === child) return true;
    if (parent.contains(child)) return true;
    if (rootNode && isShadowRoot$1(rootNode)) {
      let next2 = child;
      while (next2) {
        if (parent === next2) return true;
        next2 = next2.parentNode || next2.host;
      }
    }
    return false;
  }
  function getDocument(el) {
    if (isDocument(el)) return el;
    if (isWindow(el)) return el.document;
    return el?.ownerDocument ?? document;
  }
  function getDocumentElement$1(el) {
    return getDocument(el).documentElement;
  }
  function getWindow$1(el) {
    if (isShadowRoot$1(el)) return getWindow$1(el.host);
    if (isDocument(el)) return el.defaultView ?? window;
    if (isHTMLElement$2(el)) return el.ownerDocument?.defaultView ?? window;
    return window;
  }
  function getActiveElement(rootNode) {
    let activeElement = rootNode.activeElement;
    while (activeElement?.shadowRoot) {
      const el = activeElement.shadowRoot.activeElement;
      if (!el || el === activeElement) break;
      else activeElement = el;
    }
    return activeElement;
  }
  function getParentNode$1(node2) {
    if (getNodeName$1(node2) === "html") return node2;
    const result = node2.assignedSlot || node2.parentNode || isShadowRoot$1(node2) && node2.host || getDocumentElement$1(node2);
    return isShadowRoot$1(result) ? result.host : result;
  }
  function getRootNode(node2) {
    let result;
    try {
      result = node2.getRootNode({ composed: true });
      if (isDocument(result) || isShadowRoot$1(result)) return result;
    } catch {
    }
    return node2.ownerDocument ?? document;
  }
  var styleCache = new WeakMap();
  function getComputedStyle$3(el) {
    if (!styleCache.has(el)) {
      styleCache.set(el, getWindow$1(el).getComputedStyle(el));
    }
    return styleCache.get(el);
  }
  var INTERACTIVE_CONTAINER_ROLE = new Set(["menu", "listbox", "dialog", "grid", "tree", "region"]);
  var isInteractiveContainerRole = (role) => INTERACTIVE_CONTAINER_ROLE.has(role);
  var getAriaControls = (element) => element.getAttribute("aria-controls")?.split(" ") || [];
  function isControlledElement(container, element) {
    const visitedIds = new Set();
    const rootNode = getRootNode(container);
    const checkElement = (searchRoot) => {
      const controllingElements = searchRoot.querySelectorAll("[aria-controls]");
      for (const controller of controllingElements) {
        if (controller.getAttribute("aria-expanded") !== "true") continue;
        const controlledIds = getAriaControls(controller);
        for (const id2 of controlledIds) {
          if (!id2 || visitedIds.has(id2)) continue;
          visitedIds.add(id2);
          const controlledElement = rootNode.getElementById(id2);
          if (controlledElement) {
            const role = controlledElement.getAttribute("role");
            const modal = controlledElement.getAttribute("aria-modal") === "true";
            if (role && isInteractiveContainerRole(role) && !modal) {
              if (controlledElement === element || controlledElement.contains(element)) {
                return true;
              }
              if (checkElement(controlledElement)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    return checkElement(container);
  }
  var isDom = () => typeof document !== "undefined";
  function getPlatform() {
    const agent = navigator.userAgentData;
    return agent?.platform ?? navigator.platform;
  }
  function getUserAgent() {
    const ua2 = navigator.userAgentData;
    if (ua2 && Array.isArray(ua2.brands)) {
      return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
    }
    return navigator.userAgent;
  }
  var pt = (v) => isDom() && v.test(getPlatform());
  var ua = (v) => isDom() && v.test(getUserAgent());
  var vn = (v) => isDom() && v.test(navigator.vendor);
  var isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;
  var isIPhone = () => pt(/^iPhone/i);
  var isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;
  var isIos = () => isIPhone() || isIPad();
  var isApple = () => isMac() || isIos();
  var isMac = () => pt(/^Mac/i);
  var isSafari = () => isApple() && vn(/apple/i);
  var isFirefox = () => ua(/Firefox/i);
  var isAndroid = () => ua(/Android/i);
  function getComposedPath(event) {
    return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
  }
  function getEventTarget(event) {
    const composedPath = getComposedPath(event);
    return composedPath?.[0] ?? event.target;
  }
  function isOpeningInNewTab(event) {
    const element = event.currentTarget;
    if (!element) return false;
    const validElement = element.matches("a[href], button[type='submit'], input[type='submit']");
    if (!validElement) return false;
    const isMiddleClick = event.button === 1;
    const isModKeyClick = isCtrlOrMetaKey(event);
    return isMiddleClick || isModKeyClick;
  }
  function isComposingEvent(event) {
    return getNativeEvent(event).isComposing || event.keyCode === 229;
  }
  function isCtrlOrMetaKey(e) {
    if (isMac()) return e.metaKey;
    return e.ctrlKey;
  }
  function isVirtualClick(e) {
    if (e.pointerType === "" && e.isTrusted) return true;
    if (isAndroid() && e.pointerType) {
      return e.type === "click" && e.buttons === 1;
    }
    return e.detail === 0 && !e.pointerType;
  }
  var isContextMenuEvent = (e) => {
    return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
  };
  var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
  var keyMap = {
    Up: "ArrowUp",
    Down: "ArrowDown",
    Esc: "Escape",
    " ": "Space",
    ",": "Comma",
    Left: "ArrowLeft",
    Right: "ArrowRight"
  };
  var rtlKeyMap = {
    ArrowLeft: "ArrowRight",
    ArrowRight: "ArrowLeft"
  };
  function getEventKey(event, options = {}) {
    const { dir = "ltr", orientation = "horizontal" } = options;
    let key = event.key;
    key = keyMap[key] ?? key;
    const isRtl = dir === "rtl" && orientation === "horizontal";
    if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
    return key;
  }
  function getNativeEvent(event) {
    return event.nativeEvent ?? event;
  }
  function getEventPoint(event, type = "client") {
    const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
    return { x: point[`${type}X`], y: point[`${type}Y`] };
  }
  var addDomEvent$1 = (target, eventName, handler, options) => {
    const node2 = typeof target === "function" ? target() : target;
    node2?.addEventListener(eventName, handler, options);
    return () => {
      node2?.removeEventListener(eventName, handler, options);
    };
  };
  function getDescriptor(el, options) {
    const { type = "HTMLInputElement", property = "value" } = options;
    const proto = getWindow$1(el)[type].prototype;
    return Object.getOwnPropertyDescriptor(proto, property) ?? {};
  }
  function getElementType(el) {
    if (el.localName === "input") return "HTMLInputElement";
    if (el.localName === "textarea") return "HTMLTextAreaElement";
    if (el.localName === "select") return "HTMLSelectElement";
  }
  function setElementValue(el, value, property = "value") {
    if (!el) return;
    const type = getElementType(el);
    if (type) {
      const descriptor = getDescriptor(el, { type, property });
      descriptor.set?.call(el, value);
    }
    el.setAttribute(property, value);
  }
  function dispatchInputValueEvent(el, options) {
    const { value, bubbles = true } = options;
    if (!el) return;
    const win = getWindow$1(el);
    if (!(el instanceof win.HTMLInputElement)) return;
    setElementValue(el, `${value}`);
    el.dispatchEvent(new win.Event("input", { bubbles }));
  }
  function getClosestForm(el) {
    return isFormElement(el) ? el.form : el.closest("form");
  }
  function isFormElement(el) {
    return el.matches("textarea, input, select, button");
  }
  function trackFormReset(el, callback) {
    if (!el) return;
    const form = getClosestForm(el);
    const onReset = (e) => {
      if (e.defaultPrevented) return;
      callback();
    };
    form?.addEventListener("reset", onReset, { passive: true });
    return () => form?.removeEventListener("reset", onReset);
  }
  function trackFieldsetDisabled(el, callback) {
    const fieldset = el?.closest("fieldset");
    if (!fieldset) return;
    callback(fieldset.disabled);
    const win = getWindow$1(fieldset);
    const obs = new win.MutationObserver(() => callback(fieldset.disabled));
    obs.observe(fieldset, {
      attributes: true,
      attributeFilter: ["disabled"]
    });
    return () => obs.disconnect();
  }
  function trackFormControl(el, options) {
    if (!el) return;
    const { onFieldsetDisabledChange, onFormReset } = options;
    const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
    return () => cleanups.forEach((cleanup) => cleanup?.());
  }
  var isFrame = (el) => isHTMLElement$2(el) && el.tagName === "IFRAME";
  function parseTabIndex(el) {
    const attr = el.getAttribute("tabindex");
    if (!attr) return NaN;
    return parseInt(attr, 10);
  }
  var hasNegativeTabIndex = (el) => parseTabIndex(el) < 0;
  function getShadowRootForNode(element, getShadowRoot) {
    if (!getShadowRoot) return null;
    if (getShadowRoot === true) {
      return element.shadowRoot || null;
    }
    const result = getShadowRoot(element);
    return (result === true ? element.shadowRoot : result) || null;
  }
  function collectElementsWithShadowDOM(elements, getShadowRoot, filterFn) {
    const allElements = [...elements];
    const toProcess = [...elements];
    const processed = new Set();
    const positionMap = new Map();
    elements.forEach((el, i) => positionMap.set(el, i));
    let processIndex = 0;
    while (processIndex < toProcess.length) {
      const element = toProcess[processIndex++];
      if (!element || processed.has(element)) continue;
      processed.add(element);
      const shadowRoot = getShadowRootForNode(element, getShadowRoot);
      if (shadowRoot) {
        const shadowElements = Array.from(shadowRoot.querySelectorAll(focusableSelector)).filter(filterFn);
        const hostIndex = positionMap.get(element);
        if (hostIndex !== void 0) {
          const insertPosition = hostIndex + 1;
          allElements.splice(insertPosition, 0, ...shadowElements);
          shadowElements.forEach((el, i) => {
            positionMap.set(el, insertPosition + i);
          });
          for (let i = insertPosition + shadowElements.length; i < allElements.length; i++) {
            positionMap.set(allElements[i], i);
          }
        } else {
          const insertPosition = allElements.length;
          allElements.push(...shadowElements);
          shadowElements.forEach((el, i) => {
            positionMap.set(el, insertPosition + i);
          });
        }
        toProcess.push(...shadowElements);
      }
    }
    return allElements;
  }
  var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
  var getFocusables = (container, options = {}) => {
    if (!container) return [];
    const { includeContainer = false, getShadowRoot } = options;
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
    if (include && isHTMLElement$2(container) && isFocusable(container)) {
      elements.unshift(container);
    }
    const focusableElements2 = [];
    for (const element of elements) {
      if (!isFocusable(element)) continue;
      if (isFrame(element) && element.contentDocument) {
        const frameBody = element.contentDocument.body;
        focusableElements2.push(...getFocusables(frameBody, { getShadowRoot }));
        continue;
      }
      focusableElements2.push(element);
    }
    if (getShadowRoot) {
      return collectElementsWithShadowDOM(focusableElements2, getShadowRoot, isFocusable);
    }
    return focusableElements2;
  };
  function isFocusable(element) {
    if (!isHTMLElement$2(element) || element.closest("[inert]")) return false;
    return element.matches(focusableSelector) && isElementVisible(element);
  }
  function getTabbables(container, options = {}) {
    if (!container) return [];
    const { includeContainer, getShadowRoot } = options;
    const elements = Array.from(container.querySelectorAll(focusableSelector));
    if (includeContainer && isTabbable(container)) {
      elements.unshift(container);
    }
    const tabbableElements = [];
    for (const element of elements) {
      if (!isTabbable(element)) continue;
      if (isFrame(element) && element.contentDocument) {
        const frameBody = element.contentDocument.body;
        tabbableElements.push(...getTabbables(frameBody, { getShadowRoot }));
        continue;
      }
      tabbableElements.push(element);
    }
    if (getShadowRoot) {
      const allElements = collectElementsWithShadowDOM(tabbableElements, getShadowRoot, isTabbable);
      if (!allElements.length && includeContainer) {
        return elements;
      }
      return allElements;
    }
    if (!tabbableElements.length && includeContainer) {
      return elements;
    }
    return tabbableElements;
  }
  function isTabbable(el) {
    if (isHTMLElement$2(el) && el.tabIndex > 0) return true;
    return isFocusable(el) && !hasNegativeTabIndex(el);
  }
  function getInitialFocus(options) {
    const { root: root2, getInitialEl, filter: filter2, enabled = true } = options;
    if (!enabled) return;
    let node2 = null;
    node2 || (node2 = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
    node2 || (node2 = root2?.querySelector("[data-autofocus],[autofocus]"));
    if (!node2) {
      const tabbables = getTabbables(root2);
      node2 = filter2 ? tabbables.filter(filter2)[0] : tabbables[0];
    }
    return node2 || root2 || void 0;
  }
  var AnimationFrame = class _AnimationFrame {
    constructor() {
      __publicField$4(this, "id", null);
      __publicField$4(this, "fn_cleanup");
      __publicField$4(this, "cleanup", () => {
        this.cancel();
      });
    }
    static create() {
      return new _AnimationFrame();
    }
    request(fn) {
      this.cancel();
      this.id = globalThis.requestAnimationFrame(() => {
        this.id = null;
        this.fn_cleanup = fn?.();
      });
    }
    cancel() {
      if (this.id !== null) {
        globalThis.cancelAnimationFrame(this.id);
        this.id = null;
      }
      this.fn_cleanup?.();
      this.fn_cleanup = void 0;
    }
    isActive() {
      return this.id !== null;
    }
  };
  function raf(fn) {
    const frame2 = AnimationFrame.create();
    frame2.request(fn);
    return frame2.cleanup;
  }
  function nextTick(fn) {
    const set = new Set();
    function raf2(fn2) {
      const id2 = globalThis.requestAnimationFrame(fn2);
      set.add(() => globalThis.cancelAnimationFrame(id2));
    }
    raf2(() => raf2(fn));
    return function cleanup() {
      set.forEach((fn2) => fn2());
    };
  }
  function queueBeforeEvent(el, type, cb) {
    const cancelTimer = raf(() => {
      el.removeEventListener(type, exec, true);
      cb();
    });
    const exec = () => {
      cancelTimer();
      cb();
    };
    el.addEventListener(type, exec, { once: true, capture: true });
    return cancelTimer;
  }
  function observeAttributesImpl(node2, options) {
    if (!node2) return;
    const { attributes, callback: fn } = options;
    const win = node2.ownerDocument.defaultView || window;
    const obs = new win.MutationObserver((changes) => {
      for (const change of changes) {
        if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
          fn(change);
        }
      }
    });
    obs.observe(node2, { attributes: true, attributeFilter: attributes });
    return () => obs.disconnect();
  }
  function observeAttributes(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v) => v();
    const cleanups = [];
    cleanups.push(
      func(() => {
        const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(observeAttributesImpl(node2, options));
      })
    );
    return () => {
      cleanups.forEach((fn) => fn?.());
    };
  }
  function clickIfLink(el) {
    const click = () => {
      const win = getWindow$1(el);
      el.dispatchEvent(new win.MouseEvent("click"));
    };
    if (isFirefox()) {
      queueBeforeEvent(el, "keyup", click);
    } else {
      queueMicrotask(click);
    }
  }
  function getNearestOverflowAncestor$1(el) {
    const parentNode = getParentNode$1(el);
    if (isRootElement(parentNode)) return getDocument(parentNode).body;
    if (isHTMLElement$2(parentNode) && isOverflowElement$1(parentNode)) return parentNode;
    return getNearestOverflowAncestor$1(parentNode);
  }
  function getOverflowAncestors$1(el, list = []) {
    const scrollableAncestor = getNearestOverflowAncestor$1(el);
    const isBody = scrollableAncestor === el.ownerDocument.body;
    const win = getWindow$1(scrollableAncestor);
    if (isBody) {
      return list.concat(win, win.visualViewport || [], isOverflowElement$1(scrollableAncestor) ? scrollableAncestor : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors$1(scrollableAncestor, []));
  }
  var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
  var nonOverflowValues = new Set(["inline", "contents"]);
  function isOverflowElement$1(el) {
    const win = getWindow$1(el);
    const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
    return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !nonOverflowValues.has(display);
  }
  function isScrollable(el) {
    return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
  }
  function scrollIntoView(el, options) {
    const { rootEl, ...scrollOptions } = options || {};
    if (!el || !rootEl) return;
    if (!isOverflowElement$1(rootEl) || !isScrollable(rootEl)) return;
    el.scrollIntoView(scrollOptions);
  }
  function getRelativePoint(point, element) {
    const { left, top, width, height } = element.getBoundingClientRect();
    const offset2 = { x: point.x - left, y: point.y - top };
    const percent2 = { x: clamp$2(offset2.x / width), y: clamp$2(offset2.y / height) };
    function getPercentValue2(options = {}) {
      const { dir = "ltr", orientation = "horizontal", inverted } = options;
      const invertX = typeof inverted === "object" ? inverted.x : inverted;
      const invertY = typeof inverted === "object" ? inverted.y : inverted;
      if (orientation === "horizontal") {
        return dir === "rtl" || invertX ? 1 - percent2.x : percent2.x;
      }
      return invertY ? 1 - percent2.y : percent2.y;
    }
    return { offset: offset2, percent: percent2, getPercentValue: getPercentValue2 };
  }
  function requestPointerLock(doc, fn) {
    const body = doc.body;
    const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
    const isLocked = () => !!doc.pointerLockElement;
    function onPointerChange() {
    }
    function onPointerError(event) {
      if (isLocked()) ;
      console.error("PointerLock error occurred:", event);
      doc.exitPointerLock();
    }
    if (!supported) return;
    try {
      body.requestPointerLock();
    } catch {
    }
    const cleanup = [
      addDomEvent$1(doc, "pointerlockchange", onPointerChange, false),
      addDomEvent$1(doc, "pointerlockerror", onPointerError, false)
    ];
    return () => {
      cleanup.forEach((cleanup2) => cleanup2());
      doc.exitPointerLock();
    };
  }
  var state = "default";
  var userSelect = "";
  var elementMap = new WeakMap();
  function disableTextSelectionImpl(options = {}) {
    const { target, doc } = options;
    const docNode = doc ?? document;
    const rootEl = docNode.documentElement;
    if (isIos()) {
      if (state === "default") {
        userSelect = rootEl.style.webkitUserSelect;
        rootEl.style.webkitUserSelect = "none";
      }
      state = "disabled";
    } else if (target) {
      elementMap.set(target, target.style.userSelect);
      target.style.userSelect = "none";
    }
    return () => restoreTextSelection({ target, doc: docNode });
  }
  function restoreTextSelection(options = {}) {
    const { target, doc } = options;
    const docNode = doc ?? document;
    const rootEl = docNode.documentElement;
    if (isIos()) {
      if (state !== "disabled") return;
      state = "restoring";
      setTimeout(() => {
        nextTick(() => {
          if (state === "restoring") {
            if (rootEl.style.webkitUserSelect === "none") {
              rootEl.style.webkitUserSelect = userSelect || "";
            }
            userSelect = "";
            state = "default";
          }
        });
      }, 300);
    } else {
      if (target && elementMap.has(target)) {
        const prevUserSelect = elementMap.get(target);
        if (target.style.userSelect === "none") {
          target.style.userSelect = prevUserSelect ?? "";
        }
        if (target.getAttribute("style") === "") {
          target.removeAttribute("style");
        }
        elementMap.delete(target);
      }
    }
  }
  function disableTextSelection(options = {}) {
    const { defer, target, ...restOptions } = options;
    const func = defer ? raf : (v) => v();
    const cleanups = [];
    cleanups.push(
      func(() => {
        const node2 = typeof target === "function" ? target() : target;
        cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node2 }));
      })
    );
    return () => {
      cleanups.forEach((fn) => fn?.());
    };
  }
  function trackPointerMove(doc, handlers) {
    const { onPointerMove, onPointerUp } = handlers;
    const handleMove = (event) => {
      const point = getEventPoint(event);
      const distance2 = Math.sqrt(point.x ** 2 + point.y ** 2);
      const moveBuffer = event.pointerType === "touch" ? 10 : 5;
      if (distance2 < moveBuffer) return;
      if (event.pointerType === "mouse" && event.buttons === 0) {
        handleUp(event);
        return;
      }
      onPointerMove({ point, event });
    };
    const handleUp = (event) => {
      const point = getEventPoint(event);
      onPointerUp({ point, event });
    };
    const cleanups = [
      addDomEvent$1(doc, "pointermove", handleMove, false),
      addDomEvent$1(doc, "pointerup", handleUp, false),
      addDomEvent$1(doc, "pointercancel", handleUp, false),
      addDomEvent$1(doc, "contextmenu", handleUp, false),
      disableTextSelection({ doc })
    ];
    return () => {
      cleanups.forEach((cleanup) => cleanup());
    };
  }
  function queryAll(root2, selector) {
    return Array.from(root2?.querySelectorAll(selector) ?? []);
  }
  function query(root2, selector) {
    return root2?.querySelector(selector) ?? null;
  }
  var defaultItemToId = (v) => v.id;
  function itemById(v, id2, itemToId = defaultItemToId) {
    return v.find((item) => itemToId(item) === id2);
  }
  function indexOfId(v, id2, itemToId = defaultItemToId) {
    const item = itemById(v, id2, itemToId);
    return item ? v.indexOf(item) : -1;
  }
  function nextById(v, id2, loop = true) {
    let idx = indexOfId(v, id2);
    idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
    return v[idx];
  }
  function prevById(v, id2, loop = true) {
    let idx = indexOfId(v, id2);
    if (idx === -1) return loop ? v[v.length - 1] : null;
    idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
    return v[idx];
  }
  function createSharedResizeObserver(options) {
    const listeners = new WeakMap();
    let observer;
    const entries = new WeakMap();
    const getObserver = (win) => {
      if (observer) return observer;
      observer = new win.ResizeObserver((observedEntries) => {
        for (const entry of observedEntries) {
          entries.set(entry.target, entry);
          const elementListeners = listeners.get(entry.target);
          if (elementListeners) {
            for (const listener of elementListeners) {
              listener(entry);
            }
          }
        }
      });
      return observer;
    };
    const observe = (element, listener) => {
      let elementListeners = listeners.get(element) || new Set();
      elementListeners.add(listener);
      listeners.set(element, elementListeners);
      const win = getWindow$1(element);
      getObserver(win).observe(element, options);
      return () => {
        const elementListeners2 = listeners.get(element);
        if (!elementListeners2) return;
        elementListeners2.delete(listener);
        if (elementListeners2.size === 0) {
          listeners.delete(element);
          getObserver(win).unobserve(element);
        }
      };
    };
    const unobserve = (element) => {
      listeners.delete(element);
      observer?.unobserve(element);
    };
    return {
      observe,
      unobserve
    };
  }
  var resizeObserverBorderBox = createSharedResizeObserver({
    box: "border-box"
  });
  var sanitize$1 = (str) => str.split("").map((char2) => {
    const code = char2.charCodeAt(0);
    if (code > 0 && code < 128) return char2;
    if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
    return "";
  }).join("").trim();
  var getValueText = (el) => {
    return sanitize$1(el.dataset?.valuetext ?? el.textContent ?? "");
  };
  var match$1 = (valueText, query2) => {
    return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
  };
  function getByText(v, text, currentId, itemToId = defaultItemToId) {
    const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
    let items = currentId ? wrap$1(v, index) : v;
    const isSingleKey = text.length === 1;
    if (isSingleKey) {
      items = items.filter((item) => itemToId(item) !== currentId);
    }
    return items.find((item) => match$1(getValueText(item), text));
  }
  function setStyle$1(el, style) {
    if (!el) return noop$1;
    const prev2 = Object.keys(style).reduce((acc, key) => {
      acc[key] = el.style.getPropertyValue(key);
      return acc;
    }, {});
    Object.assign(el.style, style);
    return () => {
      Object.assign(el.style, prev2);
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    };
  }
  function getByTypeaheadImpl(baseItems, options) {
    const { state: state2, activeId, key, timeout = 350, itemToId } = options;
    const search = state2.keysSoFar + key;
    const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
    const query2 = isRepeated ? search[0] : search;
    let items = baseItems.slice();
    const next2 = getByText(items, query2, activeId, itemToId);
    function cleanup() {
      clearTimeout(state2.timer);
      state2.timer = -1;
    }
    function update(value) {
      state2.keysSoFar = value;
      cleanup();
      if (value !== "") {
        state2.timer = +setTimeout(() => {
          update("");
          cleanup();
        }, timeout);
      }
    }
    update(search);
    return next2;
  }
  var getByTypeahead = Object.assign(getByTypeaheadImpl, {
    defaultOptions: { keysSoFar: "", timer: -1 },
    isValidEvent: isValidTypeaheadEvent
  });
  function isValidTypeaheadEvent(event) {
    return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
  }
  function waitForPromise(promise, controller, timeout) {
    const { signal } = controller;
    const wrappedPromise = new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error(`Timeout of ${timeout}ms exceeded`));
      }, timeout);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new Error("Promise aborted"));
      });
      promise.then((result) => {
        if (!signal.aborted) {
          clearTimeout(timeoutId);
          resolve(result);
        }
      }).catch((error) => {
        if (!signal.aborted) {
          clearTimeout(timeoutId);
          reject(error);
        }
      });
    });
    const abort = () => controller.abort();
    return [wrappedPromise, abort];
  }
  function waitForElement(target, options) {
    const { timeout, rootNode } = options;
    const win = getWindow$1(rootNode);
    const doc = getDocument(rootNode);
    const controller = new win.AbortController();
    return waitForPromise(
      new Promise((resolve) => {
        const el = target();
        if (el) {
          resolve(el);
          return;
        }
        const observer = new win.MutationObserver(() => {
          const el2 = target();
          if (el2 && el2.isConnected) {
            observer.disconnect();
            resolve(el2);
          }
        });
        observer.observe(doc.body, {
          childList: true,
          subtree: true
        });
      }),
      controller,
      timeout
    );
  }
  var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
  var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
  var serialize = (style) => {
    const res = {};
    let match2;
    while (match2 = CSS_REGEX.exec(style)) {
      res[match2[1]] = match2[2];
    }
    return res;
  };
  var css = (a, b2) => {
    if (isString(a)) {
      if (isString(b2)) return `${a};${b2}`;
      a = serialize(a);
    } else if (isString(b2)) {
      b2 = serialize(b2);
    }
    return Object.assign({}, a ?? {}, b2 ?? {});
  };
  function mergeProps(...args) {
    let result = {};
    for (let props of args) {
      if (!props) continue;
      for (let key in result) {
        if (key.startsWith("on") && typeof result[key] === "function" && typeof props[key] === "function") {
          result[key] = callAll(props[key], result[key]);
          continue;
        }
        if (key === "className" || key === "class") {
          result[key] = clsx(result[key], props[key]);
          continue;
        }
        if (key === "style") {
          result[key] = css(result[key], props[key]);
          continue;
        }
        result[key] = props[key] !== void 0 ? props[key] : result[key];
      }
      for (let key in props) {
        if (result[key] === void 0) {
          result[key] = props[key];
        }
      }
      const symbols = Object.getOwnPropertySymbols(props);
      for (let symbol of symbols) {
        result[symbol] = props[symbol];
      }
    }
    return result;
  }
  function memo$3(getDeps, fn, opts) {
    let deps = [];
    let result;
    return (depArgs) => {
      const newDeps = getDeps(depArgs);
      const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
      if (!depsChanged) return result;
      deps = newDeps;
      result = fn(newDeps, depArgs);
      return result;
    };
  }
  function createGuards() {
    return {
      and: (...guards2) => {
        return function andGuard(params) {
          return guards2.every((str) => params.guard(str));
        };
      },
      or: (...guards2) => {
        return function orGuard(params) {
          return guards2.some((str) => params.guard(str));
        };
      },
      not: (guard) => {
        return function notGuard(params) {
          return !params.guard(guard);
        };
      }
    };
  }
  function createMachine$4(config) {
    return config;
  }
  function setup() {
    return {
      guards: createGuards(),
      createMachine: (config) => {
        return createMachine$4(config);
      },
      choose: (transitions) => {
        return function chooseFn({ choose: choose2 }) {
          return choose2(transitions)?.actions;
        };
      }
    };
  }
  var MachineStatus = ((MachineStatus2) => {
    MachineStatus2["NotStarted"] = "Not Started";
    MachineStatus2["Started"] = "Started";
    MachineStatus2["Stopped"] = "Stopped";
    return MachineStatus2;
  })(MachineStatus || {});
  var INIT_STATE = "__init__";
  function createScope(props) {
    const getRootNode2 = () => props.getRootNode?.() ?? document;
    const getDoc = () => getDocument(getRootNode2());
    const getWin = () => getDoc().defaultView ?? window;
    const getActiveElementFn = () => getActiveElement(getRootNode2());
    const getById = (id2) => getRootNode2().getElementById(id2);
    return {
      ...props,
      getRootNode: getRootNode2,
      getDoc,
      getWin,
      getActiveElement: getActiveElementFn,
      isActiveElement,
      getById
    };
  }
  function composeRefs$1(...refs) {
    return (node2) => {
      const cleanUps = [];
      for (const ref of refs) {
        if (typeof ref === "function") {
          const cb = ref(node2);
          if (typeof cb === "function") {
            cleanUps.push(cb);
          }
        } else if (ref) {
          ref.current = node2;
        }
      }
      if (cleanUps.length) {
        return () => {
          for (const cleanUp of cleanUps) {
            cleanUp();
          }
        };
      }
    };
  }
  function getRef(element) {
    let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
    let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.ref;
    }
    getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
    mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
    if (mayWarn) {
      return element.props.ref;
    }
    return element.props.ref || element.ref;
  }
  const withAsChild = (Component) => {
    const Comp = reactExports.memo(
      reactExports.forwardRef((props, ref) => {
        const { asChild, children, ...restProps } = props;
        if (!asChild) {
          return reactExports.createElement(Component, { ...restProps, ref }, children);
        }
        if (!reactExports.isValidElement(children)) {
          return null;
        }
        const onlyChild = reactExports.Children.only(children);
        const childRef = getRef(onlyChild);
        return reactExports.cloneElement(onlyChild, {
          ...mergeProps(restProps, onlyChild.props),
          ref: ref ? composeRefs$1(ref, childRef) : childRef
        });
      })
    );
    Comp.displayName = Component.displayName || Component.name;
    return Comp;
  };
  const jsxFactory = () => {
    const cache2 = new Map();
    return new Proxy(withAsChild, {
      apply(_target, _thisArg, argArray) {
        return withAsChild(argArray[0]);
      },
      get(_2, element) {
        const asElement = element;
        if (!cache2.has(asElement)) {
          cache2.set(asElement, withAsChild(asElement));
        }
        return cache2.get(asElement);
      }
    });
  };
  const ark = jsxFactory();
  const [LocaleContextProvider, useLocaleContext] = createContext({
    name: "LocaleContext",
    hookName: "useLocaleContext",
    providerName: "<LocaleProvider />",
    strict: false,
    defaultValue: { dir: "ltr", locale: "en-US" }
  });
  const { withContext: withContext$7 } = createRecipeContext({
    key: "heading"
  });
  const Heading = withContext$7("h2");
  Heading.displayName = "Heading";
  const { withContext: withContext$6 } = createRecipeContext({
    key: "mark"
  });
  const Mark = withContext$6("mark");
  Mark.displayName = "Mark";
  const createSplitProps = () => (props, keys) => keys.reduce(
    (previousValue, currentValue) => {
      const [target, source] = previousValue;
      const key = currentValue;
      if (source[key] !== void 0) {
        target[key] = source[key];
      }
      delete source[key];
      return [target, source];
    },
    [{}, { ...props }]
  );
  function createNormalizer(fn) {
    return new Proxy({}, {
      get(_target, key) {
        if (key === "style")
          return (props) => {
            return fn({ style: props }).style;
          };
        return fn;
      }
    });
  }
  var createProps$1 = () => (props) => Array.from(new Set(props));
  function connect$2(service, _normalize) {
    const { state: state2, send, context } = service;
    const present = state2.matches("mounted", "unmountSuspended");
    return {
      skip: !context.get("initial"),
      present,
      setNode(node2) {
        if (!node2) return;
        send({ type: "NODE.SET", node: node2 });
      },
      unmount() {
        send({ type: "UNMOUNT" });
      }
    };
  }
  var machine$2 = createMachine$4({
    props({ props: props2 }) {
      return { ...props2, present: !!props2.present };
    },
    initialState({ prop }) {
      return prop("present") ? "mounted" : "unmounted";
    },
    refs() {
      return {
        node: null,
        styles: null
      };
    },
    context({ bindable }) {
      return {
        unmountAnimationName: bindable(() => ({ defaultValue: null })),
        prevAnimationName: bindable(() => ({ defaultValue: null })),
        present: bindable(() => ({ defaultValue: false })),
        initial: bindable(() => ({
          sync: true,
          defaultValue: false
        }))
      };
    },
    exit: ["clearInitial", "cleanupNode"],
    watch({ track, prop, send }) {
      track([() => prop("present")], () => {
        send({ type: "PRESENCE.CHANGED" });
      });
    },
    on: {
      "NODE.SET": {
        actions: ["setupNode"]
      },
      "PRESENCE.CHANGED": {
        actions: ["setInitial", "syncPresence"]
      }
    },
    states: {
      mounted: {
        on: {
          UNMOUNT: {
            target: "unmounted",
            actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
          },
          "UNMOUNT.SUSPEND": {
            target: "unmountSuspended"
          }
        }
      },
      unmountSuspended: {
        effects: ["trackAnimationEvents"],
        on: {
          MOUNT: {
            target: "mounted",
            actions: ["setPrevAnimationName"]
          },
          UNMOUNT: {
            target: "unmounted",
            actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
          }
        }
      },
      unmounted: {
        on: {
          MOUNT: {
            target: "mounted",
            actions: ["setPrevAnimationName"]
          }
        }
      }
    },
    implementations: {
      actions: {
        setInitial: ({ context }) => {
          if (context.get("initial")) return;
          queueMicrotask(() => {
            context.set("initial", true);
          });
        },
        clearInitial: ({ context }) => {
          context.set("initial", false);
        },
        invokeOnExitComplete: ({ prop, refs }) => {
          prop("onExitComplete")?.();
          const node2 = refs.get("node");
          if (!node2) return;
          const win = getWindow$1(node2);
          const event = new win.CustomEvent("exitcomplete", { bubbles: false });
          node2.dispatchEvent(event);
        },
        setupNode: ({ refs, event }) => {
          if (refs.get("node") === event.node) return;
          refs.set("node", event.node);
          refs.set("styles", getComputedStyle$3(event.node));
        },
        cleanupNode: ({ refs }) => {
          refs.set("node", null);
          refs.set("styles", null);
        },
        syncPresence: ({ context, refs, send, prop }) => {
          const presentProp = prop("present");
          if (presentProp) {
            return send({ type: "MOUNT", src: "presence.changed" });
          }
          const node2 = refs.get("node");
          if (!presentProp && node2?.ownerDocument.visibilityState === "hidden") {
            return send({ type: "UNMOUNT", src: "visibilitychange" });
          }
          raf(() => {
            const animationName = getAnimationName(refs.get("styles"));
            context.set("unmountAnimationName", animationName);
            if (animationName === "none" || animationName === context.get("prevAnimationName") || refs.get("styles")?.display === "none" || refs.get("styles")?.animationDuration === "0s") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName: ({ context, refs }) => {
          raf(() => {
            context.set("prevAnimationName", getAnimationName(refs.get("styles")));
          });
        },
        clearPrevAnimationName: ({ context }) => {
          context.set("prevAnimationName", null);
        }
      },
      effects: {
        trackAnimationEvents: ({ context, refs, send, prop }) => {
          const node2 = refs.get("node");
          if (!node2) return;
          const onStart = (event) => {
            const target = event.composedPath?.()?.[0] ?? event.target;
            if (target === node2) {
              context.set("prevAnimationName", getAnimationName(refs.get("styles")));
            }
          };
          const onEnd = (event) => {
            const animationName = getAnimationName(refs.get("styles"));
            const target = getEventTarget(event);
            if (target === node2 && animationName === context.get("unmountAnimationName") && !prop("present")) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          const onCancel = (event) => {
            const target = getEventTarget(event);
            if (target === node2 && !prop("present")) {
              send({ type: "UNMOUNT", src: "animationcancel" });
            }
          };
          node2.addEventListener("animationstart", onStart);
          node2.addEventListener("animationcancel", onCancel);
          node2.addEventListener("animationend", onEnd);
          const cleanupStyles = setStyle$1(node2, { animationFillMode: "forwards" });
          return () => {
            node2.removeEventListener("animationstart", onStart);
            node2.removeEventListener("animationcancel", onCancel);
            node2.removeEventListener("animationend", onEnd);
            nextTick(() => cleanupStyles());
          };
        }
      }
    }
  });
  function getAnimationName(styles) {
    return styles?.animationName || "none";
  }
  createProps$1()(["onExitComplete", "present", "immediate"]);
  var reactDomExports = requireReactDom();
  var useSafeLayoutEffect = typeof globalThis.document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
  function useBindable(props) {
    const initial = props().value ?? props().defaultValue;
    const eq = props().isEqual ?? Object.is;
    const [initialValue] = reactExports.useState(initial);
    const [value, setValue] = reactExports.useState(initialValue);
    const controlled = props().value !== void 0;
    const valueRef = reactExports.useRef(value);
    valueRef.current = controlled ? props().value : value;
    const prevValue = reactExports.useRef(valueRef.current);
    useSafeLayoutEffect(() => {
      prevValue.current = valueRef.current;
    }, [value, props().value]);
    const setFn = (value2) => {
      const prev2 = prevValue.current;
      const next2 = isFunction(value2) ? value2(prev2) : value2;
      if (props().debug) {
        console.log(`[bindable > ${props().debug}] setValue`, { next: next2, prev: prev2 });
      }
      if (!controlled) setValue(next2);
      if (!eq(next2, prev2)) {
        props().onChange?.(next2, prev2);
      }
    };
    function get() {
      return controlled ? props().value : value;
    }
    return {
      initial: initialValue,
      ref: valueRef,
      get,
      set(value2) {
        const exec = props().sync ? reactDomExports.flushSync : identity;
        exec(() => setFn(value2));
      },
      invoke(nextValue, prevValue2) {
        props().onChange?.(nextValue, prevValue2);
      },
      hash(value2) {
        return props().hash?.(value2) ?? String(value2);
      }
    };
  }
  useBindable.cleanup = (fn) => {
    reactExports.useEffect(() => fn, []);
  };
  useBindable.ref = (defaultValue) => {
    const value = reactExports.useRef(defaultValue);
    return {
      get: () => value.current,
      set: (next2) => {
        value.current = next2;
      }
    };
  };
  function useRefs(refs) {
    const ref = reactExports.useRef(refs);
    return {
      get(key) {
        return ref.current[key];
      },
      set(key, value) {
        ref.current[key] = value;
      }
    };
  }
  var useTrack = (deps, effect) => {
    const render = reactExports.useRef(false);
    const called = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const mounted = render.current;
      const run = mounted && called.current;
      if (run) return effect();
      called.current = true;
    }, [...(deps ?? []).map((d) => typeof d === "function" ? d() : d)]);
    reactExports.useEffect(() => {
      render.current = true;
      return () => {
        render.current = false;
      };
    }, []);
  };
  function useMachine(machine2, userProps = {}) {
    const scope = reactExports.useMemo(() => {
      const { id: id2, ids, getRootNode: getRootNode2 } = userProps;
      return createScope({ id: id2, ids, getRootNode: getRootNode2 });
    }, [userProps]);
    const debug = (...args) => {
      if (machine2.debug) console.log(...args);
    };
    const props = machine2.props?.({ props: compact(userProps), scope }) ?? userProps;
    const prop = useProp(props);
    const context = machine2.context?.({
      prop,
      bindable: useBindable,
      scope,
      flush,
      getContext() {
        return ctx;
      },
      getComputed() {
        return computed;
      },
      getRefs() {
        return refs;
      },
      getEvent() {
        return getEvent();
      }
    });
    const contextRef = useLiveRef(context);
    const ctx = {
      get(key) {
        return contextRef.current?.[key].ref.current;
      },
      set(key, value) {
        contextRef.current?.[key].set(value);
      },
      initial(key) {
        return contextRef.current?.[key].initial;
      },
      hash(key) {
        const current = contextRef.current?.[key].get();
        return contextRef.current?.[key].hash(current);
      }
    };
    const effects = reactExports.useRef( new Map());
    const transitionRef = reactExports.useRef(null);
    const previousEventRef = reactExports.useRef(null);
    const eventRef = reactExports.useRef({ type: "" });
    const getEvent = () => ({
      ...eventRef.current,
      current() {
        return eventRef.current;
      },
      previous() {
        return previousEventRef.current;
      }
    });
    const getState = () => ({
      ...state2,
      matches(...values) {
        return values.includes(state2.ref.current);
      },
      hasTag(tag) {
        return !!machine2.states[state2.ref.current]?.tags?.includes(tag);
      }
    });
    const refs = useRefs(machine2.refs?.({ prop, context: ctx }) ?? {});
    const getParams = () => ({
      state: getState(),
      context: ctx,
      event: getEvent(),
      prop,
      send,
      action,
      guard,
      track: useTrack,
      refs,
      computed,
      flush,
      scope,
      choose: choose2
    });
    const action = (keys) => {
      const strs = isFunction(keys) ? keys(getParams()) : keys;
      if (!strs) return;
      const fns = strs.map((s) => {
        const fn = machine2.implementations?.actions?.[s];
        if (!fn) warn(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
        return fn;
      });
      for (const fn of fns) {
        fn?.(getParams());
      }
    };
    const guard = (str) => {
      if (isFunction(str)) return str(getParams());
      return machine2.implementations?.guards?.[str](getParams());
    };
    const effect = (keys) => {
      const strs = isFunction(keys) ? keys(getParams()) : keys;
      if (!strs) return;
      const fns = strs.map((s) => {
        const fn = machine2.implementations?.effects?.[s];
        if (!fn) warn(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
        return fn;
      });
      const cleanups = [];
      for (const fn of fns) {
        const cleanup = fn?.(getParams());
        if (cleanup) cleanups.push(cleanup);
      }
      return () => cleanups.forEach((fn) => fn?.());
    };
    const choose2 = (transitions) => {
      return toArray(transitions).find((t) => {
        let result = !t.guard;
        if (isString(t.guard)) result = !!guard(t.guard);
        else if (isFunction(t.guard)) result = t.guard(getParams());
        return result;
      });
    };
    const computed = (key) => {
      ensure(machine2.computed, () => `[zag-js] No computed object found on machine`);
      const fn = machine2.computed[key];
      return fn({
        context: ctx,
        event: getEvent(),
        prop,
        refs,
        scope,
        computed
      });
    };
    const state2 = useBindable(() => ({
      defaultValue: machine2.initialState({ prop }),
      onChange(nextState, prevState) {
        if (prevState) {
          const exitEffects = effects.current.get(prevState);
          exitEffects?.();
          effects.current.delete(prevState);
        }
        if (prevState) {
          action(machine2.states[prevState]?.exit);
        }
        action(transitionRef.current?.actions);
        const cleanup = effect(machine2.states[nextState]?.effects);
        if (cleanup) effects.current.set(nextState, cleanup);
        if (prevState === INIT_STATE) {
          action(machine2.entry);
          const cleanup2 = effect(machine2.effects);
          if (cleanup2) effects.current.set(INIT_STATE, cleanup2);
        }
        action(machine2.states[nextState]?.entry);
      }
    }));
    const hydratedStateRef = reactExports.useRef(void 0);
    const statusRef = reactExports.useRef(MachineStatus.NotStarted);
    useSafeLayoutEffect(() => {
      queueMicrotask(() => {
        const started = statusRef.current === MachineStatus.Started;
        statusRef.current = MachineStatus.Started;
        debug(started ? "rehydrating..." : "initializing...");
        const initialState = hydratedStateRef.current ?? state2.initial;
        state2.invoke(initialState, started ? state2.get() : INIT_STATE);
      });
      const fns = effects.current;
      const currentState = state2.ref.current;
      return () => {
        debug("unmounting...");
        hydratedStateRef.current = currentState;
        statusRef.current = MachineStatus.Stopped;
        fns.forEach((fn) => fn?.());
        effects.current = new Map();
        transitionRef.current = null;
        queueMicrotask(() => {
          action(machine2.exit);
        });
      };
    }, []);
    const getCurrentState = () => {
      if ("ref" in state2) return state2.ref.current;
      return state2.get();
    };
    const send = (event) => {
      queueMicrotask(() => {
        if (statusRef.current !== MachineStatus.Started) return;
        previousEventRef.current = eventRef.current;
        eventRef.current = event;
        let currentState = getCurrentState();
        const transitions = (
machine2.states[currentState].on?.[event.type] ??
machine2.on?.[event.type]
        );
        const transition = choose2(transitions);
        if (!transition) return;
        transitionRef.current = transition;
        const target = transition.target ?? currentState;
        debug("transition", event.type, transition.target || currentState, `(${transition.actions})`);
        const changed = target !== currentState;
        if (changed) {
          reactDomExports.flushSync(() => state2.set(target));
        } else if (transition.reenter && !changed) {
          state2.invoke(currentState, currentState);
        } else {
          action(transition.actions ?? []);
        }
      });
    };
    machine2.watch?.(getParams());
    return {
      state: getState(),
      send,
      context: ctx,
      prop,
      scope,
      refs,
      computed,
      event: getEvent(),
      getStatus: () => statusRef.current
    };
  }
  function useLiveRef(value) {
    const ref = reactExports.useRef(value);
    ref.current = value;
    return ref;
  }
  function useProp(value) {
    const ref = useLiveRef(value);
    return function get(key) {
      return ref.current[key];
    };
  }
  function flush(fn) {
    queueMicrotask(() => {
      reactDomExports.flushSync(() => fn());
    });
  }
  var normalizeProps = createNormalizer((v) => v);
  function useEvent(callback, opts = {}) {
    const { sync = false } = opts;
    const callbackRef = useLatestRef(callback);
    return reactExports.useCallback(
      (...args) => {
        if (sync) return queueMicrotask(() => callbackRef.current?.(...args));
        return callbackRef.current?.(...args);
      },
      [sync, callbackRef]
    );
  }
  function useLatestRef(value) {
    const ref = reactExports.useRef(value);
    ref.current = value;
    return ref;
  }
  const usePresence$1 = (props = {}) => {
    const { lazyMount, unmountOnExit, present, skipAnimationOnMount = false, ...rest } = props;
    const wasEverPresent = reactExports.useRef(false);
    const machineProps = {
      ...rest,
      present,
      onExitComplete: useEvent(props.onExitComplete)
    };
    const service = useMachine(machine$2, machineProps);
    const api = connect$2(service);
    if (api.present) {
      wasEverPresent.current = true;
    }
    const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
    const getPresenceProps = () => ({
      "data-state": api.skip && skipAnimationOnMount ? void 0 : present ? "open" : "closed",
      hidden: !api.present
    });
    return {
      ref: api.setNode,
      getPresenceProps,
      present: api.present,
      unmounted
    };
  };
  const [PresenceProvider] = createContext({
    name: "PresenceContext",
    hookName: "usePresenceContext",
    providerName: "<PresenceProvider />"
  });
  const Span = chakra("span");
  Span.displayName = "Span";
  const { withContext: withContext$5 } = createRecipeContext({
    key: "text"
  });
  const Text = withContext$5("p");
  Text.displayName = "Text";
  var createAnatomy = (name, parts2 = []) => ({
    parts: (...values) => {
      if (isEmpty(parts2)) {
        return createAnatomy(name, values);
      }
      throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
    },
    extendWith: (...values) => createAnatomy(name, [...parts2, ...values]),
    omit: (...values) => createAnatomy(name, parts2.filter((part) => !values.includes(part))),
    rename: (newName) => createAnatomy(newName, parts2),
    keys: () => parts2,
    build: () => [...new Set(parts2)].reduce(
      (prev2, part) => Object.assign(prev2, {
        [part]: {
          selector: [
            `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
            `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
          ].join(", "),
          attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
        }
      }),
      {}
    )
  });
  var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
  var isEmpty = (v) => v.length === 0;
  var anatomy$t = createAnatomy("collapsible").parts("root", "trigger", "content", "indicator");
  anatomy$t.build();
  createProps$1()([
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "collapsedHeight",
    "collapsedWidth",
    "onExitComplete",
    "onOpenChange",
    "defaultOpen",
    "open"
  ]);
  var __defProp$3 = Object.defineProperty;
  var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, key + "", value);
  var isEqualObject = (a, b2) => {
    if (Object.keys(a).length !== Object.keys(b2).length) return false;
    for (let key in a) if (a[key] !== b2[key]) return false;
    return true;
  };
  var Color = class {
    toHexInt() {
      return this.toFormat("rgba").toHexInt();
    }
    getChannelValue(channel) {
      if (channel in this) return this[channel];
      throw new Error("Unsupported color channel: " + channel);
    }
    getChannelValuePercent(channel, valueToCheck) {
      const value = valueToCheck ?? this.getChannelValue(channel);
      const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
      return getValuePercent(value, minValue, maxValue2);
    }
    getChannelPercentValue(channel, percentToCheck) {
      const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
      const percentValue = getPercentValue(percentToCheck, minValue, maxValue2, step);
      return snapValueToStep(percentValue, minValue, maxValue2, step);
    }
    withChannelValue(channel, value) {
      const { minValue, maxValue: maxValue2 } = this.getChannelRange(channel);
      if (channel in this) {
        let clone2 = this.clone();
        clone2[channel] = clampValue(value, minValue, maxValue2);
        return clone2;
      }
      throw new Error("Unsupported color channel: " + channel);
    }
    getColorAxes(xyChannels) {
      let { xChannel, yChannel } = xyChannels;
      let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
      let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
      let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
      return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
    }
    incrementChannel(channel, stepSize) {
      const { minValue, maxValue: maxValue2, step } = this.getChannelRange(channel);
      const value = snapValueToStep(
        clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue2),
        minValue,
        maxValue2,
        step
      );
      return this.withChannelValue(channel, value);
    }
    decrementChannel(channel, stepSize) {
      return this.incrementChannel(channel, -stepSize);
    }
    isEqual(color2) {
      const isSame = isEqualObject(this.toJSON(), color2.toJSON());
      return isSame && this.getChannelValue("alpha") === color2.getChannelValue("alpha");
    }
  };
  var HEX_COLOR_REGEX = /^#[\da-f]+$/i;
  var RGB_COLOR_REGEX = /^rgba?\((.*)\)$/;
  var HEX_STARTING_REGEX = /[^#]/gi;
  var _RGBColor = class _RGBColor2 extends Color {
    constructor(red, green, blue, alpha2) {
      super();
      this.red = red;
      this.green = green;
      this.blue = blue;
      this.alpha = alpha2;
    }
    static parse(value) {
      let colors2 = [];
      if (HEX_COLOR_REGEX.test(value) && [4, 5, 7, 9].includes(value.length)) {
        const values = (value.length < 6 ? value.replace(HEX_STARTING_REGEX, "$&$&") : value).slice(1).split("");
        while (values.length > 0) {
          colors2.push(parseInt(values.splice(0, 2).join(""), 16));
        }
        colors2[3] = colors2[3] !== void 0 ? colors2[3] / 255 : void 0;
      }
      const match2 = value.match(RGB_COLOR_REGEX);
      if (match2?.[1]) {
        colors2 = match2[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
      }
      return colors2.length < 3 ? void 0 : new _RGBColor2(colors2[0], colors2[1], colors2[2], colors2[3] ?? 1);
    }
    toString(format) {
      switch (format) {
        case "hex":
          return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
        case "hexa":
          return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
        case "rgb":
          return `rgb(${this.red}, ${this.green}, ${this.blue})`;
        case "css":
        case "rgba":
          return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
        case "hsl":
          return this.toHSL().toString("hsl");
        case "hsb":
          return this.toHSB().toString("hsb");
        default:
          return this.toFormat(format).toString(format);
      }
    }
    toFormat(format) {
      switch (format) {
        case "rgba":
          return this;
        case "hsba":
          return this.toHSB();
        case "hsla":
          return this.toHSL();
        default:
          throw new Error("Unsupported color conversion: rgb -> " + format);
      }
    }
    toHexInt() {
      return this.red << 16 | this.green << 8 | this.blue;
    }
toHSB() {
      const red = this.red / 255;
      const green = this.green / 255;
      const blue = this.blue / 255;
      const min2 = Math.min(red, green, blue);
      const brightness = Math.max(red, green, blue);
      const chroma = brightness - min2;
      const saturation = brightness === 0 ? 0 : chroma / brightness;
      let hue = 0;
      if (chroma !== 0) {
        switch (brightness) {
          case red:
            hue = (green - blue) / chroma + (green < blue ? 6 : 0);
            break;
          case green:
            hue = (blue - red) / chroma + 2;
            break;
          case blue:
            hue = (red - green) / chroma + 4;
            break;
        }
        hue /= 6;
      }
      return new HSBColor(
        toFixedNumber(hue * 360, 2),
        toFixedNumber(saturation * 100, 2),
        toFixedNumber(brightness * 100, 2),
        toFixedNumber(this.alpha, 2)
      );
    }
toHSL() {
      const red = this.red / 255;
      const green = this.green / 255;
      const blue = this.blue / 255;
      const min2 = Math.min(red, green, blue);
      const max2 = Math.max(red, green, blue);
      const lightness = (max2 + min2) / 2;
      const chroma = max2 - min2;
      let hue = -1;
      let saturation = -1;
      if (chroma === 0) {
        hue = saturation = 0;
      } else {
        saturation = chroma / (lightness < 0.5 ? max2 + min2 : 2 - max2 - min2);
        switch (max2) {
          case red:
            hue = (green - blue) / chroma + (green < blue ? 6 : 0);
            break;
          case green:
            hue = (blue - red) / chroma + 2;
            break;
          case blue:
            hue = (red - green) / chroma + 4;
            break;
        }
        hue /= 6;
      }
      return new HSLColor(
        toFixedNumber(hue * 360, 2),
        toFixedNumber(saturation * 100, 2),
        toFixedNumber(lightness * 100, 2),
        toFixedNumber(this.alpha, 2)
      );
    }
    clone() {
      return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
    }
    getChannelFormatOptions(channel) {
      switch (channel) {
        case "red":
        case "green":
        case "blue":
          return { style: "decimal" };
        case "alpha":
          return { style: "percent" };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    formatChannelValue(channel, locale) {
      let options = this.getChannelFormatOptions(channel);
      let value = this.getChannelValue(channel);
      return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
      switch (channel) {
        case "red":
        case "green":
        case "blue":
          return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
        case "alpha":
          return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    toJSON() {
      return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
    }
    getFormat() {
      return "rgba";
    }
    getChannels() {
      return _RGBColor2.colorChannels;
    }
  };
  __publicField$3(_RGBColor, "colorChannels", ["red", "green", "blue"]);
  var RGBColor = _RGBColor;
  var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
  var _HSLColor = class _HSLColor2 extends Color {
    constructor(hue, saturation, lightness, alpha2) {
      super();
      this.hue = hue;
      this.saturation = saturation;
      this.lightness = lightness;
      this.alpha = alpha2;
    }
    static parse(value) {
      let m;
      if (m = value.match(HSL_REGEX)) {
        const [h, s, l, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
        return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1));
      }
    }
    toString(format) {
      switch (format) {
        case "hex":
          return this.toRGB().toString("hex");
        case "hexa":
          return this.toRGB().toString("hexa");
        case "hsl":
          return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
        case "css":
        case "hsla":
          return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
        case "hsb":
          return this.toHSB().toString("hsb");
        case "rgb":
          return this.toRGB().toString("rgb");
        default:
          return this.toFormat(format).toString(format);
      }
    }
    toFormat(format) {
      switch (format) {
        case "hsla":
          return this;
        case "hsba":
          return this.toHSB();
        case "rgba":
          return this.toRGB();
        default:
          throw new Error("Unsupported color conversion: hsl -> " + format);
      }
    }
toHSB() {
      let saturation = this.saturation / 100;
      let lightness = this.lightness / 100;
      let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
      saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
      return new HSBColor(
        toFixedNumber(this.hue, 2),
        toFixedNumber(saturation * 100, 2),
        toFixedNumber(brightness * 100, 2),
        toFixedNumber(this.alpha, 2)
      );
    }
toRGB() {
      let hue = this.hue;
      let saturation = this.saturation / 100;
      let lightness = this.lightness / 100;
      let a = saturation * Math.min(lightness, 1 - lightness);
      let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return new RGBColor(
        Math.round(fn(0) * 255),
        Math.round(fn(8) * 255),
        Math.round(fn(4) * 255),
        toFixedNumber(this.alpha, 2)
      );
    }
    clone() {
      return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
    }
    getChannelFormatOptions(channel) {
      switch (channel) {
        case "hue":
          return { style: "unit", unit: "degree", unitDisplay: "narrow" };
        case "saturation":
        case "lightness":
        case "alpha":
          return { style: "percent" };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    formatChannelValue(channel, locale) {
      let options = this.getChannelFormatOptions(channel);
      let value = this.getChannelValue(channel);
      if (channel === "saturation" || channel === "lightness") {
        value /= 100;
      }
      return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
      switch (channel) {
        case "hue":
          return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
        case "saturation":
        case "lightness":
          return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
        case "alpha":
          return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    toJSON() {
      return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
    }
    getFormat() {
      return "hsla";
    }
    getChannels() {
      return _HSLColor2.colorChannels;
    }
  };
  __publicField$3(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
  var HSLColor = _HSLColor;
  var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
  var _HSBColor = class _HSBColor2 extends Color {
    constructor(hue, saturation, brightness, alpha2) {
      super();
      this.hue = hue;
      this.saturation = saturation;
      this.brightness = brightness;
      this.alpha = alpha2;
    }
    static parse(value) {
      let m;
      if (m = value.match(HSB_REGEX)) {
        const [h, s, b2, a] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
        return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b2, 0, 100), clampValue(a ?? 1, 0, 1));
      }
    }
    toString(format) {
      switch (format) {
        case "css":
          return this.toHSL().toString("css");
        case "hex":
          return this.toRGB().toString("hex");
        case "hexa":
          return this.toRGB().toString("hexa");
        case "hsb":
          return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
        case "hsba":
          return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
        case "hsl":
          return this.toHSL().toString("hsl");
        case "rgb":
          return this.toRGB().toString("rgb");
        default:
          return this.toFormat(format).toString(format);
      }
    }
    toFormat(format) {
      switch (format) {
        case "hsba":
          return this;
        case "hsla":
          return this.toHSL();
        case "rgba":
          return this.toRGB();
        default:
          throw new Error("Unsupported color conversion: hsb -> " + format);
      }
    }
toHSL() {
      let saturation = this.saturation / 100;
      let brightness = this.brightness / 100;
      let lightness = brightness * (1 - saturation / 2);
      saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
      return new HSLColor(
        toFixedNumber(this.hue, 2),
        toFixedNumber(saturation * 100, 2),
        toFixedNumber(lightness * 100, 2),
        toFixedNumber(this.alpha, 2)
      );
    }
toRGB() {
      let hue = this.hue;
      let saturation = this.saturation / 100;
      let brightness = this.brightness / 100;
      let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
      return new RGBColor(
        Math.round(fn(5) * 255),
        Math.round(fn(3) * 255),
        Math.round(fn(1) * 255),
        toFixedNumber(this.alpha, 2)
      );
    }
    clone() {
      return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
    }
    getChannelFormatOptions(channel) {
      switch (channel) {
        case "hue":
          return { style: "unit", unit: "degree", unitDisplay: "narrow" };
        case "saturation":
        case "brightness":
        case "alpha":
          return { style: "percent" };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    formatChannelValue(channel, locale) {
      let options = this.getChannelFormatOptions(channel);
      let value = this.getChannelValue(channel);
      if (channel === "saturation" || channel === "brightness") {
        value /= 100;
      }
      return new Intl.NumberFormat(locale, options).format(value);
    }
    getChannelRange(channel) {
      switch (channel) {
        case "hue":
          return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
        case "saturation":
        case "brightness":
          return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
        case "alpha":
          return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
        default:
          throw new Error("Unknown color channel: " + channel);
      }
    }
    toJSON() {
      return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
    }
    getFormat() {
      return "hsba";
    }
    getChannels() {
      return _HSBColor2.colorChannels;
    }
  };
  __publicField$3(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
  var HSBColor = _HSBColor;
  var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,rebeccapurple:663399,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
  var makeMap = (str) => {
    const map2 = new Map();
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      const [key, val] = list[i].split(":");
      map2.set(key, `#${val}`);
      if (key.includes("gray")) map2.set(key.replace("gray", "grey"), `#${val}`);
    }
    return map2;
  };
  var nativeColorMap = makeMap(nativeColors);
  var parseColor = (value) => {
    if (nativeColorMap.has(value)) {
      return parseColor(nativeColorMap.get(value));
    }
    const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
    if (!result) {
      const error = new Error("Invalid color value: " + value);
      Error.captureStackTrace?.(error, parseColor);
      throw error;
    }
    return result;
  };
  const sides = ["top", "right", "bottom", "left"];
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v) => ({
    x: v,
    y: v
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp$1(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  const yAxisSides = new Set(["top", "bottom"]);
  function getSideAxis$1(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis$1(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length2 = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length2] > rects.floating[length2]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  const lrPlacement = ["left", "right"];
  const rlPlacement = ["right", "left"];
  const tbPlacement = ["top", "bottom"];
  const btPlacement = ["bottom", "top"];
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y,
      left: x2,
      right: x2 + width,
      bottom: y + height,
      x: x2,
      y
    };
  }
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis$1(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  const computePosition$1 = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware: middleware2 = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware2.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i = 0; i < validMiddleware.length; i++) {
      const {
        name,
        fn
      } = validMiddleware[i];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x: x2,
        y,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y = nextY != null ? nextY : y;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i = -1;
      }
    }
    return {
      x: x2,
      y,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state2, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state2;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state2);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$1 = (options) => ({
    name: "arrow",
    options,
    async fn(state2) {
      const {
        x: x2,
        y,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state2;
      const {
        element,
        padding = 0
      } = evaluate(options, state2) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y
      };
      const axis = getAlignmentAxis(placement);
      const length2 = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length2];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$12 = minPadding;
      const max2 = clientSize - arrowDimensions[length2] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
      const offset2 = clamp$1(min$12, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state2) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state2;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state2);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis$1(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex2];
          if (nextPlacement) {
            const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis$1(nextPlacement) : false;
            if (!ignoreCrossAxisOverflow ||

overflowsData.every((d) => getSideAxis$1(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
              return {
                data: {
                  index: nextIndex2,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis$1(d.placement);
                    return currentSideAxis === initialSideAxis ||

currentSideAxis === "y";
                  }
                  return true;
                }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  const hide$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "hide",
      options,
      async fn(state2) {
        const {
          rects
        } = state2;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options, state2);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state2, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state2, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  const originSides = new Set(["left", "top"]);
  async function convertValueToCoords(state2, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state2;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis$1(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state2);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state2) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y,
          placement,
          middlewareData
        } = state2;
        const diffCoords = await convertValueToCoords(state2, options);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state2) {
        const {
          x: x2,
          y,
          placement
        } = state2;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y2
              } = _ref;
              return {
                x: x3,
                y: y2
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state2);
        const coords = {
          x: x2,
          y
        };
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const crossAxis = getSideAxis$1(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state2,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  const limitShift$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state2) {
        const {
          x: x2,
          y,
          placement,
          rects,
          middlewareData
        } = state2;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state2);
        const coords = {
          x: x2,
          y
        };
        const crossAxis = getSideAxis$1(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset2, state2);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = originSides.has(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  const size$1 = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state2) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state2;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state2);
        const overflow = await detectOverflow(state2, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis$1(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state2.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state2,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node2) {
    if (isNode(node2)) {
      return (node2.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node2) {
    var _node$ownerDocument;
    return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node2) {
    var _ref;
    return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement$1(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  const invalidOverflowDisplayValues = new Set(["inline", "contents"]);
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$2(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  const tableElements = new Set(["table", "td", "th"]);
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  const topLayerSelectors = [":popover-open", ":modal"];
  function isTopLayer(element) {
    return topLayerSelectors.some((selector) => {
      try {
        return element.matches(selector);
      } catch (_e) {
        return false;
      }
    });
  }
  const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
  const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
  const containValues = ["paint", "layout", "strict", "content"];
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css2 = isElement(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
    return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  const lastTraversableNodeNames = new Set(["html", "body", "#document"]);
  function isLastTraversableNode(node2) {
    return lastTraversableNodeNames.has(getNodeName(node2));
  }
  function getComputedStyle$2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node2) {
    if (getNodeName(node2) === "html") {
      return node2;
    }
    const result = (
node2.assignedSlot ||
node2.parentNode ||
isShadowRoot(node2) && node2.host ||
getDocumentElement(node2)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node2) {
    const parentNode = getParentNode(node2);
    if (isLastTraversableNode(parentNode)) {
      return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
    }
    if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node2, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node2);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css2 = getComputedStyle$2(element);
    let width = parseFloat(css2.width) || 0;
    let height = parseFloat(css2.height) || 0;
    const hasOffset = isHTMLElement$1(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement$1(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x2 = ($ ? round(rect.width) : rect.width) / width;
    let y = ($ ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y || !Number.isFinite(y)) {
      y = 1;
    }
    return {
      x: x2,
      y
    };
  }
  const noOffsets = createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale2 = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale2 = getScale(offsetParent);
        }
      } else {
        scale2 = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
    let y = (clientRect.top + visualOffsets.y) / scale2.y;
    let width = clientRect.width / scale2.x;
    let height = clientRect.height / scale2.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css2 = getComputedStyle$2(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll) {
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
    const y = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale2 = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement$1(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale2 = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    return {
      width: rect.width * scale2.x,
      height: rect.height * scale2.y,
      x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
      y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y = -scroll.scrollTop;
    if (getComputedStyle$2(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  const SCROLLBAR_MAX = 25;
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    const windowScrollbarX = getWindowScrollBarX(html);
    if (windowScrollbarX <= 0) {
      const doc = html.ownerDocument;
      const body = doc.body;
      const bodyStyles = getComputedStyle(body);
      const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
      const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
      if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
        width -= clippingStableScrollbarWidth;
      }
    } else if (windowScrollbarX <= SCROLLBAR_MAX) {
      width += windowScrollbarX;
    }
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  const absoluteOrFixed = new Set(["absolute", "fixed"]);
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale2 = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale2.x;
    const height = element.clientHeight * scale2.y;
    const x2 = left * scale2.x;
    const y = top * scale2.y;
    return {
      width,
      height,
      x: x2,
      y
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache2) {
    const cachedResult = cache2.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$2(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$2(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache2.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$2(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement$1(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$2(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a, b2) {
    return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
root: root2.ownerDocument
        });
      } catch (_e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset = offset$1;
  const shift = shift$1;
  const flip = flip$1;
  const size = size$1;
  const hide = hide$1;
  const arrow = arrow$1;
  const limitShift = limitShift$1;
  const computePosition = (reference, floating, options) => {
    const cache2 = new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache2
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  function createDOMRect(x2 = 0, y = 0, width = 0, height = 0) {
    if (typeof DOMRect === "function") {
      return new DOMRect(x2, y, width, height);
    }
    const rect = {
      x: x2,
      y,
      width,
      height,
      top: y,
      right: x2 + width,
      bottom: y + height,
      left: x2
    };
    return { ...rect, toJSON: () => rect };
  }
  function getDOMRect(anchorRect) {
    if (!anchorRect) return createDOMRect();
    const { x: x2, y, width, height } = anchorRect;
    return createDOMRect(x2, y, width, height);
  }
  function getAnchorElement(anchorElement, getAnchorRect) {
    return {
      contextElement: isHTMLElement$2(anchorElement) ? anchorElement : void 0,
      getBoundingClientRect: () => {
        const anchor = anchorElement;
        const anchorRect = getAnchorRect?.(anchor);
        if (anchorRect || !anchor) {
          return getDOMRect(anchorRect);
        }
        return anchor.getBoundingClientRect();
      }
    };
  }
  var toVar = (value) => ({ variable: value, reference: `var(${value})` });
  var cssVars = {
    transformOrigin: toVar("--transform-origin"),
    arrowOffset: toVar("--arrow-offset")
  };
  var getSideAxis = (side) => side === "top" || side === "bottom" ? "y" : "x";
  function createTransformOriginMiddleware(opts, arrowEl) {
    return {
      name: "transformOrigin",
      fn(state2) {
        const { elements, middlewareData, placement, rects, y } = state2;
        const side = placement.split("-")[0];
        const axis = getSideAxis(side);
        const arrowX = middlewareData.arrow?.x || 0;
        const arrowY = middlewareData.arrow?.y || 0;
        const arrowWidth = arrowEl?.clientWidth || 0;
        const arrowHeight = arrowEl?.clientHeight || 0;
        const transformX = arrowX + arrowWidth / 2;
        const transformY = arrowY + arrowHeight / 2;
        const shiftY = Math.abs(middlewareData.shift?.y || 0);
        const halfAnchorHeight = rects.reference.height / 2;
        const arrowOffset = arrowHeight / 2;
        const gutter = opts.offset?.mainAxis ?? opts.gutter;
        const sideOffsetValue = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
        const isOverlappingAnchor = shiftY > sideOffsetValue;
        const adjacentTransformOrigin = {
          top: `${transformX}px calc(100% + ${sideOffsetValue}px)`,
          bottom: `${transformX}px ${-sideOffsetValue}px`,
          left: `calc(100% + ${sideOffsetValue}px) ${transformY}px`,
          right: `${-sideOffsetValue}px ${transformY}px`
        }[side];
        const overlapTransformOrigin = `${transformX}px ${rects.reference.y + halfAnchorHeight - y}px`;
        const useOverlap = Boolean(opts.overlap) && axis === "y" && isOverlappingAnchor;
        elements.floating.style.setProperty(
          cssVars.transformOrigin.variable,
          useOverlap ? overlapTransformOrigin : adjacentTransformOrigin
        );
        return {
          data: {
            transformOrigin: useOverlap ? overlapTransformOrigin : adjacentTransformOrigin
          }
        };
      }
    };
  }
  var rectMiddleware = {
    name: "rects",
    fn({ rects }) {
      return {
        data: rects
      };
    }
  };
  var shiftArrowMiddleware = (arrowEl) => {
    if (!arrowEl) return;
    return {
      name: "shiftArrow",
      fn({ placement, middlewareData }) {
        if (!middlewareData.arrow) return {};
        const { x: x2, y } = middlewareData.arrow;
        const dir = placement.split("-")[0];
        Object.assign(arrowEl.style, {
          left: x2 != null ? `${x2}px` : "",
          top: y != null ? `${y}px` : "",
          [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
        });
        return {};
      }
    };
  };
  function getPlacementDetails(placement) {
    const [side, align] = placement.split("-");
    return { side, align, hasAlign: align != null };
  }
  function getPlacementSide(placement) {
    return placement.split("-")[0];
  }
  var defaultOptions = {
    strategy: "absolute",
    placement: "bottom",
    listeners: true,
    gutter: 8,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    overflowPadding: 8,
    arrowPadding: 4
  };
  function roundByDpr(win, value) {
    const dpr = win.devicePixelRatio || 1;
    return Math.round(value * dpr) / dpr;
  }
  function resolveBoundaryOption(boundary) {
    if (typeof boundary === "function") return boundary();
    if (boundary === "clipping-ancestors") return "clippingAncestors";
    return boundary;
  }
  function getArrowMiddleware(arrowElement, doc, opts) {
    const element = arrowElement || doc.createElement("div");
    return arrow({ element, padding: opts.arrowPadding });
  }
  function getOffsetMiddleware(arrowElement, opts) {
    if (isNull(opts.offset ?? opts.gutter)) return;
    return offset(({ placement }) => {
      const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
      const gutter = opts.offset?.mainAxis ?? opts.gutter;
      const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
      const { hasAlign } = getPlacementDetails(placement);
      const shift2 = !hasAlign ? opts.shift : void 0;
      const crossAxis = opts.offset?.crossAxis ?? shift2;
      return compact({
        crossAxis,
        mainAxis,
        alignmentAxis: opts.shift
      });
    });
  }
  function getFlipMiddleware(opts) {
    if (!opts.flip) return;
    const boundary = resolveBoundaryOption(opts.boundary);
    return flip({
      ...boundary ? { boundary } : void 0,
      padding: opts.overflowPadding,
      fallbackPlacements: opts.flip === true ? void 0 : opts.flip
    });
  }
  function getShiftMiddleware(opts) {
    if (!opts.slide && !opts.overlap) return;
    const boundary = resolveBoundaryOption(opts.boundary);
    return shift({
      ...boundary ? { boundary } : void 0,
      mainAxis: opts.slide,
      crossAxis: opts.overlap,
      padding: opts.overflowPadding,
      limiter: limitShift()
    });
  }
  function getSizeMiddleware(opts) {
    return size({
      padding: opts.overflowPadding,
      apply({ elements, rects, availableHeight, availableWidth }) {
        const floating = elements.floating;
        const referenceWidth = Math.round(rects.reference.width);
        const referenceHeight = Math.round(rects.reference.height);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floating.style.setProperty("--reference-width", `${referenceWidth}px`);
        floating.style.setProperty("--reference-height", `${referenceHeight}px`);
        floating.style.setProperty("--available-width", `${availableWidth}px`);
        floating.style.setProperty("--available-height", `${availableHeight}px`);
      }
    });
  }
  function hideWhenDetachedMiddleware(opts) {
    if (!opts.hideWhenDetached) return;
    return hide({ strategy: "referenceHidden", boundary: resolveBoundaryOption(opts.boundary) ?? "clippingAncestors" });
  }
  function getAutoUpdateOptions(opts) {
    if (!opts) return {};
    if (opts === true) {
      return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
    }
    return opts;
  }
  function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
    const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
    if (!floating || !reference) return;
    const options = Object.assign({}, defaultOptions, opts);
    const arrowEl = floating.querySelector("[data-part=arrow]");
    const middleware2 = [
      getOffsetMiddleware(arrowEl, options),
      getFlipMiddleware(options),
      getShiftMiddleware(options),
      getArrowMiddleware(arrowEl, floating.ownerDocument, options),
      shiftArrowMiddleware(arrowEl),
      createTransformOriginMiddleware(
        { gutter: options.gutter, offset: options.offset, overlap: options.overlap },
        arrowEl
      ),
      getSizeMiddleware(options),
      hideWhenDetachedMiddleware(options),
      rectMiddleware
    ];
    const { placement, strategy, onComplete, onPositioned } = options;
    const updatePosition = async () => {
      if (!reference || !floating) return;
      const pos = await computePosition(reference, floating, {
        placement,
        middleware: middleware2,
        strategy
      });
      onComplete?.(pos);
      onPositioned?.({ placed: true });
      const win = getWindow$1(floating);
      const x2 = roundByDpr(win, pos.x);
      const y = roundByDpr(win, pos.y);
      floating.style.setProperty("--x", `${x2}px`);
      floating.style.setProperty("--y", `${y}px`);
      if (options.hideWhenDetached) {
        const isHidden = pos.middlewareData.hide?.referenceHidden;
        if (isHidden) {
          floating.style.setProperty("visibility", "hidden");
          floating.style.setProperty("pointer-events", "none");
        } else {
          floating.style.removeProperty("visibility");
          floating.style.removeProperty("pointer-events");
        }
      }
      const contentEl = floating.firstElementChild;
      if (contentEl) {
        const styles = getComputedStyle$3(contentEl);
        floating.style.setProperty("--z-index", styles.zIndex);
      }
    };
    const update = async () => {
      if (opts.updatePosition) {
        await opts.updatePosition({ updatePosition, floatingElement: floating });
        onPositioned?.({ placed: true });
      } else {
        await updatePosition();
      }
    };
    const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
    const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop$2;
    update();
    return () => {
      cancelAutoUpdate?.();
      onPositioned?.({ placed: false });
    };
  }
  function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
    const { defer, ...options } = opts;
    const func = defer ? raf : (v) => v();
    const cleanups = [];
    cleanups.push(
      func(() => {
        const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
        const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
        cleanups.push(getPlacementImpl(reference, floating, options));
      })
    );
    return () => {
      cleanups.forEach((fn) => fn?.());
    };
  }
  function getWindowFrames(win) {
    const frames = {
      each(cb) {
        for (let i = 0; i < win.frames?.length; i += 1) {
          const frame2 = win.frames[i];
          if (frame2) cb(frame2);
        }
      },
      addEventListener(event, listener, options) {
        frames.each((frame2) => {
          try {
            frame2.document.addEventListener(event, listener, options);
          } catch {
          }
        });
        return () => {
          try {
            frames.removeEventListener(event, listener, options);
          } catch {
          }
        };
      },
      removeEventListener(event, listener, options) {
        frames.each((frame2) => {
          try {
            frame2.document.removeEventListener(event, listener, options);
          } catch {
          }
        });
      }
    };
    return frames;
  }
  function getParentWindow(win) {
    const parent = win.frameElement != null ? win.parent : null;
    return {
      addEventListener: (event, listener, options) => {
        try {
          parent?.addEventListener(event, listener, options);
        } catch {
        }
        return () => {
          try {
            parent?.removeEventListener(event, listener, options);
          } catch {
          }
        };
      },
      removeEventListener: (event, listener, options) => {
        try {
          parent?.removeEventListener(event, listener, options);
        } catch {
        }
      }
    };
  }
  var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
  var FOCUS_OUTSIDE_EVENT = "focus.outside";
  function isComposedPathFocusable(composedPath) {
    for (const node2 of composedPath) {
      if (isHTMLElement$2(node2) && isFocusable(node2)) return true;
    }
    return false;
  }
  var isPointerEvent = (event) => "clientY" in event;
  function isEventPointWithin(node2, event) {
    if (!isPointerEvent(event) || !node2) return false;
    const rect = node2.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return false;
    return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
  }
  function isPointInRect(rect, point) {
    return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
  }
  function isEventWithinScrollbar(event, ancestor) {
    if (!ancestor || !isPointerEvent(event)) return false;
    const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
    const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
    const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
    const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
    const rect = {
      x: ancestor.offsetLeft,
      y: ancestor.offsetTop,
      width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
      height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
    };
    const point = {
      x: event.clientX,
      y: event.clientY
    };
    if (!isPointInRect(rect, point)) return false;
    return onScrollbarY || onScrollbarX;
  }
  function trackInteractOutsideImpl(node2, options) {
    const {
      exclude,
      onFocusOutside,
      onPointerDownOutside,
      onInteractOutside,
      defer,
      followControlledElements = true
    } = options;
    if (!node2) return;
    const doc = getDocument(node2);
    const win = getWindow$1(node2);
    const frames = getWindowFrames(win);
    const parentWin = getParentWindow(win);
    function isEventOutside(event, target) {
      if (!isHTMLElement$2(target)) return false;
      if (!target.isConnected) return false;
      if (contains(node2, target)) return false;
      if (isEventPointWithin(node2, event)) return false;
      if (followControlledElements && isControlledElement(node2, target)) return false;
      const triggerEl = doc.querySelector(`[aria-controls="${node2.id}"]`);
      if (triggerEl) {
        const triggerAncestor = getNearestOverflowAncestor$1(triggerEl);
        if (isEventWithinScrollbar(event, triggerAncestor)) return false;
      }
      const nodeAncestor = getNearestOverflowAncestor$1(node2);
      if (isEventWithinScrollbar(event, nodeAncestor)) return false;
      return !exclude?.(target);
    }
    const pointerdownCleanups = new Set();
    const isInShadowRoot = isShadowRoot$1(node2?.getRootNode());
    function onPointerDown(event) {
      function handler(clickEvent) {
        const func = defer && !isTouchDevice() ? raf : (v) => v();
        const evt = clickEvent ?? event;
        const composedPath = evt?.composedPath?.() ?? [evt?.target];
        func(() => {
          const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
          if (!node2 || !isEventOutside(event, target)) return;
          if (onPointerDownOutside || onInteractOutside) {
            const handler2 = callAll(onPointerDownOutside, onInteractOutside);
            node2.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
          }
          fireCustomEvent$1(node2, POINTER_OUTSIDE_EVENT, {
            bubbles: false,
            cancelable: true,
            detail: {
              originalEvent: evt,
              contextmenu: isContextMenuEvent(evt),
              focusable: isComposedPathFocusable(composedPath),
              target
            }
          });
        });
      }
      if (event.pointerType === "touch") {
        pointerdownCleanups.forEach((fn) => fn());
        pointerdownCleanups.add(addDomEvent$1(doc, "click", handler, { once: true }));
        pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
        pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
      } else {
        handler();
      }
    }
    const cleanups = new Set();
    const timer = setTimeout(() => {
      cleanups.add(addDomEvent$1(doc, "pointerdown", onPointerDown, true));
      cleanups.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
      cleanups.add(frames.addEventListener("pointerdown", onPointerDown, true));
    }, 0);
    function onFocusin(event) {
      const func = defer ? raf : (v) => v();
      func(() => {
        const composedPath = event?.composedPath?.() ?? [event?.target];
        const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);
        if (!node2 || !isEventOutside(event, target)) return;
        if (onFocusOutside || onInteractOutside) {
          const handler = callAll(onFocusOutside, onInteractOutside);
          node2.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
        }
        fireCustomEvent$1(node2, FOCUS_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: false,
            focusable: isFocusable(target),
            target
          }
        });
      });
    }
    if (!isTouchDevice()) {
      cleanups.add(addDomEvent$1(doc, "focusin", onFocusin, true));
      cleanups.add(parentWin.addEventListener("focusin", onFocusin, true));
      cleanups.add(frames.addEventListener("focusin", onFocusin, true));
    }
    return () => {
      clearTimeout(timer);
      pointerdownCleanups.forEach((fn) => fn());
      cleanups.forEach((fn) => fn());
    };
  }
  function trackInteractOutside(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v) => v();
    const cleanups = [];
    cleanups.push(
      func(() => {
        const node2 = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackInteractOutsideImpl(node2, options));
      })
    );
    return () => {
      cleanups.forEach((fn) => fn?.());
    };
  }
  function fireCustomEvent$1(el, type, init) {
    const win = el.ownerDocument.defaultView || window;
    const event = new win.CustomEvent(type, init);
    return el.dispatchEvent(event);
  }
  function trackEscapeKeydown(node2, fn) {
    const handleKeyDown = (event) => {
      if (event.key !== "Escape") return;
      if (event.isComposing) return;
      fn?.(event);
    };
    return addDomEvent$1(getDocument(node2), "keydown", handleKeyDown, { capture: true });
  }
  var LAYER_REQUEST_DISMISS_EVENT = "layer:request-dismiss";
  var layerStack = {
    layers: [],
    branches: [],
    count() {
      return this.layers.length;
    },
    pointerBlockingLayers() {
      return this.layers.filter((layer) => layer.pointerBlocking);
    },
    topMostPointerBlockingLayer() {
      return [...this.pointerBlockingLayers()].slice(-1)[0];
    },
    hasPointerBlockingLayer() {
      return this.pointerBlockingLayers().length > 0;
    },
    isBelowPointerBlockingLayer(node2) {
      const index = this.indexOf(node2);
      const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
      return index < highestBlockingIndex;
    },
    isTopMost(node2) {
      const layer = this.layers[this.count() - 1];
      return layer?.node === node2;
    },
    getNestedLayers(node2) {
      return Array.from(this.layers).slice(this.indexOf(node2) + 1);
    },
    getLayersByType(type) {
      return this.layers.filter((layer) => layer.type === type);
    },
    getNestedLayersByType(node2, type) {
      const index = this.indexOf(node2);
      if (index === -1) return [];
      return this.layers.slice(index + 1).filter((layer) => layer.type === type);
    },
    getParentLayerOfType(node2, type) {
      const index = this.indexOf(node2);
      if (index <= 0) return void 0;
      return this.layers.slice(0, index).reverse().find((layer) => layer.type === type);
    },
    countNestedLayersOfType(node2, type) {
      return this.getNestedLayersByType(node2, type).length;
    },
    isInNestedLayer(node2, target) {
      return this.getNestedLayers(node2).some((layer) => contains(layer.node, target));
    },
    isInBranch(target) {
      return Array.from(this.branches).some((branch) => contains(branch, target));
    },
    add(layer) {
      this.layers.push(layer);
      this.syncLayers();
    },
    addBranch(node2) {
      this.branches.push(node2);
    },
    remove(node2) {
      const index = this.indexOf(node2);
      if (index < 0) return;
      if (index < this.count() - 1) {
        const _layers = this.getNestedLayers(node2);
        _layers.forEach((layer) => layerStack.dismiss(layer.node, node2));
      }
      this.layers.splice(index, 1);
      this.syncLayers();
    },
    removeBranch(node2) {
      const index = this.branches.indexOf(node2);
      if (index >= 0) this.branches.splice(index, 1);
    },
    syncLayers() {
      this.layers.forEach((layer, index) => {
        layer.node.style.setProperty("--layer-index", `${index}`);
        layer.node.removeAttribute("data-nested");
        layer.node.removeAttribute("data-has-nested");
        const parentOfSameType = this.getParentLayerOfType(layer.node, layer.type);
        if (parentOfSameType) {
          layer.node.setAttribute("data-nested", layer.type);
        }
        const nestedCount = this.countNestedLayersOfType(layer.node, layer.type);
        if (nestedCount > 0) {
          layer.node.setAttribute("data-has-nested", layer.type);
        }
        layer.node.style.setProperty("--nested-layer-count", `${nestedCount}`);
      });
    },
    indexOf(node2) {
      return this.layers.findIndex((layer) => layer.node === node2);
    },
    dismiss(node2, parent) {
      const index = this.indexOf(node2);
      if (index === -1) return;
      const layer = this.layers[index];
      addListenerOnce(node2, LAYER_REQUEST_DISMISS_EVENT, (event) => {
        layer.requestDismiss?.(event);
        if (!event.defaultPrevented) {
          layer?.dismiss();
        }
      });
      fireCustomEvent(node2, LAYER_REQUEST_DISMISS_EVENT, {
        originalLayer: node2,
        targetLayer: parent,
        originalIndex: index,
        targetIndex: parent ? this.indexOf(parent) : -1
      });
      this.syncLayers();
    },
    clear() {
      this.remove(this.layers[0].node);
    }
  };
  function fireCustomEvent(el, type, detail) {
    const win = el.ownerDocument.defaultView || window;
    const event = new win.CustomEvent(type, { cancelable: true, bubbles: true, detail });
    return el.dispatchEvent(event);
  }
  function addListenerOnce(el, type, callback) {
    el.addEventListener(type, callback, { once: true });
  }
  var originalBodyPointerEvents;
  function assignPointerEventToLayers() {
    layerStack.layers.forEach(({ node: node2 }) => {
      node2.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node2) ? "none" : "auto";
    });
  }
  function clearPointerEvent(node2) {
    node2.style.pointerEvents = "";
  }
  function disablePointerEventsOutside(node2, persistentElements) {
    const doc = getDocument(node2);
    const cleanups = [];
    if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
      originalBodyPointerEvents = document.body.style.pointerEvents;
      queueMicrotask(() => {
        doc.body.style.pointerEvents = "none";
        doc.body.setAttribute("data-inert", "");
      });
    }
    persistentElements?.forEach((el) => {
      const [promise, abort] = waitForElement(
        () => {
          const node22 = el();
          return isHTMLElement$2(node22) ? node22 : null;
        },
        { timeout: 1e3 }
      );
      promise.then((el2) => cleanups.push(setStyle$1(el2, { pointerEvents: "auto" })));
      cleanups.push(abort);
    });
    return () => {
      if (layerStack.hasPointerBlockingLayer()) return;
      queueMicrotask(() => {
        doc.body.style.pointerEvents = originalBodyPointerEvents;
        doc.body.removeAttribute("data-inert");
        if (doc.body.style.length === 0) doc.body.removeAttribute("style");
      });
      cleanups.forEach((fn) => fn());
    };
  }
  function trackDismissableElementImpl(node2, options) {
    const { warnOnMissingNode = true } = options;
    if (warnOnMissingNode && !node2) {
      warn("[@zag-js/dismissable] node is `null` or `undefined`");
      return;
    }
    if (!node2) {
      return;
    }
    const { onDismiss, onRequestDismiss, pointerBlocking, exclude: excludeContainers, debug, type = "dialog" } = options;
    const layer = { dismiss: onDismiss, node: node2, type, pointerBlocking, requestDismiss: onRequestDismiss };
    layerStack.add(layer);
    assignPointerEventToLayers();
    function onPointerDownOutside(event) {
      const target = getEventTarget(event.detail.originalEvent);
      if (layerStack.isBelowPointerBlockingLayer(node2) || layerStack.isInBranch(target)) return;
      options.onPointerDownOutside?.(event);
      options.onInteractOutside?.(event);
      if (event.defaultPrevented) return;
      if (debug) {
        console.log("onPointerDownOutside:", event.detail.originalEvent);
      }
      onDismiss?.();
    }
    function onFocusOutside(event) {
      const target = getEventTarget(event.detail.originalEvent);
      if (layerStack.isInBranch(target)) return;
      options.onFocusOutside?.(event);
      options.onInteractOutside?.(event);
      if (event.defaultPrevented) return;
      if (debug) {
        console.log("onFocusOutside:", event.detail.originalEvent);
      }
      onDismiss?.();
    }
    function onEscapeKeyDown(event) {
      if (!layerStack.isTopMost(node2)) return;
      options.onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }
    function exclude(target) {
      if (!node2) return false;
      const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
      const _containers = Array.isArray(containers) ? containers : [containers];
      const persistentElements = options.persistentElements?.map((fn) => fn()).filter(isHTMLElement$2);
      if (persistentElements) _containers.push(...persistentElements);
      return _containers.some((node22) => contains(node22, target)) || layerStack.isInNestedLayer(node2, target);
    }
    const cleanups = [
      pointerBlocking ? disablePointerEventsOutside(node2, options.persistentElements) : void 0,
      trackEscapeKeydown(node2, onEscapeKeyDown),
      trackInteractOutside(node2, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
    ];
    return () => {
      layerStack.remove(node2);
      assignPointerEventToLayers();
      clearPointerEvent(node2);
      cleanups.forEach((fn) => fn?.());
    };
  }
  function trackDismissableElement(nodeOrFn, options) {
    const { defer } = options;
    const func = defer ? raf : (v) => v();
    const cleanups = [];
    cleanups.push(
      func(() => {
        const node2 = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
        cleanups.push(trackDismissableElementImpl(node2, options));
      })
    );
    return () => {
      cleanups.forEach((fn) => fn?.());
    };
  }
  var anatomy$s = createAnatomy("color-picker", [
    "root",
    "label",
    "control",
    "trigger",
    "positioner",
    "content",
    "area",
    "areaThumb",
    "valueText",
    "areaBackground",
    "channelSlider",
    "channelSliderLabel",
    "channelSliderTrack",
    "channelSliderThumb",
    "channelSliderValueText",
    "channelInput",
    "transparencyGrid",
    "swatchGroup",
    "swatchTrigger",
    "swatchIndicator",
    "swatch",
    "eyeDropperTrigger",
    "formatTrigger",
    "formatSelect"
  ]);
  anatomy$s.build();
  var getHiddenInputId$1 = (ctx) => ctx.ids?.hiddenInput ?? `color-picker:${ctx.id}:hidden-input`;
  var getControlId$1 = (ctx) => ctx.ids?.control ?? `color-picker:${ctx.id}:control`;
  var getTriggerId$6 = (ctx) => ctx.ids?.trigger ?? `color-picker:${ctx.id}:trigger`;
  var getContentId$7 = (ctx) => ctx.ids?.content ?? `color-picker:${ctx.id}:content`;
  var getPositionerId$5 = (ctx) => ctx.ids?.positioner ?? `color-picker:${ctx.id}:positioner`;
  var getFormatSelectId = (ctx) => ctx.ids?.formatSelect ?? `color-picker:${ctx.id}:format-select`;
  var getAreaId = (ctx) => ctx.ids?.area ?? `color-picker:${ctx.id}:area`;
  var getAreaThumbId = (ctx) => ctx.ids?.areaThumb ?? `color-picker:${ctx.id}:area-thumb`;
  var getChannelSliderTrackId = (ctx, channel) => ctx.ids?.channelSliderTrack?.(channel) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  var getChannelSliderThumbId = (ctx, channel) => ctx.ids?.channelSliderThumb?.(channel) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  var getContentEl$7 = (ctx) => ctx.getById(getContentId$7(ctx));
  var getAreaThumbEl = (ctx) => ctx.getById(getAreaThumbId(ctx));
  var getChannelSliderThumbEl = (ctx, channel) => ctx.getById(getChannelSliderThumbId(ctx, channel));
  var getFormatSelectEl = (ctx) => ctx.getById(getFormatSelectId(ctx));
  var getHiddenInputEl$1 = (ctx) => ctx.getById(getHiddenInputId$1(ctx));
  var getAreaEl = (ctx) => ctx.getById(getAreaId(ctx));
  var getAreaValueFromPoint = (ctx, point, dir) => {
    const areaEl = getAreaEl(ctx);
    if (!areaEl) return;
    const { getPercentValue: getPercentValue2 } = getRelativePoint(point, areaEl);
    return {
      x: getPercentValue2({ dir, orientation: "horizontal" }),
      y: getPercentValue2({ orientation: "vertical" })
    };
  };
  var getControlEl$1 = (ctx) => ctx.getById(getControlId$1(ctx));
  var getTriggerEl$6 = (ctx) => ctx.getById(getTriggerId$6(ctx));
  var getPositionerEl$5 = (ctx) => ctx.getById(getPositionerId$5(ctx));
  var getChannelSliderTrackEl = (ctx, channel) => ctx.getById(getChannelSliderTrackId(ctx, channel));
  var getChannelSliderValueFromPoint = (ctx, point, channel, dir) => {
    const trackEl = getChannelSliderTrackEl(ctx, channel);
    if (!trackEl) return;
    const { getPercentValue: getPercentValue2 } = getRelativePoint(point, trackEl);
    return {
      x: getPercentValue2({ dir, orientation: "horizontal" }),
      y: getPercentValue2({ orientation: "vertical" })
    };
  };
  var getChannelInputEls = (ctx) => {
    return [
      ...queryAll(getContentEl$7(ctx), "input[data-channel]"),
      ...queryAll(getControlEl$1(ctx), "input[data-channel]")
    ];
  };
  function getChannelValue(color2, channel) {
    if (channel == null) return "";
    if (channel === "hex") {
      return color2.toString("hex");
    }
    if (channel === "css") {
      return color2.toString("css");
    }
    if (channel in color2) {
      return color2.getChannelValue(channel).toString();
    }
    const isHSL = color2.getFormat() === "hsla";
    switch (channel) {
      case "hue":
        return isHSL ? color2.toFormat("hsla").getChannelValue("hue").toString() : color2.toFormat("hsba").getChannelValue("hue").toString();
      case "saturation":
        return isHSL ? color2.toFormat("hsla").getChannelValue("saturation").toString() : color2.toFormat("hsba").getChannelValue("saturation").toString();
      case "lightness":
        return color2.toFormat("hsla").getChannelValue("lightness").toString();
      case "brightness":
        return color2.toFormat("hsba").getChannelValue("brightness").toString();
      case "red":
      case "green":
      case "blue":
        return color2.toFormat("rgba").getChannelValue(channel).toString();
      default:
        return color2.getChannelValue(channel).toString();
    }
  }
  var parse = (colorString) => {
    return parseColor(colorString);
  };
  var HEX_REGEX = /^[0-9a-fA-F]{3,8}$/;
  function isValidHex(value) {
    return HEX_REGEX.test(value);
  }
  function prefixHex(value) {
    if (value.startsWith("#")) return value;
    if (isValidHex(value)) return `#${value}`;
    return value;
  }
  var { and: and$9 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        dir: "ltr",
        defaultValue: parse("#000000"),
        defaultFormat: "rgba",
        openAutoFocus: true,
        ...props2,
        positioning: {
          placement: "bottom",
          ...props2.positioning
        }
      };
    },
    initialState({ prop }) {
      const open = prop("open") || prop("defaultOpen") || prop("inline");
      return open ? "open" : "idle";
    },
    context({ prop, bindable, getContext }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          isEqual(a, b2) {
            return a.toString("css") === b2?.toString("css");
          },
          hash(a) {
            return a.toString("css");
          },
          onChange(value) {
            const ctx = getContext();
            const valueAsString = value.toString(ctx.get("format"));
            prop("onValueChange")?.({ value, valueAsString });
          }
        })),
        format: bindable(() => ({
          defaultValue: prop("defaultFormat"),
          value: prop("format"),
          onChange(format) {
            prop("onFormatChange")?.({ format });
          }
        })),
        activeId: bindable(() => ({ defaultValue: null })),
        activeChannel: bindable(() => ({ defaultValue: null })),
        activeOrientation: bindable(() => ({ defaultValue: null })),
        fieldsetDisabled: bindable(() => ({ defaultValue: false })),
        restoreFocus: bindable(() => ({ defaultValue: true })),
        currentPlacement: bindable(() => ({
          defaultValue: void 0
        }))
      };
    },
    computed: {
      rtl: ({ prop }) => prop("dir") === "rtl",
      disabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
      interactive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
      valueAsString: ({ context }) => context.get("value").toString(context.get("format")),
      areaValue: ({ context }) => {
        const format = context.get("format").startsWith("hsl") ? "hsla" : "hsba";
        return context.get("value").toFormat(format);
      }
    },
    effects: ["trackFormControl"],
    watch({ prop, context, action, track }) {
      track([() => context.hash("value")], () => {
        action(["syncInputElements", "dispatchChangeEvent"]);
      });
      track([() => context.get("format")], () => {
        action(["syncFormatSelectElement"]);
      });
      track([() => prop("open")], () => {
        action(["toggleVisibility"]);
      });
    },
    on: {
      "VALUE.SET": {
        actions: ["setValue"]
      },
      "FORMAT.SET": {
        actions: ["setFormat"]
      },
      "CHANNEL_INPUT.CHANGE": {
        actions: ["setChannelColorFromInput"]
      },
      "EYEDROPPER.CLICK": {
        actions: ["openEyeDropper"]
      },
      "SWATCH_TRIGGER.CLICK": {
        actions: ["setValue"]
      }
    },
    states: {
      idle: {
        tags: ["closed"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open",
            actions: ["setInitialFocus"]
          },
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen", "setInitialFocus"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen", "setInitialFocus"]
            }
          ],
          "CHANNEL_INPUT.FOCUS": {
            target: "focused",
            actions: ["setActiveChannel"]
          }
        }
      },
      focused: {
        tags: ["closed", "focused"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open",
            actions: ["setInitialFocus"]
          },
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen", "setInitialFocus"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen", "setInitialFocus"]
            }
          ],
          "CHANNEL_INPUT.FOCUS": {
            actions: ["setActiveChannel"]
          },
          "CHANNEL_INPUT.BLUR": {
            target: "idle",
            actions: ["setChannelColorFromInput"]
          },
          "TRIGGER.BLUR": {
            target: "idle"
          }
        }
      },
      open: {
        tags: ["open"],
        effects: ["trackPositioning", "trackDismissableElement"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              guard: "shouldRestoreFocus",
              target: "focused",
              actions: ["setReturnFocus"]
            },
            {
              target: "idle"
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          "AREA.POINTER_DOWN": {
            target: "open:dragging",
            actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
          },
          "AREA.FOCUS": {
            actions: ["setActiveChannel"]
          },
          "CHANNEL_SLIDER.POINTER_DOWN": {
            target: "open:dragging",
            actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
          },
          "CHANNEL_SLIDER.FOCUS": {
            actions: ["setActiveChannel"]
          },
          "AREA.ARROW_LEFT": {
            actions: ["decrementAreaXChannel"]
          },
          "AREA.ARROW_RIGHT": {
            actions: ["incrementAreaXChannel"]
          },
          "AREA.ARROW_UP": {
            actions: ["incrementAreaYChannel"]
          },
          "AREA.ARROW_DOWN": {
            actions: ["decrementAreaYChannel"]
          },
          "AREA.PAGE_UP": {
            actions: ["incrementAreaXChannel"]
          },
          "AREA.PAGE_DOWN": {
            actions: ["decrementAreaXChannel"]
          },
          "CHANNEL_SLIDER.ARROW_LEFT": {
            actions: ["decrementChannel"]
          },
          "CHANNEL_SLIDER.ARROW_RIGHT": {
            actions: ["incrementChannel"]
          },
          "CHANNEL_SLIDER.ARROW_UP": {
            actions: ["incrementChannel"]
          },
          "CHANNEL_SLIDER.ARROW_DOWN": {
            actions: ["decrementChannel"]
          },
          "CHANNEL_SLIDER.PAGE_UP": {
            actions: ["incrementChannel"]
          },
          "CHANNEL_SLIDER.PAGE_DOWN": {
            actions: ["decrementChannel"]
          },
          "CHANNEL_SLIDER.HOME": {
            actions: ["setChannelToMin"]
          },
          "CHANNEL_SLIDER.END": {
            actions: ["setChannelToMax"]
          },
          "CHANNEL_INPUT.BLUR": {
            actions: ["setChannelColorFromInput"]
          },
          INTERACT_OUTSIDE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              guard: "shouldRestoreFocus",
              target: "focused",
              actions: ["invokeOnClose", "setReturnFocus"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          "SWATCH_TRIGGER.CLICK": [
            {
              guard: and$9("isOpenControlled", "closeOnSelect"),
              actions: ["setValue", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["setValue", "invokeOnClose", "setReturnFocus"]
            },
            {
              actions: ["setValue"]
            }
          ]
        }
      },
      "open:dragging": {
        tags: ["open"],
        exit: ["clearActiveChannel"],
        effects: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              guard: "shouldRestoreFocus",
              target: "focused",
              actions: ["setReturnFocus"]
            },
            {
              target: "idle"
            }
          ],
          "AREA.POINTER_MOVE": {
            actions: ["setAreaColorFromPoint", "focusAreaThumb"]
          },
          "AREA.POINTER_UP": {
            target: "open",
            actions: ["invokeOnChangeEnd"]
          },
          "CHANNEL_SLIDER.POINTER_MOVE": {
            actions: ["setChannelColorFromPoint", "focusChannelThumb"]
          },
          "CHANNEL_SLIDER.POINTER_UP": {
            target: "open",
            actions: ["invokeOnChangeEnd"]
          },
          INTERACT_OUTSIDE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              guard: "shouldRestoreFocus",
              target: "focused",
              actions: ["invokeOnClose", "setReturnFocus"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ]
        }
      }
    },
    implementations: {
      guards: {
        closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
        isOpenControlled: ({ prop }) => prop("open") != null || !!prop("inline"),
        shouldRestoreFocus: ({ context }) => !!context.get("restoreFocus")
      },
      effects: {
        trackPositioning({ context, prop, scope }) {
          if (prop("inline")) return;
          if (!context.get("currentPlacement")) {
            context.set("currentPlacement", prop("positioning")?.placement);
          }
          const anchorEl = getTriggerEl$6(scope);
          const getPositionerEl2 = () => getPositionerEl$5(scope);
          return getPlacement(anchorEl, getPositionerEl2, {
            ...prop("positioning"),
            defer: true,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        trackDismissableElement({ context, scope, prop, send }) {
          if (prop("inline")) return;
          const getContentEl2 = () => getContentEl$7(scope);
          return trackDismissableElement(getContentEl2, {
            type: "popover",
            exclude: getTriggerEl$6(scope),
            defer: true,
            onInteractOutside(event) {
              prop("onInteractOutside")?.(event);
              if (event.defaultPrevented) return;
              context.set("restoreFocus", !(event.detail.focusable || event.detail.contextmenu));
            },
            onPointerDownOutside: prop("onPointerDownOutside"),
            onFocusOutside: prop("onFocusOutside"),
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        },
        trackFormControl({ context, scope, send }) {
          const inputEl = getHiddenInputEl$1(scope);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              context.set("fieldsetDisabled", disabled);
            },
            onFormReset() {
              send({ type: "VALUE.SET", value: context.initial("value"), src: "form.reset" });
            }
          });
        },
        trackPointerMove({ context, scope, event, send }) {
          return trackPointerMove(scope.getDoc(), {
            onPointerMove({ point }) {
              const type = context.get("activeId") === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
              send({ type, point, format: event.format });
            },
            onPointerUp() {
              const type = context.get("activeId") === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
              send({ type });
            }
          });
        },
        disableTextSelection({ scope }) {
          return disableTextSelection({
            doc: scope.getDoc(),
            target: getContentEl$7(scope)
          });
        }
      },
      actions: {
        openEyeDropper({ scope, context }) {
          const win = scope.getWin();
          const isSupported = "EyeDropper" in win;
          if (!isSupported) return;
          const picker = new win.EyeDropper();
          picker.open().then(({ sRGBHex }) => {
            const format = context.get("value").getFormat();
            const color2 = parseColor(sRGBHex).toFormat(format);
            context.set("value", color2);
          }).catch(() => void 0);
        },
        setActiveChannel({ context, event }) {
          context.set("activeId", event.id);
          if (event.channel) context.set("activeChannel", event.channel);
          if (event.orientation) context.set("activeOrientation", event.orientation);
        },
        clearActiveChannel({ context }) {
          context.set("activeChannel", null);
          context.set("activeId", null);
          context.set("activeOrientation", null);
        },
        setAreaColorFromPoint({ context, event, computed, scope, prop }) {
          const v = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
          const { xChannel, yChannel } = event.channel || context.get("activeChannel");
          const percent2 = getAreaValueFromPoint(scope, event.point, prop("dir"));
          if (!percent2) return;
          const xValue = v.getChannelPercentValue(xChannel, percent2.x);
          const yValue = v.getChannelPercentValue(yChannel, 1 - percent2.y);
          const color2 = v.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
          context.set("value", color2);
        },
        setChannelColorFromPoint({ context, event, computed, scope, prop }) {
          const channel = event.channel || context.get("activeId");
          const normalizedValue = event.format ? context.get("value").toFormat(event.format) : computed("areaValue");
          const percent2 = getChannelSliderValueFromPoint(scope, event.point, channel, prop("dir"));
          if (!percent2) return;
          const orientation = context.get("activeOrientation") || "horizontal";
          const channelPercent = orientation === "horizontal" ? percent2.x : percent2.y;
          const value = normalizedValue.getChannelPercentValue(channel, channelPercent);
          const color2 = normalizedValue.withChannelValue(channel, value);
          context.set("value", color2);
        },
        setValue({ context, event }) {
          context.set("value", event.value);
        },
        setFormat({ context, event }) {
          context.set("format", event.format);
        },
        dispatchChangeEvent({ scope, computed }) {
          dispatchInputValueEvent(getHiddenInputEl$1(scope), { value: computed("valueAsString") });
        },
        syncInputElements({ context, scope }) {
          syncChannelInputs(scope, context.get("value"));
        },
        invokeOnChangeEnd({ context, prop, computed }) {
          prop("onValueChangeEnd")?.({
            value: context.get("value"),
            valueAsString: computed("valueAsString")
          });
        },
        setChannelColorFromInput({ context, event, scope, prop }) {
          const { channel, isTextField, value } = event;
          const currentAlpha = context.get("value").getChannelValue("alpha");
          let color2;
          if (channel === "alpha") {
            let valueAsNumber = parseFloat(value);
            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
            color2 = context.get("value").withChannelValue("alpha", valueAsNumber);
          } else if (isTextField) {
            color2 = tryCatch(
              () => {
                const parseValue2 = channel === "hex" ? prefixHex(value) : value;
                return parse(parseValue2).withChannelValue("alpha", currentAlpha);
              },
              () => context.get("value")
            );
          } else {
            const current = context.get("value").toFormat(context.get("format"));
            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
            color2 = current.withChannelValue(channel, valueAsNumber);
          }
          syncChannelInputs(scope, context.get("value"), color2);
          context.set("value", color2);
          prop("onValueChangeEnd")?.({
            value: color2,
            valueAsString: color2.toString(context.get("format"))
          });
        },
        incrementChannel({ context, event }) {
          const color2 = context.get("value").incrementChannel(event.channel, event.step);
          context.set("value", color2);
        },
        decrementChannel({ context, event }) {
          const color2 = context.get("value").decrementChannel(event.channel, event.step);
          context.set("value", color2);
        },
        incrementAreaXChannel({ context, event, computed }) {
          const { xChannel } = event.channel;
          const color2 = computed("areaValue").incrementChannel(xChannel, event.step);
          context.set("value", color2);
        },
        decrementAreaXChannel({ context, event, computed }) {
          const { xChannel } = event.channel;
          const color2 = computed("areaValue").decrementChannel(xChannel, event.step);
          context.set("value", color2);
        },
        incrementAreaYChannel({ context, event, computed }) {
          const { yChannel } = event.channel;
          const color2 = computed("areaValue").incrementChannel(yChannel, event.step);
          context.set("value", color2);
        },
        decrementAreaYChannel({ context, event, computed }) {
          const { yChannel } = event.channel;
          const color2 = computed("areaValue").decrementChannel(yChannel, event.step);
          context.set("value", color2);
        },
        setChannelToMax({ context, event }) {
          const value = context.get("value");
          const range = value.getChannelRange(event.channel);
          const color2 = value.withChannelValue(event.channel, range.maxValue);
          context.set("value", color2);
        },
        setChannelToMin({ context, event }) {
          const value = context.get("value");
          const range = value.getChannelRange(event.channel);
          const color2 = value.withChannelValue(event.channel, range.minValue);
          context.set("value", color2);
        },
        focusAreaThumb({ scope }) {
          raf(() => {
            getAreaThumbEl(scope)?.focus({ preventScroll: true });
          });
        },
        focusChannelThumb({ event, scope }) {
          raf(() => {
            getChannelSliderThumbEl(scope, event.channel)?.focus({ preventScroll: true });
          });
        },
        setInitialFocus({ prop, scope }) {
          if (!prop("openAutoFocus")) return;
          raf(() => {
            const element = getInitialFocus({
              root: getContentEl$7(scope),
              getInitialEl: prop("initialFocusEl")
            });
            element?.focus({ preventScroll: true });
          });
        },
        setReturnFocus({ scope }) {
          raf(() => {
            getTriggerEl$6(scope)?.focus({ preventScroll: true });
          });
        },
        syncFormatSelectElement({ context, scope }) {
          syncFormatSelect(scope, context.get("format"));
        },
        invokeOnOpen({ prop, context }) {
          if (prop("inline")) return;
          prop("onOpenChange")?.({ open: true, value: context.get("value") });
        },
        invokeOnClose({ prop, context }) {
          if (prop("inline")) return;
          prop("onOpenChange")?.({ open: false, value: context.get("value") });
        },
        toggleVisibility({ prop, event, send }) {
          send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
        }
      }
    }
  });
  function syncChannelInputs(scope, currentValue, nextValue) {
    const channelInputEls = getChannelInputEls(scope);
    raf(() => {
      channelInputEls.forEach((inputEl) => {
        const channel = inputEl.dataset.channel;
        setElementValue(inputEl, getChannelValue(nextValue || currentValue, channel));
      });
    });
  }
  function syncFormatSelect(scope, format) {
    const selectEl = getFormatSelectEl(scope);
    if (!selectEl) return;
    raf(() => setElementValue(selectEl, format));
  }
  createProps$1()([
    "closeOnSelect",
    "dir",
    "disabled",
    "format",
    "defaultFormat",
    "getRootNode",
    "id",
    "ids",
    "initialFocusEl",
    "inline",
    "name",
    "positioning",
    "onFocusOutside",
    "onFormatChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "onValueChangeEnd",
    "defaultOpen",
    "open",
    "positioning",
    "required",
    "readOnly",
    "value",
    "defaultValue",
    "invalid",
    "openAutoFocus"
  ]);
  createProps$1()(["xChannel", "yChannel"]);
  createProps$1()(["channel", "orientation"]);
  createProps$1()(["value", "disabled"]);
  createProps$1()(["value", "respectAlpha"]);
  createProps$1()(["size"]);
  var ID = "__live-region__";
  function createLiveRegion(opts = {}) {
    const { level = "polite", document: doc = document, root: root2, delay: _delay = 0 } = opts;
    const win = doc.defaultView ?? window;
    const parent = root2 ?? doc.body;
    function announce(message, delay2) {
      const oldRegion = doc.getElementById(ID);
      oldRegion?.remove();
      delay2 = delay2 ?? _delay;
      const region = doc.createElement("span");
      region.id = ID;
      region.dataset.liveAnnouncer = "true";
      const role = level !== "assertive" ? "status" : "alert";
      region.setAttribute("aria-live", level);
      region.setAttribute("role", role);
      Object.assign(region.style, {
        border: "0",
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: "0",
        position: "absolute",
        width: "1px",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      });
      parent.appendChild(region);
      win.setTimeout(() => {
        region.textContent = message;
      }, delay2);
    }
    function destroy() {
      const oldRegion = doc.getElementById(ID);
      oldRegion?.remove();
    }
    return {
      announce,
      destroy,
      toJSON() {
        return ID;
      }
    };
  }
  var anatomy$r = createAnatomy("splitter").parts("root", "panel", "resizeTrigger", "resizeTriggerIndicator");
  anatomy$r.build();
  createProps$1()([
    "dir",
    "getRootNode",
    "id",
    "ids",
    "onResize",
    "onResizeStart",
    "onResizeEnd",
    "onCollapse",
    "onExpand",
    "orientation",
    "size",
    "defaultSize",
    "panels",
    "keyboardResizeBy",
    "nonce"
  ]);
  createProps$1()(["id"]);
  createProps$1()(["disabled", "id"]);
  const [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
    name: "RenderStrategyContext",
    hookName: "useRenderStrategyContext",
    providerName: "<RenderStrategyPropsProvider />"
  });
  const splitRenderStrategyProps = (props) => createSplitProps()(props, ["lazyMount", "unmountOnExit"]);
  var anatomy$q = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
  anatomy$q.build();
  var getRootId$3 = (ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`;
  var getItemTriggerId = (ctx, value) => ctx.ids?.itemTrigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`;
  var getRootEl$2 = (ctx) => ctx.getById(getRootId$3(ctx));
  var getTriggerEls = (ctx) => {
    const ownerId = CSS.escape(getRootId$3(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(getRootEl$2(ctx), selector);
  };
  var getFirstTriggerEl$1 = (ctx) => first(getTriggerEls(ctx));
  var getLastTriggerEl$1 = (ctx) => last(getTriggerEls(ctx));
  var getNextTriggerEl$1 = (ctx, id2) => nextById(getTriggerEls(ctx), getItemTriggerId(ctx, id2));
  var getPrevTriggerEl$1 = (ctx, id2) => prevById(getTriggerEls(ctx), getItemTriggerId(ctx, id2));
  var { and: and$8, not: not$7 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        defaultValue: [],
        ...props2
      };
    },
    initialState() {
      return "idle";
    },
    context({ prop, bindable }) {
      return {
        focusedValue: bindable(() => ({
          defaultValue: null,
          sync: true,
          onChange(value) {
            prop("onFocusChange")?.({ value });
          }
        })),
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          onChange(value) {
            prop("onValueChange")?.({ value });
          }
        }))
      };
    },
    computed: {
      isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
    },
    on: {
      "VALUE.SET": {
        actions: ["setValue"]
      }
    },
    states: {
      idle: {
        on: {
          "TRIGGER.FOCUS": {
            target: "focused",
            actions: ["setFocusedValue"]
          }
        }
      },
      focused: {
        on: {
          "GOTO.NEXT": {
            actions: ["focusNextTrigger"]
          },
          "GOTO.PREV": {
            actions: ["focusPrevTrigger"]
          },
          "TRIGGER.CLICK": [
            {
              guard: and$8("isExpanded", "canToggle"),
              actions: ["collapse"]
            },
            {
              guard: not$7("isExpanded"),
              actions: ["expand"]
            }
          ],
          "GOTO.FIRST": {
            actions: ["focusFirstTrigger"]
          },
          "GOTO.LAST": {
            actions: ["focusLastTrigger"]
          },
          "TRIGGER.BLUR": {
            target: "idle",
            actions: ["clearFocusedValue"]
          }
        }
      }
    },
    implementations: {
      guards: {
        canToggle: ({ prop }) => !!prop("collapsible") || !!prop("multiple"),
        isExpanded: ({ context, event }) => context.get("value").includes(event.value)
      },
      actions: {
        collapse({ context, prop, event }) {
          const next2 = prop("multiple") ? remove$1(context.get("value"), event.value) : [];
          context.set("value", next2);
        },
        expand({ context, prop, event }) {
          const next2 = prop("multiple") ? add$1(context.get("value"), event.value) : [event.value];
          context.set("value", next2);
        },
        focusFirstTrigger({ scope }) {
          getFirstTriggerEl$1(scope)?.focus();
        },
        focusLastTrigger({ scope }) {
          getLastTriggerEl$1(scope)?.focus();
        },
        focusNextTrigger({ context, scope }) {
          const focusedValue = context.get("focusedValue");
          if (!focusedValue) return;
          const triggerEl = getNextTriggerEl$1(scope, focusedValue);
          triggerEl?.focus();
        },
        focusPrevTrigger({ context, scope }) {
          const focusedValue = context.get("focusedValue");
          if (!focusedValue) return;
          const triggerEl = getPrevTriggerEl$1(scope, focusedValue);
          triggerEl?.focus();
        },
        setFocusedValue({ context, event }) {
          context.set("focusedValue", event.value);
        },
        clearFocusedValue({ context }) {
          context.set("focusedValue", null);
        },
        setValue({ context, event }) {
          context.set("value", event.value);
        },
        coarseValue({ context, prop }) {
          if (!prop("multiple") && context.get("value").length > 1) {
            warn(`The value of accordion should be a single value when multiple is false.`);
            context.set("value", [context.get("value")[0]]);
          }
        }
      }
    }
  });
  createProps$1()([
    "collapsible",
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value",
    "defaultValue"
  ]);
  createProps$1()(["value", "disabled"]);
  var createPoint = (x2, y) => ({ x: x2, y });
  function createRect(r) {
    const { x: x2, y, width, height } = r;
    const midX = x2 + width / 2;
    const midY = y + height / 2;
    return {
      x: x2,
      y,
      width,
      height,
      minX: x2,
      minY: y,
      maxX: x2 + width,
      maxY: y + height,
      midX,
      midY,
      center: createPoint(midX, midY)
    };
  }
  function getRectCorners(v) {
    const top = createPoint(v.minX, v.minY);
    const right = createPoint(v.maxX, v.minY);
    const bottom = createPoint(v.maxX, v.maxY);
    const left = createPoint(v.minX, v.maxY);
    return { top, right, bottom, left };
  }
  function getElementPolygon(rectValue, placement) {
    const rect = createRect(rectValue);
    const { top, right, left, bottom } = getRectCorners(rect);
    const [base] = placement.split("-");
    return {
      top: [left, top, right, bottom],
      right: [top, right, bottom, left],
      bottom: [top, left, bottom, right],
      left: [right, top, left, bottom]
    }[base];
  }
  function isPointInPolygon(polygon, point) {
    const { x: x2, y } = point;
    let c = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i].x;
      const yi = polygon[i].y;
      const xj = polygon[j].x;
      const yj = polygon[j].y;
      if (yi > y !== yj > y && x2 < (xj - xi) * (y - yi) / (yj - yi) + xi) {
        c = !c;
      }
    }
    return c;
  }
  var anatomy$p = createAnatomy("avatar").parts("root", "image", "fallback");
  anatomy$p.build();
  createProps$1()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
  var anatomy$o = createAnatomy("carousel").parts(
    "root",
    "itemGroup",
    "item",
    "control",
    "nextTrigger",
    "prevTrigger",
    "indicatorGroup",
    "indicator",
    "autoplayTrigger",
    "progressText"
  );
  anatomy$o.build();
  createProps$1()([
    "dir",
    "getRootNode",
    "id",
    "ids",
    "loop",
    "page",
    "defaultPage",
    "onPageChange",
    "orientation",
    "slideCount",
    "slidesPerPage",
    "slidesPerMove",
    "spacing",
    "padding",
    "autoplay",
    "allowMouseDrag",
    "inViewThreshold",
    "translations",
    "snapType",
    "autoSize",
    "onDragStatusChange",
    "onAutoplayStatusChange"
  ]);
  createProps$1()(["index", "readOnly"]);
  createProps$1()(["index", "snapAlign"]);
  const carouselAnatomy = anatomy$o.extendWith("progressText", "autoplayIndicator");
  function isValidKey(e) {
    return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
  }
  var nonTextInputTypes = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
  function isKeyboardFocusEvent(isTextInput, modality, e) {
    const target = e ? getEventTarget(e) : null;
    const win = getWindow$1(target);
    isTextInput = isTextInput || target instanceof win.HTMLInputElement && !nonTextInputTypes.has(target?.type) || target instanceof win.HTMLTextAreaElement || target instanceof win.HTMLElement && target.isContentEditable;
    return !(isTextInput && modality === "keyboard" && e instanceof win.KeyboardEvent && !Reflect.has(FOCUS_VISIBLE_INPUT_KEYS, e.key));
  }
  var currentModality = null;
  var changeHandlers = new Set();
  var listenerMap = new Map();
  var hasEventBeforeFocus = false;
  var hasBlurredWindowRecently = false;
  var FOCUS_VISIBLE_INPUT_KEYS = {
    Tab: true,
    Escape: true
  };
  function triggerChangeHandlers(modality, e) {
    for (let handler of changeHandlers) {
      handler(modality, e);
    }
  }
  function handleKeyboardEvent(e) {
    hasEventBeforeFocus = true;
    if (isValidKey(e)) {
      currentModality = "keyboard";
      triggerChangeHandlers("keyboard", e);
    }
  }
  function handlePointerEvent(e) {
    currentModality = "pointer";
    if (e.type === "mousedown" || e.type === "pointerdown") {
      hasEventBeforeFocus = true;
      triggerChangeHandlers("pointer", e);
    }
  }
  function handleClickEvent(e) {
    if (isVirtualClick(e)) {
      hasEventBeforeFocus = true;
      currentModality = "virtual";
    }
  }
  function handleFocusEvent(e) {
    const target = getEventTarget(e);
    if (target === getWindow$1(target) || target === getDocument(target)) {
      return;
    }
    if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
      currentModality = "virtual";
      triggerChangeHandlers("virtual", e);
    }
    hasEventBeforeFocus = false;
    hasBlurredWindowRecently = false;
  }
  function handleWindowBlur() {
    hasEventBeforeFocus = false;
    hasBlurredWindowRecently = true;
  }
  function setupGlobalFocusEvents(root2) {
    if (typeof window === "undefined" || listenerMap.get(getWindow$1(root2))) {
      return;
    }
    const win = getWindow$1(root2);
    const doc = getDocument(root2);
    let focus = win.HTMLElement.prototype.focus;
    function patchedFocus() {
      currentModality = "virtual";
      triggerChangeHandlers("virtual", null);
      hasEventBeforeFocus = true;
      focus.apply(this, arguments);
    }
    try {
      Object.defineProperty(win.HTMLElement.prototype, "focus", {
        configurable: true,
        value: patchedFocus
      });
    } catch {
    }
    doc.addEventListener("keydown", handleKeyboardEvent, true);
    doc.addEventListener("keyup", handleKeyboardEvent, true);
    doc.addEventListener("click", handleClickEvent, true);
    win.addEventListener("focus", handleFocusEvent, true);
    win.addEventListener("blur", handleWindowBlur, false);
    if (typeof win.PointerEvent !== "undefined") {
      doc.addEventListener("pointerdown", handlePointerEvent, true);
      doc.addEventListener("pointermove", handlePointerEvent, true);
      doc.addEventListener("pointerup", handlePointerEvent, true);
    } else {
      doc.addEventListener("mousedown", handlePointerEvent, true);
      doc.addEventListener("mousemove", handlePointerEvent, true);
      doc.addEventListener("mouseup", handlePointerEvent, true);
    }
    win.addEventListener(
      "beforeunload",
      () => {
        tearDownWindowFocusTracking(root2);
      },
      { once: true }
    );
    listenerMap.set(win, { focus });
  }
  var tearDownWindowFocusTracking = (root2, loadListener) => {
    const win = getWindow$1(root2);
    const doc = getDocument(root2);
    const listenerData = listenerMap.get(win);
    if (!listenerData) {
      return;
    }
    try {
      Object.defineProperty(win.HTMLElement.prototype, "focus", {
        configurable: true,
        value: listenerData.focus
      });
    } catch {
    }
    doc.removeEventListener("keydown", handleKeyboardEvent, true);
    doc.removeEventListener("keyup", handleKeyboardEvent, true);
    doc.removeEventListener("click", handleClickEvent, true);
    win.removeEventListener("focus", handleFocusEvent, true);
    win.removeEventListener("blur", handleWindowBlur, false);
    if (typeof win.PointerEvent !== "undefined") {
      doc.removeEventListener("pointerdown", handlePointerEvent, true);
      doc.removeEventListener("pointermove", handlePointerEvent, true);
      doc.removeEventListener("pointerup", handlePointerEvent, true);
    } else {
      doc.removeEventListener("mousedown", handlePointerEvent, true);
      doc.removeEventListener("mousemove", handlePointerEvent, true);
      doc.removeEventListener("mouseup", handlePointerEvent, true);
    }
    listenerMap.delete(win);
  };
  function getInteractionModality() {
    return currentModality;
  }
  function isFocusVisible() {
    return currentModality === "keyboard";
  }
  function trackFocusVisible(props = {}) {
    const { isTextInput, autoFocus, onChange, root: root2 } = props;
    setupGlobalFocusEvents(root2);
    onChange?.({ isFocusVisible: autoFocus || isFocusVisible(), modality: currentModality });
    const handler = (modality, e) => {
      if (!isKeyboardFocusEvent(!!isTextInput, modality, e)) return;
      onChange?.({ isFocusVisible: isFocusVisible(), modality });
    };
    changeHandlers.add(handler);
    return () => {
      changeHandlers.delete(handler);
    };
  }
  var anatomy$n = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
  anatomy$n.build();
  createProps$1()([
    "defaultChecked",
    "checked",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkboxAnatomy = anatomy$n.extendWith("group");
  var anatomy$m = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
  anatomy$m.build();
  createProps$1()([
    "getRootNode",
    "id",
    "ids",
    "value",
    "defaultValue",
    "timeout",
    "onStatusChange",
    "onValueChange"
  ]);
  createProps$1()(["copied"]);
  const colorPickerAnatomy$1 = anatomy$s.extendWith("view");
  var __defProp$2 = Object.defineProperty;
  var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  var fallback$1 = {
    itemToValue(item) {
      if (typeof item === "string") return item;
      if (isObject$2(item) && hasProp(item, "value")) return item.value;
      return "";
    },
    itemToString(item) {
      if (typeof item === "string") return item;
      if (isObject$2(item) && hasProp(item, "label")) return item.label;
      return fallback$1.itemToValue(item);
    },
    isItemDisabled(item) {
      if (isObject$2(item) && hasProp(item, "disabled")) return !!item.disabled;
      return false;
    }
  };
  var ListCollection = class _ListCollection {
    constructor(options) {
      this.options = options;
      __publicField$2(this, "items");
      __publicField$2(this, "indexMap", null);
      __publicField$2(this, "copy", (items) => {
        return new _ListCollection({ ...this.options, items: items ?? [...this.items] });
      });
      __publicField$2(this, "isEqual", (other) => {
        return isEqual(this.items, other.items);
      });
      __publicField$2(this, "setItems", (items) => {
        return this.copy(items);
      });
      __publicField$2(this, "getValues", (items = this.items) => {
        const values = [];
        for (const item of items) {
          const value = this.getItemValue(item);
          if (value != null) values.push(value);
        }
        return values;
      });
      __publicField$2(this, "find", (value) => {
        if (value == null) return null;
        const index = this.indexOf(value);
        return index !== -1 ? this.at(index) : null;
      });
      __publicField$2(this, "findMany", (values) => {
        const result = [];
        for (const value of values) {
          const item = this.find(value);
          if (item != null) result.push(item);
        }
        return result;
      });
      __publicField$2(this, "at", (index) => {
        if (!this.options.groupBy && !this.options.groupSort) {
          return this.items[index] ?? null;
        }
        let idx = 0;
        const groups = this.group();
        for (const [, items] of groups) {
          for (const item of items) {
            if (idx === index) return item;
            idx++;
          }
        }
        return null;
      });
      __publicField$2(this, "sortFn", (valueA, valueB) => {
        const indexA = this.indexOf(valueA);
        const indexB = this.indexOf(valueB);
        return (indexA ?? 0) - (indexB ?? 0);
      });
      __publicField$2(this, "sort", (values) => {
        return [...values].sort(this.sortFn.bind(this));
      });
      __publicField$2(this, "getItemValue", (item) => {
        if (item == null) return null;
        return this.options.itemToValue?.(item) ?? fallback$1.itemToValue(item);
      });
      __publicField$2(this, "getItemDisabled", (item) => {
        if (item == null) return false;
        return this.options.isItemDisabled?.(item) ?? fallback$1.isItemDisabled(item);
      });
      __publicField$2(this, "stringifyItem", (item) => {
        if (item == null) return null;
        return this.options.itemToString?.(item) ?? fallback$1.itemToString(item);
      });
      __publicField$2(this, "stringify", (value) => {
        if (value == null) return null;
        return this.stringifyItem(this.find(value));
      });
      __publicField$2(this, "stringifyItems", (items, separator = ", ") => {
        const strs = [];
        for (const item of items) {
          const str = this.stringifyItem(item);
          if (str != null) strs.push(str);
        }
        return strs.join(separator);
      });
      __publicField$2(this, "stringifyMany", (value, separator) => {
        return this.stringifyItems(this.findMany(value), separator);
      });
      __publicField$2(this, "has", (value) => {
        return this.indexOf(value) !== -1;
      });
      __publicField$2(this, "hasItem", (item) => {
        if (item == null) return false;
        return this.has(this.getItemValue(item));
      });
      __publicField$2(this, "group", () => {
        const { groupBy, groupSort } = this.options;
        if (!groupBy) return [["", [...this.items]]];
        const groups = new Map();
        this.items.forEach((item, index) => {
          const groupKey = groupBy(item, index);
          if (!groups.has(groupKey)) {
            groups.set(groupKey, []);
          }
          groups.get(groupKey).push(item);
        });
        let entries = Array.from(groups.entries());
        if (groupSort) {
          entries.sort(([a], [b2]) => {
            if (typeof groupSort === "function") return groupSort(a, b2);
            if (Array.isArray(groupSort)) {
              const indexA = groupSort.indexOf(a);
              const indexB = groupSort.indexOf(b2);
              if (indexA === -1) return 1;
              if (indexB === -1) return -1;
              return indexA - indexB;
            }
            if (groupSort === "asc") return a.localeCompare(b2);
            if (groupSort === "desc") return b2.localeCompare(a);
            return 0;
          });
        }
        return entries;
      });
      __publicField$2(this, "getNextValue", (value, step = 1, clamp2 = false) => {
        let index = this.indexOf(value);
        if (index === -1) return null;
        index = clamp2 ? Math.min(index + step, this.size - 1) : index + step;
        while (index <= this.size && this.getItemDisabled(this.at(index))) index++;
        return this.getItemValue(this.at(index));
      });
      __publicField$2(this, "getPreviousValue", (value, step = 1, clamp2 = false) => {
        let index = this.indexOf(value);
        if (index === -1) return null;
        index = clamp2 ? Math.max(index - step, 0) : index - step;
        while (index >= 0 && this.getItemDisabled(this.at(index))) index--;
        return this.getItemValue(this.at(index));
      });
      __publicField$2(this, "indexOf", (value) => {
        if (value == null) return -1;
        if (!this.options.groupBy && !this.options.groupSort) {
          return this.items.findIndex((item) => this.getItemValue(item) === value);
        }
        if (!this.indexMap) {
          this.indexMap = new Map();
          let idx = 0;
          const groups = this.group();
          for (const [, items] of groups) {
            for (const item of items) {
              const itemValue = this.getItemValue(item);
              if (itemValue != null) {
                this.indexMap.set(itemValue, idx);
              }
              idx++;
            }
          }
        }
        return this.indexMap.get(value) ?? -1;
      });
      __publicField$2(this, "getByText", (text, current) => {
        const currentIndex = current != null ? this.indexOf(current) : -1;
        const isSingleKey = text.length === 1;
        for (let i = 0; i < this.items.length; i++) {
          const item = this.items[(currentIndex + i + 1) % this.items.length];
          if (isSingleKey && this.getItemValue(item) === current) continue;
          if (this.getItemDisabled(item)) continue;
          if (match(this.stringifyItem(item), text)) return item;
        }
        return void 0;
      });
      __publicField$2(this, "search", (queryString, options2) => {
        const { state: state2, currentValue, timeout = 350 } = options2;
        const search = state2.keysSoFar + queryString;
        const isRepeated = search.length > 1 && Array.from(search).every((char2) => char2 === search[0]);
        const query2 = isRepeated ? search[0] : search;
        const item = this.getByText(query2, currentValue);
        const value = this.getItemValue(item);
        function cleanup() {
          clearTimeout(state2.timer);
          state2.timer = -1;
        }
        function update(value2) {
          state2.keysSoFar = value2;
          cleanup();
          if (value2 !== "") {
            state2.timer = +setTimeout(() => {
              update("");
              cleanup();
            }, timeout);
          }
        }
        update(search);
        return value;
      });
      __publicField$2(this, "update", (value, item) => {
        let index = this.indexOf(value);
        if (index === -1) return this;
        return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
      });
      __publicField$2(this, "upsert", (value, item, mode = "append") => {
        let index = this.indexOf(value);
        if (index === -1) {
          const fn = mode === "append" ? this.append : this.prepend;
          return fn(item);
        }
        return this.copy([...this.items.slice(0, index), item, ...this.items.slice(index + 1)]);
      });
      __publicField$2(this, "insert", (index, ...items) => {
        return this.copy(insert(this.items, index, ...items));
      });
      __publicField$2(this, "insertBefore", (value, ...items) => {
        let toIndex = this.indexOf(value);
        if (toIndex === -1) {
          if (this.items.length === 0) toIndex = 0;
          else return this;
        }
        return this.copy(insert(this.items, toIndex, ...items));
      });
      __publicField$2(this, "insertAfter", (value, ...items) => {
        let toIndex = this.indexOf(value);
        if (toIndex === -1) {
          if (this.items.length === 0) toIndex = 0;
          else return this;
        }
        return this.copy(insert(this.items, toIndex + 1, ...items));
      });
      __publicField$2(this, "prepend", (...items) => {
        return this.copy(insert(this.items, 0, ...items));
      });
      __publicField$2(this, "append", (...items) => {
        return this.copy(insert(this.items, this.items.length, ...items));
      });
      __publicField$2(this, "filter", (fn) => {
        const filteredItems = this.items.filter((item, index) => fn(this.stringifyItem(item), index, item));
        return this.copy(filteredItems);
      });
      __publicField$2(this, "remove", (...itemsOrValues) => {
        const values = itemsOrValues.map(
          (itemOrValue) => typeof itemOrValue === "string" ? itemOrValue : this.getItemValue(itemOrValue)
        );
        return this.copy(
          this.items.filter((item) => {
            const value = this.getItemValue(item);
            if (value == null) return false;
            return !values.includes(value);
          })
        );
      });
      __publicField$2(this, "move", (value, toIndex) => {
        const fromIndex = this.indexOf(value);
        if (fromIndex === -1) return this;
        return this.copy(move(this.items, [fromIndex], toIndex));
      });
      __publicField$2(this, "moveBefore", (value, ...values) => {
        let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
        if (toIndex === -1) return this;
        let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b2) => a - b2);
        return this.copy(move(this.items, indices, toIndex));
      });
      __publicField$2(this, "moveAfter", (value, ...values) => {
        let toIndex = this.items.findIndex((item) => this.getItemValue(item) === value);
        if (toIndex === -1) return this;
        let indices = values.map((value2) => this.items.findIndex((item) => this.getItemValue(item) === value2)).sort((a, b2) => a - b2);
        return this.copy(move(this.items, indices, toIndex + 1));
      });
      __publicField$2(this, "reorder", (fromIndex, toIndex) => {
        return this.copy(move(this.items, [fromIndex], toIndex));
      });
      __publicField$2(this, "compareValue", (a, b2) => {
        const indexA = this.indexOf(a);
        const indexB = this.indexOf(b2);
        if (indexA < indexB) return -1;
        if (indexA > indexB) return 1;
        return 0;
      });
      __publicField$2(this, "range", (from2, to) => {
        let keys = [];
        let key = from2;
        while (key != null) {
          let item = this.find(key);
          if (item) keys.push(key);
          if (key === to) return keys;
          key = this.getNextValue(key);
        }
        return [];
      });
      __publicField$2(this, "getValueRange", (from2, to) => {
        if (from2 && to) {
          if (this.compareValue(from2, to) <= 0) {
            return this.range(from2, to);
          }
          return this.range(to, from2);
        }
        return [];
      });
      __publicField$2(this, "toString", () => {
        let result = "";
        for (const item of this.items) {
          const value = this.getItemValue(item);
          const label = this.stringifyItem(item);
          const disabled = this.getItemDisabled(item);
          const itemString = [value, label, disabled].filter(Boolean).join(":");
          result += itemString + ",";
        }
        return result;
      });
      __publicField$2(this, "toJSON", () => {
        return {
          size: this.size,
          first: this.firstValue,
          last: this.lastValue
        };
      });
      this.items = [...options.items];
    }
get size() {
      return this.items.length;
    }
get firstValue() {
      let index = 0;
      while (this.getItemDisabled(this.at(index))) index++;
      return this.getItemValue(this.at(index));
    }
get lastValue() {
      let index = this.size - 1;
      while (this.getItemDisabled(this.at(index))) index--;
      return this.getItemValue(this.at(index));
    }
    *[Symbol.iterator]() {
      yield* this.items;
    }
  };
  var match = (label, query2) => {
    return !!label?.toLowerCase().startsWith(query2.toLowerCase());
  };
  function insert(items, index, ...values) {
    return [...items.slice(0, index), ...values, ...items.slice(index)];
  }
  function move(items, indices, toIndex) {
    indices = [...indices].sort((a, b2) => a - b2);
    const itemsToMove = indices.map((i) => items[i]);
    for (let i = indices.length - 1; i >= 0; i--) {
      items = [...items.slice(0, indices[i]), ...items.slice(indices[i] + 1)];
    }
    toIndex = Math.max(0, toIndex - indices.filter((i) => i < toIndex).length);
    return [...items.slice(0, toIndex), ...itemsToMove, ...items.slice(toIndex)];
  }
  var Selection = class _Selection extends Set {
    constructor(values = []) {
      super(values);
      __publicField$2(this, "selectionMode", "single");
      __publicField$2(this, "deselectable", true);
      __publicField$2(this, "copy", () => {
        const clone2 = new _Selection([...this]);
        return this.sync(clone2);
      });
      __publicField$2(this, "sync", (other) => {
        other.selectionMode = this.selectionMode;
        other.deselectable = this.deselectable;
        return other;
      });
      __publicField$2(this, "isEmpty", () => {
        return this.size === 0;
      });
      __publicField$2(this, "isSelected", (value) => {
        if (this.selectionMode === "none" || value == null) {
          return false;
        }
        return this.has(value);
      });
      __publicField$2(this, "canSelect", (collection2, value) => {
        return this.selectionMode !== "none" || !collection2.getItemDisabled(collection2.find(value));
      });
      __publicField$2(this, "firstSelectedValue", (collection2) => {
        let firstValue = null;
        for (let value of this) {
          if (!firstValue || collection2.compareValue(value, firstValue) < 0) {
            firstValue = value;
          }
        }
        return firstValue;
      });
      __publicField$2(this, "lastSelectedValue", (collection2) => {
        let lastValue = null;
        for (let value of this) {
          if (!lastValue || collection2.compareValue(value, lastValue) > 0) {
            lastValue = value;
          }
        }
        return lastValue;
      });
      __publicField$2(this, "extendSelection", (collection2, anchorValue, targetValue) => {
        if (this.selectionMode === "none") {
          return this;
        }
        if (this.selectionMode === "single") {
          return this.replaceSelection(collection2, targetValue);
        }
        const selection = this.copy();
        const lastSelected = Array.from(this).pop();
        for (let key of collection2.getValueRange(anchorValue, lastSelected ?? targetValue)) {
          selection.delete(key);
        }
        for (let key of collection2.getValueRange(targetValue, anchorValue)) {
          if (this.canSelect(collection2, key)) {
            selection.add(key);
          }
        }
        return selection;
      });
      __publicField$2(this, "toggleSelection", (collection2, value) => {
        if (this.selectionMode === "none") {
          return this;
        }
        if (this.selectionMode === "single" && !this.isSelected(value)) {
          return this.replaceSelection(collection2, value);
        }
        const selection = this.copy();
        if (selection.has(value)) {
          selection.delete(value);
        } else if (selection.canSelect(collection2, value)) {
          selection.add(value);
        }
        return selection;
      });
      __publicField$2(this, "replaceSelection", (collection2, value) => {
        if (this.selectionMode === "none") {
          return this;
        }
        if (value == null) {
          return this;
        }
        if (!this.canSelect(collection2, value)) {
          return this;
        }
        const selection = new _Selection([value]);
        return this.sync(selection);
      });
      __publicField$2(this, "setSelection", (values2) => {
        if (this.selectionMode === "none") {
          return this;
        }
        let selection = new _Selection();
        for (let value of values2) {
          if (value != null) {
            selection.add(value);
            if (this.selectionMode === "single") {
              break;
            }
          }
        }
        return this.sync(selection);
      });
      __publicField$2(this, "clearSelection", () => {
        const selection = this.copy();
        if (selection.deselectable && selection.size > 0) {
          selection.clear();
        }
        return selection;
      });
      __publicField$2(this, "select", (collection2, value, forceToggle) => {
        if (this.selectionMode === "none") {
          return this;
        }
        if (this.selectionMode === "single") {
          if (this.isSelected(value) && this.deselectable) {
            return this.toggleSelection(collection2, value);
          } else {
            return this.replaceSelection(collection2, value);
          }
        } else if (this.selectionMode === "multiple" || forceToggle) {
          return this.toggleSelection(collection2, value);
        } else {
          return this.replaceSelection(collection2, value);
        }
      });
      __publicField$2(this, "deselect", (value) => {
        const selection = this.copy();
        selection.delete(value);
        return selection;
      });
      __publicField$2(this, "isEqual", (other) => {
        return isEqual(Array.from(this), Array.from(other));
      });
    }
  };
  function access(node2, indexPath, options) {
    for (let i = 0; i < indexPath.length; i++) node2 = options.getChildren(node2, indexPath.slice(i + 1))[indexPath[i]];
    return node2;
  }
  function ancestorIndexPaths(indexPaths) {
    const sortedPaths = sortIndexPaths(indexPaths);
    const result = [];
    const seen = new Set();
    for (const indexPath of sortedPaths) {
      const key = indexPath.join();
      if (!seen.has(key)) {
        seen.add(key);
        result.push(indexPath);
      }
    }
    return result;
  }
  function compareIndexPaths(a, b2) {
    for (let i = 0; i < Math.min(a.length, b2.length); i++) {
      if (a[i] < b2[i]) return -1;
      if (a[i] > b2[i]) return 1;
    }
    return a.length - b2.length;
  }
  function sortIndexPaths(indexPaths) {
    return indexPaths.sort(compareIndexPaths);
  }
  function find(node2, options) {
    let found;
    visit(node2, {
      ...options,
      onEnter: (child, indexPath) => {
        if (options.predicate(child, indexPath)) {
          found = child;
          return "stop";
        }
      }
    });
    return found;
  }
  function findAll(node2, options) {
    const found = [];
    visit(node2, {
      onEnter: (child, indexPath) => {
        if (options.predicate(child, indexPath)) found.push(child);
      },
      getChildren: options.getChildren
    });
    return found;
  }
  function findIndexPath(node2, options) {
    let found;
    visit(node2, {
      onEnter: (child, indexPath) => {
        if (options.predicate(child, indexPath)) {
          found = [...indexPath];
          return "stop";
        }
      },
      getChildren: options.getChildren
    });
    return found;
  }
  function reduce(node2, options) {
    let result = options.initialResult;
    visit(node2, {
      ...options,
      onEnter: (child, indexPath) => {
        result = options.nextResult(result, child, indexPath);
      }
    });
    return result;
  }
  function flatMap(node2, options) {
    return reduce(node2, {
      ...options,
      initialResult: [],
      nextResult: (result, child, indexPath) => {
        result.push(...options.transform(child, indexPath));
        return result;
      }
    });
  }
  function filter$1(node2, options) {
    const { predicate, create, getChildren } = options;
    const filterRecursive = (node22, indexPath) => {
      const children = getChildren(node22, indexPath);
      const filteredChildren = [];
      children.forEach((child, index) => {
        const childIndexPath = [...indexPath, index];
        const filteredChild = filterRecursive(child, childIndexPath);
        if (filteredChild) filteredChildren.push(filteredChild);
      });
      const isRoot = indexPath.length === 0;
      const nodeMatches = predicate(node22, indexPath);
      const hasFilteredChildren = filteredChildren.length > 0;
      if (isRoot || nodeMatches || hasFilteredChildren) {
        return create(node22, filteredChildren, indexPath);
      }
      return null;
    };
    return filterRecursive(node2, []) || create(node2, [], []);
  }
  function flatten$1(rootNode, options) {
    const nodes = [];
    let idx = 0;
    const idxMap = new Map();
    const parentMap = new Map();
    visit(rootNode, {
      getChildren: options.getChildren,
      onEnter: (node2, indexPath) => {
        if (!idxMap.has(node2)) {
          idxMap.set(node2, idx++);
        }
        const children = options.getChildren(node2, indexPath);
        children.forEach((child) => {
          if (!parentMap.has(child)) {
            parentMap.set(child, node2);
          }
          if (!idxMap.has(child)) {
            idxMap.set(child, idx++);
          }
        });
        const _children = children.length > 0 ? children.map((child) => idxMap.get(child)) : void 0;
        const parent = parentMap.get(node2);
        const _parent = parent ? idxMap.get(parent) : void 0;
        const _index = idxMap.get(node2);
        nodes.push({ ...node2, _children, _parent, _index });
      }
    });
    return nodes;
  }
  function insertOperation(index, nodes) {
    return { type: "insert", index, nodes };
  }
  function removeOperation(indexes) {
    return { type: "remove", indexes };
  }
  function replaceOperation() {
    return { type: "replace" };
  }
  function splitIndexPath(indexPath) {
    return [indexPath.slice(0, -1), indexPath[indexPath.length - 1]];
  }
  function getInsertionOperations(indexPath, nodes, operations = new Map()) {
    const [parentIndexPath, index] = splitIndexPath(indexPath);
    for (let i = parentIndexPath.length - 1; i >= 0; i--) {
      const parentKey = parentIndexPath.slice(0, i).join();
      switch (operations.get(parentKey)?.type) {
        case "remove":
          continue;
      }
      operations.set(parentKey, replaceOperation());
    }
    const operation = operations.get(parentIndexPath.join());
    switch (operation?.type) {
      case "remove":
        operations.set(parentIndexPath.join(), {
          type: "removeThenInsert",
          removeIndexes: operation.indexes,
          insertIndex: index,
          insertNodes: nodes
        });
        break;
      default:
        operations.set(parentIndexPath.join(), insertOperation(index, nodes));
    }
    return operations;
  }
  function getRemovalOperations(indexPaths) {
    const operations = new Map();
    const indexesToRemove = new Map();
    for (const indexPath of indexPaths) {
      const parentKey = indexPath.slice(0, -1).join();
      const value = indexesToRemove.get(parentKey) ?? [];
      value.push(indexPath[indexPath.length - 1]);
      indexesToRemove.set(
        parentKey,
        value.sort((a, b2) => a - b2)
      );
    }
    for (const indexPath of indexPaths) {
      for (let i = indexPath.length - 2; i >= 0; i--) {
        const parentKey = indexPath.slice(0, i).join();
        if (!operations.has(parentKey)) {
          operations.set(parentKey, replaceOperation());
        }
      }
    }
    for (const [parentKey, indexes] of indexesToRemove) {
      operations.set(parentKey, removeOperation(indexes));
    }
    return operations;
  }
  function getReplaceOperations(indexPath, node2) {
    const operations = new Map();
    const [parentIndexPath, index] = splitIndexPath(indexPath);
    for (let i = parentIndexPath.length - 1; i >= 0; i--) {
      const parentKey = parentIndexPath.slice(0, i).join();
      operations.set(parentKey, replaceOperation());
    }
    operations.set(parentIndexPath.join(), {
      type: "removeThenInsert",
      removeIndexes: [index],
      insertIndex: index,
      insertNodes: [node2]
    });
    return operations;
  }
  function mutate(node2, operations, options) {
    return map(node2, {
      ...options,
      getChildren: (node22, indexPath) => {
        const key = indexPath.join();
        const operation = operations.get(key);
        switch (operation?.type) {
          case "replace":
          case "remove":
          case "removeThenInsert":
          case "insert":
            return options.getChildren(node22, indexPath);
          default:
            return [];
        }
      },
      transform: (node22, children, indexPath) => {
        const key = indexPath.join();
        const operation = operations.get(key);
        switch (operation?.type) {
          case "remove":
            return options.create(
              node22,
              children.filter((_2, index) => !operation.indexes.includes(index)),
              indexPath
            );
          case "removeThenInsert":
            const updatedChildren = children.filter((_2, index) => !operation.removeIndexes.includes(index));
            const adjustedIndex = operation.removeIndexes.reduce(
              (index, removedIndex) => removedIndex < index ? index - 1 : index,
              operation.insertIndex
            );
            return options.create(node22, splice(updatedChildren, adjustedIndex, 0, ...operation.insertNodes), indexPath);
          case "insert":
            return options.create(node22, splice(children, operation.index, 0, ...operation.nodes), indexPath);
          case "replace":
            return options.create(node22, children, indexPath);
          default:
            return node22;
        }
      }
    });
  }
  function splice(array, start, deleteCount, ...items) {
    return [...array.slice(0, start), ...items, ...array.slice(start + deleteCount)];
  }
  function map(node2, options) {
    const childrenMap = {};
    visit(node2, {
      ...options,
      onLeave: (child, indexPath) => {
        const keyIndexPath = [0, ...indexPath];
        const key = keyIndexPath.join();
        const transformed = options.transform(child, childrenMap[key] ?? [], indexPath);
        const parentKey = keyIndexPath.slice(0, -1).join();
        const parentChildren = childrenMap[parentKey] ?? [];
        parentChildren.push(transformed);
        childrenMap[parentKey] = parentChildren;
      }
    });
    return childrenMap[""][0];
  }
  function insert2(node2, options) {
    const { nodes, at } = options;
    if (at.length === 0) throw new Error(`Can't insert nodes at the root`);
    const state2 = getInsertionOperations(at, nodes);
    return mutate(node2, state2, options);
  }
  function replace(node2, options) {
    if (options.at.length === 0) return options.node;
    const operations = getReplaceOperations(options.at, options.node);
    return mutate(node2, operations, options);
  }
  function remove(node2, options) {
    if (options.indexPaths.length === 0) return node2;
    for (const indexPath of options.indexPaths) {
      if (indexPath.length === 0) throw new Error(`Can't remove the root node`);
    }
    const operations = getRemovalOperations(options.indexPaths);
    return mutate(node2, operations, options);
  }
  function move2(node2, options) {
    if (options.indexPaths.length === 0) return node2;
    for (const indexPath of options.indexPaths) {
      if (indexPath.length === 0) throw new Error(`Can't move the root node`);
    }
    if (options.to.length === 0) throw new Error(`Can't move nodes to the root`);
    const _ancestorIndexPaths = ancestorIndexPaths(options.indexPaths);
    const nodesToInsert = _ancestorIndexPaths.map((indexPath) => access(node2, indexPath, options));
    const operations = getInsertionOperations(options.to, nodesToInsert, getRemovalOperations(_ancestorIndexPaths));
    return mutate(node2, operations, options);
  }
  function visit(node2, options) {
    const { onEnter, onLeave, getChildren } = options;
    let indexPath = [];
    let stack = [{ node: node2 }];
    const getIndexPath = options.reuseIndexPath ? () => indexPath : () => indexPath.slice();
    while (stack.length > 0) {
      let wrapper = stack[stack.length - 1];
      if (wrapper.state === void 0) {
        const enterResult = onEnter?.(wrapper.node, getIndexPath());
        if (enterResult === "stop") return;
        wrapper.state = enterResult === "skip" ? -1 : 0;
      }
      const children = wrapper.children || getChildren(wrapper.node, getIndexPath());
      wrapper.children || (wrapper.children = children);
      if (wrapper.state !== -1) {
        if (wrapper.state < children.length) {
          let currentIndex = wrapper.state;
          indexPath.push(currentIndex);
          stack.push({ node: children[currentIndex] });
          wrapper.state = currentIndex + 1;
          continue;
        }
        const leaveResult = onLeave?.(wrapper.node, getIndexPath());
        if (leaveResult === "stop") return;
      }
      indexPath.pop();
      stack.pop();
    }
  }
  var TreeCollection = class _TreeCollection {
    constructor(options) {
      this.options = options;
      __publicField$2(this, "rootNode");
      __publicField$2(this, "isEqual", (other) => {
        return isEqual(this.rootNode, other.rootNode);
      });
      __publicField$2(this, "getNodeChildren", (node2) => {
        return this.options.nodeToChildren?.(node2) ?? fallbackMethods.nodeToChildren(node2) ?? [];
      });
      __publicField$2(this, "resolveIndexPath", (valueOrIndexPath) => {
        return typeof valueOrIndexPath === "string" ? this.getIndexPath(valueOrIndexPath) : valueOrIndexPath;
      });
      __publicField$2(this, "resolveNode", (valueOrIndexPath) => {
        const indexPath = this.resolveIndexPath(valueOrIndexPath);
        return indexPath ? this.at(indexPath) : void 0;
      });
      __publicField$2(this, "getNodeChildrenCount", (node2) => {
        return this.options.nodeToChildrenCount?.(node2) ?? fallbackMethods.nodeToChildrenCount(node2);
      });
      __publicField$2(this, "getNodeValue", (node2) => {
        return this.options.nodeToValue?.(node2) ?? fallbackMethods.nodeToValue(node2);
      });
      __publicField$2(this, "getNodeDisabled", (node2) => {
        return this.options.isNodeDisabled?.(node2) ?? fallbackMethods.isNodeDisabled(node2);
      });
      __publicField$2(this, "stringify", (value) => {
        const node2 = this.findNode(value);
        if (!node2) return null;
        return this.stringifyNode(node2);
      });
      __publicField$2(this, "stringifyNode", (node2) => {
        return this.options.nodeToString?.(node2) ?? fallbackMethods.nodeToString(node2);
      });
      __publicField$2(this, "getFirstNode", (rootNode = this.rootNode) => {
        let firstChild;
        visit(rootNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (!firstChild && indexPath.length > 0 && !this.getNodeDisabled(node2)) {
              firstChild = node2;
              return "stop";
            }
          }
        });
        return firstChild;
      });
      __publicField$2(this, "getLastNode", (rootNode = this.rootNode, opts = {}) => {
        let lastChild;
        visit(rootNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (this.isSameNode(node2, rootNode)) return;
            if (opts.skip?.({ value: this.getNodeValue(node2), node: node2, indexPath })) return "skip";
            if (indexPath.length > 0 && !this.getNodeDisabled(node2)) {
              lastChild = node2;
            }
          }
        });
        return lastChild;
      });
      __publicField$2(this, "at", (indexPath) => {
        return access(this.rootNode, indexPath, {
          getChildren: this.getNodeChildren
        });
      });
      __publicField$2(this, "findNode", (value, rootNode = this.rootNode) => {
        return find(rootNode, {
          getChildren: this.getNodeChildren,
          predicate: (node2) => this.getNodeValue(node2) === value
        });
      });
      __publicField$2(this, "findNodes", (values, rootNode = this.rootNode) => {
        const v = new Set(values.filter((v2) => v2 != null));
        return findAll(rootNode, {
          getChildren: this.getNodeChildren,
          predicate: (node2) => v.has(this.getNodeValue(node2))
        });
      });
      __publicField$2(this, "sort", (values) => {
        return values.reduce((acc, value) => {
          const indexPath = this.getIndexPath(value);
          if (indexPath) acc.push({ value, indexPath });
          return acc;
        }, []).sort((a, b2) => compareIndexPaths(a.indexPath, b2.indexPath)).map(({ value }) => value);
      });
      __publicField$2(this, "getIndexPath", (value) => {
        return findIndexPath(this.rootNode, {
          getChildren: this.getNodeChildren,
          predicate: (node2) => this.getNodeValue(node2) === value
        });
      });
      __publicField$2(this, "getValue", (indexPath) => {
        const node2 = this.at(indexPath);
        return node2 ? this.getNodeValue(node2) : void 0;
      });
      __publicField$2(this, "getValuePath", (indexPath) => {
        if (!indexPath) return [];
        const valuePath = [];
        let currentPath = [...indexPath];
        while (currentPath.length > 0) {
          const node2 = this.at(currentPath);
          if (node2) valuePath.unshift(this.getNodeValue(node2));
          currentPath.pop();
        }
        return valuePath;
      });
      __publicField$2(this, "getDepth", (value) => {
        const indexPath = findIndexPath(this.rootNode, {
          getChildren: this.getNodeChildren,
          predicate: (node2) => this.getNodeValue(node2) === value
        });
        return indexPath?.length ?? 0;
      });
      __publicField$2(this, "isSameNode", (node2, other) => {
        return this.getNodeValue(node2) === this.getNodeValue(other);
      });
      __publicField$2(this, "isRootNode", (node2) => {
        return this.isSameNode(node2, this.rootNode);
      });
      __publicField$2(this, "contains", (parentIndexPath, valueIndexPath) => {
        if (!parentIndexPath || !valueIndexPath) return false;
        return valueIndexPath.slice(0, parentIndexPath.length).every((_2, i) => parentIndexPath[i] === valueIndexPath[i]);
      });
      __publicField$2(this, "getNextNode", (value, opts = {}) => {
        let found = false;
        let nextNode;
        visit(this.rootNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (this.isRootNode(node2)) return;
            const nodeValue = this.getNodeValue(node2);
            if (opts.skip?.({ value: nodeValue, node: node2, indexPath })) {
              if (nodeValue === value) {
                found = true;
              }
              return "skip";
            }
            if (found && !this.getNodeDisabled(node2)) {
              nextNode = node2;
              return "stop";
            }
            if (nodeValue === value) {
              found = true;
            }
          }
        });
        return nextNode;
      });
      __publicField$2(this, "getPreviousNode", (value, opts = {}) => {
        let previousNode;
        let found = false;
        visit(this.rootNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (this.isRootNode(node2)) return;
            const nodeValue = this.getNodeValue(node2);
            if (opts.skip?.({ value: nodeValue, node: node2, indexPath })) {
              return "skip";
            }
            if (nodeValue === value) {
              found = true;
              return "stop";
            }
            if (!this.getNodeDisabled(node2)) {
              previousNode = node2;
            }
          }
        });
        return found ? previousNode : void 0;
      });
      __publicField$2(this, "getParentNodes", (valueOrIndexPath) => {
        const indexPath = this.resolveIndexPath(valueOrIndexPath)?.slice();
        if (!indexPath) return [];
        const result = [];
        while (indexPath.length > 0) {
          indexPath.pop();
          const parentNode = this.at(indexPath);
          if (parentNode && !this.isRootNode(parentNode)) {
            result.unshift(parentNode);
          }
        }
        return result;
      });
      __publicField$2(this, "getDescendantNodes", (valueOrIndexPath, options2) => {
        const parentNode = this.resolveNode(valueOrIndexPath);
        if (!parentNode) return [];
        const result = [];
        visit(parentNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, nodeIndexPath) => {
            if (nodeIndexPath.length === 0) return;
            if (!options2?.withBranch && this.isBranchNode(node2)) return;
            result.push(node2);
          }
        });
        return result;
      });
      __publicField$2(this, "getDescendantValues", (valueOrIndexPath, options2) => {
        const children = this.getDescendantNodes(valueOrIndexPath, options2);
        return children.map((child) => this.getNodeValue(child));
      });
      __publicField$2(this, "getParentIndexPath", (indexPath) => {
        return indexPath.slice(0, -1);
      });
      __publicField$2(this, "getParentNode", (valueOrIndexPath) => {
        const indexPath = this.resolveIndexPath(valueOrIndexPath);
        return indexPath ? this.at(this.getParentIndexPath(indexPath)) : void 0;
      });
      __publicField$2(this, "visit", (opts) => {
        const { skip, ...rest } = opts;
        visit(this.rootNode, {
          ...rest,
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (this.isRootNode(node2)) return;
            if (skip?.({ value: this.getNodeValue(node2), node: node2, indexPath })) return "skip";
            return rest.onEnter?.(node2, indexPath);
          }
        });
      });
      __publicField$2(this, "getPreviousSibling", (indexPath) => {
        const parentNode = this.getParentNode(indexPath);
        if (!parentNode) return;
        const siblings = this.getNodeChildren(parentNode);
        let idx = indexPath[indexPath.length - 1];
        while (--idx >= 0) {
          const sibling = siblings[idx];
          if (!this.getNodeDisabled(sibling)) return sibling;
        }
        return;
      });
      __publicField$2(this, "getNextSibling", (indexPath) => {
        const parentNode = this.getParentNode(indexPath);
        if (!parentNode) return;
        const siblings = this.getNodeChildren(parentNode);
        let idx = indexPath[indexPath.length - 1];
        while (++idx < siblings.length) {
          const sibling = siblings[idx];
          if (!this.getNodeDisabled(sibling)) return sibling;
        }
        return;
      });
      __publicField$2(this, "getSiblingNodes", (indexPath) => {
        const parentNode = this.getParentNode(indexPath);
        return parentNode ? this.getNodeChildren(parentNode) : [];
      });
      __publicField$2(this, "getValues", (rootNode = this.rootNode) => {
        const values = flatMap(rootNode, {
          getChildren: this.getNodeChildren,
          transform: (node2) => [this.getNodeValue(node2)]
        });
        return values.slice(1);
      });
      __publicField$2(this, "isValidDepth", (indexPath, depth) => {
        if (depth == null) return true;
        if (typeof depth === "function") return depth(indexPath.length);
        return indexPath.length === depth;
      });
      __publicField$2(this, "isBranchNode", (node2) => {
        return this.getNodeChildren(node2).length > 0 || this.getNodeChildrenCount(node2) != null;
      });
      __publicField$2(this, "getBranchValues", (rootNode = this.rootNode, opts = {}) => {
        let values = [];
        visit(rootNode, {
          getChildren: this.getNodeChildren,
          onEnter: (node2, indexPath) => {
            if (indexPath.length === 0) return;
            const nodeValue = this.getNodeValue(node2);
            if (opts.skip?.({ value: nodeValue, node: node2, indexPath })) return "skip";
            if (this.isBranchNode(node2) && this.isValidDepth(indexPath, opts.depth)) {
              values.push(this.getNodeValue(node2));
            }
          }
        });
        return values;
      });
      __publicField$2(this, "flatten", (rootNode = this.rootNode) => {
        return flatten$1(rootNode, { getChildren: this.getNodeChildren });
      });
      __publicField$2(this, "_create", (node2, children) => {
        if (this.getNodeChildren(node2).length > 0 || children.length > 0) {
          return { ...node2, children };
        }
        return { ...node2 };
      });
      __publicField$2(this, "_insert", (rootNode, indexPath, nodes) => {
        return this.copy(
          insert2(rootNode, { at: indexPath, nodes, getChildren: this.getNodeChildren, create: this._create })
        );
      });
      __publicField$2(this, "copy", (rootNode) => {
        return new _TreeCollection({ ...this.options, rootNode });
      });
      __publicField$2(this, "_replace", (rootNode, indexPath, node2) => {
        return this.copy(
          replace(rootNode, { at: indexPath, node: node2, getChildren: this.getNodeChildren, create: this._create })
        );
      });
      __publicField$2(this, "_move", (rootNode, indexPaths, to) => {
        return this.copy(move2(rootNode, { indexPaths, to, getChildren: this.getNodeChildren, create: this._create }));
      });
      __publicField$2(this, "_remove", (rootNode, indexPaths) => {
        return this.copy(remove(rootNode, { indexPaths, getChildren: this.getNodeChildren, create: this._create }));
      });
      __publicField$2(this, "replace", (indexPath, node2) => {
        return this._replace(this.rootNode, indexPath, node2);
      });
      __publicField$2(this, "remove", (indexPaths) => {
        return this._remove(this.rootNode, indexPaths);
      });
      __publicField$2(this, "insertBefore", (indexPath, nodes) => {
        const parentNode = this.getParentNode(indexPath);
        return parentNode ? this._insert(this.rootNode, indexPath, nodes) : void 0;
      });
      __publicField$2(this, "insertAfter", (indexPath, nodes) => {
        const parentNode = this.getParentNode(indexPath);
        if (!parentNode) return;
        const nextIndex2 = [...indexPath.slice(0, -1), indexPath[indexPath.length - 1] + 1];
        return this._insert(this.rootNode, nextIndex2, nodes);
      });
      __publicField$2(this, "move", (fromIndexPaths, toIndexPath) => {
        return this._move(this.rootNode, fromIndexPaths, toIndexPath);
      });
      __publicField$2(this, "filter", (predicate) => {
        const filteredRoot = filter$1(this.rootNode, {
          predicate,
          getChildren: this.getNodeChildren,
          create: this._create
        });
        return this.copy(filteredRoot);
      });
      __publicField$2(this, "toJSON", () => {
        return this.getValues(this.rootNode);
      });
      this.rootNode = options.rootNode;
    }
  };
  var fallbackMethods = {
    nodeToValue(node2) {
      if (typeof node2 === "string") return node2;
      if (isObject$2(node2) && hasProp(node2, "value")) return node2.value;
      return "";
    },
    nodeToString(node2) {
      if (typeof node2 === "string") return node2;
      if (isObject$2(node2) && hasProp(node2, "label")) return node2.label;
      return fallbackMethods.nodeToValue(node2);
    },
    isNodeDisabled(node2) {
      if (isObject$2(node2) && hasProp(node2, "disabled")) return !!node2.disabled;
      return false;
    },
    nodeToChildren(node2) {
      return node2.children;
    },
    nodeToChildrenCount(node2) {
      if (isObject$2(node2) && hasProp(node2, "childrenCount")) return node2.childrenCount;
    }
  };
  var anatomy$l = createAnatomy("combobox").parts(
    "root",
    "clearTrigger",
    "content",
    "control",
    "input",
    "item",
    "itemGroup",
    "itemGroupLabel",
    "itemIndicator",
    "itemText",
    "label",
    "list",
    "positioner",
    "trigger"
  );
  anatomy$l.build();
  var collection$3 = (options) => {
    return new ListCollection(options);
  };
  collection$3.empty = () => {
    return new ListCollection({ items: [] });
  };
  var getControlId = (ctx) => ctx.ids?.control ?? `combobox:${ctx.id}:control`;
  var getInputId$2 = (ctx) => ctx.ids?.input ?? `combobox:${ctx.id}:input`;
  var getContentId$6 = (ctx) => ctx.ids?.content ?? `combobox:${ctx.id}:content`;
  var getPositionerId$4 = (ctx) => ctx.ids?.positioner ?? `combobox:${ctx.id}:popper`;
  var getTriggerId$5 = (ctx) => ctx.ids?.trigger ?? `combobox:${ctx.id}:toggle-btn`;
  var getClearTriggerId$1 = (ctx) => ctx.ids?.clearTrigger ?? `combobox:${ctx.id}:clear-btn`;
  var getContentEl$6 = (ctx) => ctx.getById(getContentId$6(ctx));
  var getInputEl$2 = (ctx) => ctx.getById(getInputId$2(ctx));
  var getPositionerEl$4 = (ctx) => ctx.getById(getPositionerId$4(ctx));
  var getControlEl = (ctx) => ctx.getById(getControlId(ctx));
  var getTriggerEl$5 = (ctx) => ctx.getById(getTriggerId$5(ctx));
  var getClearTriggerEl$1 = (ctx) => ctx.getById(getClearTriggerId$1(ctx));
  var getItemEl$3 = (ctx, value) => {
    if (value == null) return null;
    const selector = `[role=option][data-value="${CSS.escape(value)}"]`;
    return query(getContentEl$6(ctx), selector);
  };
  var focusInputEl = (ctx) => {
    const inputEl = getInputEl$2(ctx);
    if (ctx.isActiveElement(inputEl)) return;
    inputEl?.focus({ preventScroll: true });
  };
  var focusTriggerEl = (ctx) => {
    const triggerEl = getTriggerEl$5(ctx);
    if (ctx.isActiveElement(triggerEl)) return;
    triggerEl?.focus({ preventScroll: true });
  };
  var { guards: guards$2, createMachine: createMachine$3, choose: choose$1 } = setup();
  var { and: and$7, not: not$6 } = guards$2;
  createMachine$3({
    props({ props: props2 }) {
      return {
        loopFocus: true,
        openOnClick: false,
        defaultValue: [],
        defaultInputValue: "",
        closeOnSelect: !props2.multiple,
        allowCustomValue: false,
        alwaysSubmitOnEnter: false,
        inputBehavior: "none",
        selectionBehavior: props2.multiple ? "clear" : "replace",
        openOnKeyPress: true,
        openOnChange: true,
        composite: true,
        navigate({ node: node2 }) {
          clickIfLink(node2);
        },
        collection: collection$3.empty(),
        ...props2,
        positioning: {
          placement: "bottom",
          sameWidth: true,
          ...props2.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          ...props2.translations
        }
      };
    },
    initialState({ prop }) {
      const open = prop("open") || prop("defaultOpen");
      return open ? "suggesting" : "idle";
    },
    context({ prop, bindable, getContext, getEvent }) {
      return {
        currentPlacement: bindable(() => ({
          defaultValue: void 0
        })),
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          isEqual,
          hash(value) {
            return value.join(",");
          },
          onChange(value) {
            const context = getContext();
            const prevSelectedItems = context.get("selectedItems");
            const collection2 = prop("collection");
            const nextItems = value.map((v) => {
              const item = prevSelectedItems.find((item2) => collection2.getItemValue(item2) === v);
              return item || collection2.find(v);
            });
            context.set("selectedItems", nextItems);
            prop("onValueChange")?.({ value, items: nextItems });
          }
        })),
        highlightedValue: bindable(() => ({
          defaultValue: prop("defaultHighlightedValue") || null,
          value: prop("highlightedValue"),
          onChange(value) {
            const item = prop("collection").find(value);
            prop("onHighlightChange")?.({ highlightedValue: value, highlightedItem: item });
          }
        })),
        inputValue: bindable(() => {
          let inputValue = prop("inputValue") || prop("defaultInputValue");
          const value = prop("value") || prop("defaultValue");
          if (!inputValue.trim() && !prop("multiple")) {
            const valueAsString = prop("collection").stringifyMany(value);
            inputValue = match$2(prop("selectionBehavior"), {
              preserve: inputValue || valueAsString,
              replace: valueAsString,
              clear: ""
            });
          }
          return {
            defaultValue: inputValue,
            value: prop("inputValue"),
            onChange(value2) {
              const event = getEvent();
              const reason = (event.previousEvent || event).src;
              prop("onInputValueChange")?.({ inputValue: value2, reason });
            }
          };
        }),
        highlightedItem: bindable(() => {
          const highlightedValue = prop("highlightedValue");
          const highlightedItem = prop("collection").find(highlightedValue);
          return { defaultValue: highlightedItem };
        }),
        selectedItems: bindable(() => {
          const value = prop("value") || prop("defaultValue") || [];
          const selectedItems = prop("collection").findMany(value);
          return { defaultValue: selectedItems };
        })
      };
    },
    computed: {
      isInputValueEmpty: ({ context }) => context.get("inputValue").length === 0,
      isInteractive: ({ prop }) => !(prop("readOnly") || prop("disabled")),
      autoComplete: ({ prop }) => prop("inputBehavior") === "autocomplete",
      autoHighlight: ({ prop }) => prop("inputBehavior") === "autohighlight",
      hasSelectedItems: ({ context }) => context.get("value").length > 0,
      valueAsString: ({ context, prop }) => prop("collection").stringifyItems(context.get("selectedItems")),
      isCustomValue: ({ context, computed }) => context.get("inputValue") !== computed("valueAsString")
    },
    watch({ context, prop, track, action, send }) {
      track([() => context.hash("value")], () => {
        action(["syncSelectedItems"]);
      });
      track([() => context.get("inputValue")], () => {
        action(["syncInputValue"]);
      });
      track([() => context.get("highlightedValue")], () => {
        action(["syncHighlightedItem", "autofillInputValue"]);
      });
      track([() => prop("open")], () => {
        action(["toggleVisibility"]);
      });
      track([() => prop("collection").toString()], () => {
        send({ type: "CHILDREN_CHANGE" });
      });
    },
    on: {
      "SELECTED_ITEMS.SYNC": {
        actions: ["syncSelectedItems"]
      },
      "HIGHLIGHTED_VALUE.SET": {
        actions: ["setHighlightedValue"]
      },
      "HIGHLIGHTED_VALUE.CLEAR": {
        actions: ["clearHighlightedValue"]
      },
      "ITEM.SELECT": {
        actions: ["selectItem"]
      },
      "ITEM.CLEAR": {
        actions: ["clearItem"]
      },
      "VALUE.SET": {
        actions: ["setValue"]
      },
      "INPUT_VALUE.SET": {
        actions: ["setInputValue"]
      },
      "POSITIONING.SET": {
        actions: ["reposition"]
      }
    },
    entry: choose$1([
      {
        guard: "autoFocus",
        actions: ["setInitialFocus"]
      }
    ]),
    states: {
      idle: {
        tags: ["idle", "closed"],
        entry: ["scrollContentToTop", "clearHighlightedValue"],
        on: {
          "CONTROLLED.OPEN": {
            target: "interacting"
          },
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
            }
          ],
          "INPUT.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            }
          ],
          "INPUT.FOCUS": {
            target: "focused"
          },
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["invokeOnOpen"]
            }
          ],
          "VALUE.CLEAR": {
            target: "focused",
            actions: ["clearInputValue", "clearSelectedItems", "setInitialFocus"]
          }
        }
      },
      focused: {
        tags: ["focused", "closed"],
        entry: ["scrollContentToTop", "clearHighlightedValue"],
        on: {
          "CONTROLLED.OPEN": [
            {
              guard: "isChangeEvent",
              target: "suggesting"
            },
            {
              target: "interacting"
            }
          ],
          "INPUT.CHANGE": [
            {
              guard: and$7("isOpenControlled", "openOnChange"),
              actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
            },
            {
              guard: "openOnChange",
              target: "suggesting",
              actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
            },
            {
              actions: ["setInputValue"]
            }
          ],
          "LAYER.INTERACT_OUTSIDE": {
            target: "idle"
          },
          "INPUT.ESCAPE": {
            guard: and$7("isCustomValue", not$6("allowCustomValue")),
            actions: ["revertInputValue"]
          },
          "INPUT.BLUR": {
            target: "idle"
          },
          "INPUT.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
            }
          ],
          "INPUT.ARROW_DOWN": [
{
              guard: and$7("isOpenControlled", "autoComplete"),
              actions: ["invokeOnOpen"]
            },
            {
              guard: "autoComplete",
              target: "interacting",
              actions: ["invokeOnOpen"]
            },
{
              guard: "isOpenControlled",
              actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
            }
          ],
          "INPUT.ARROW_UP": [
{
              guard: "autoComplete",
              target: "interacting",
              actions: ["invokeOnOpen"]
            },
            {
              guard: "autoComplete",
              target: "interacting",
              actions: ["invokeOnOpen"]
            },
{
              target: "interacting",
              actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
            }
          ],
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "interacting",
              actions: ["invokeOnOpen"]
            }
          ],
          "VALUE.CLEAR": {
            actions: ["clearInputValue", "clearSelectedItems"]
          }
        }
      },
      interacting: {
        tags: ["open", "focused"],
        entry: ["setInitialFocus"],
        effects: ["scrollToHighlightedItem", "trackDismissableLayer", "trackPlacement"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              guard: "restoreFocus",
              target: "focused",
              actions: ["setFinalFocus"]
            },
            {
              target: "idle"
            }
          ],
          CHILDREN_CHANGE: [
            {
              guard: "isHighlightedItemRemoved",
              actions: ["clearHighlightedValue"]
            },
            {
              actions: ["scrollToHighlightedItem"]
            }
          ],
          "INPUT.HOME": {
            actions: ["highlightFirstItem"]
          },
          "INPUT.END": {
            actions: ["highlightLastItem"]
          },
          "INPUT.ARROW_DOWN": [
            {
              guard: and$7("autoComplete", "isLastItemHighlighted"),
              actions: ["clearHighlightedValue", "scrollContentToTop"]
            },
            {
              actions: ["highlightNextItem"]
            }
          ],
          "INPUT.ARROW_UP": [
            {
              guard: and$7("autoComplete", "isFirstItemHighlighted"),
              actions: ["clearHighlightedValue"]
            },
            {
              actions: ["highlightPrevItem"]
            }
          ],
          "INPUT.ENTER": [
{
              guard: and$7("isOpenControlled", "isCustomValue", not$6("hasHighlightedItem"), not$6("allowCustomValue")),
              actions: ["revertInputValue", "invokeOnClose"]
            },
            {
              guard: and$7("isCustomValue", not$6("hasHighlightedItem"), not$6("allowCustomValue")),
              target: "focused",
              actions: ["revertInputValue", "invokeOnClose"]
            },
{
              guard: and$7("isOpenControlled", "closeOnSelect"),
              actions: ["selectHighlightedItem", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
            },
            {
              actions: ["selectHighlightedItem"]
            }
          ],
          "INPUT.CHANGE": [
            {
              guard: "autoComplete",
              target: "suggesting",
              actions: ["setInputValue"]
            },
            {
              target: "suggesting",
              actions: ["clearHighlightedValue", "setInputValue"]
            }
          ],
          "ITEM.POINTER_MOVE": {
            actions: ["setHighlightedValue"]
          },
          "ITEM.POINTER_LEAVE": {
            actions: ["clearHighlightedValue"]
          },
          "ITEM.CLICK": [
            {
              guard: and$7("isOpenControlled", "closeOnSelect"),
              actions: ["selectItem", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
            },
            {
              actions: ["selectItem"]
            }
          ],
          "LAYER.ESCAPE": [
            {
              guard: and$7("isOpenControlled", "autoComplete"),
              actions: ["syncInputValue", "invokeOnClose"]
            },
            {
              guard: "autoComplete",
              target: "focused",
              actions: ["syncInputValue", "invokeOnClose"]
            },
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose", "setFinalFocus"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose"]
            }
          ],
          "LAYER.INTERACT_OUTSIDE": [
{
              guard: and$7("isOpenControlled", "isCustomValue", not$6("allowCustomValue")),
              actions: ["revertInputValue", "invokeOnClose"]
            },
            {
              guard: and$7("isCustomValue", not$6("allowCustomValue")),
              target: "idle",
              actions: ["revertInputValue", "invokeOnClose"]
            },
{
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose", "setFinalFocus"]
            }
          ],
          "VALUE.CLEAR": [
            {
              guard: "isOpenControlled",
              actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
            }
          ]
        }
      },
      suggesting: {
        tags: ["open", "focused"],
        effects: ["trackDismissableLayer", "scrollToHighlightedItem", "trackPlacement"],
        entry: ["setInitialFocus"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              guard: "restoreFocus",
              target: "focused",
              actions: ["setFinalFocus"]
            },
            {
              target: "idle"
            }
          ],
          CHILDREN_CHANGE: [
            {
              guard: and$7("isHighlightedItemRemoved", "hasCollectionItems", "autoHighlight"),
              actions: ["clearHighlightedValue", "highlightFirstItem"]
            },
            {
              guard: "isHighlightedItemRemoved",
              actions: ["clearHighlightedValue"]
            },
            {
              guard: "autoHighlight",
              actions: ["highlightFirstItem"]
            }
          ],
          "INPUT.ARROW_DOWN": {
            target: "interacting",
            actions: ["highlightNextItem"]
          },
          "INPUT.ARROW_UP": {
            target: "interacting",
            actions: ["highlightPrevItem"]
          },
          "INPUT.HOME": {
            target: "interacting",
            actions: ["highlightFirstItem"]
          },
          "INPUT.END": {
            target: "interacting",
            actions: ["highlightLastItem"]
          },
          "INPUT.ENTER": [
{
              guard: and$7("isOpenControlled", "isCustomValue", not$6("hasHighlightedItem"), not$6("allowCustomValue")),
              actions: ["revertInputValue", "invokeOnClose"]
            },
            {
              guard: and$7("isCustomValue", not$6("hasHighlightedItem"), not$6("allowCustomValue")),
              target: "focused",
              actions: ["revertInputValue", "invokeOnClose"]
            },
{
              guard: and$7("isOpenControlled", "closeOnSelect"),
              actions: ["selectHighlightedItem", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
            },
            {
              actions: ["selectHighlightedItem"]
            }
          ],
          "INPUT.CHANGE": {
            actions: ["setInputValue"]
          },
          "LAYER.ESCAPE": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose"]
            }
          ],
          "ITEM.POINTER_MOVE": {
            target: "interacting",
            actions: ["setHighlightedValue"]
          },
          "ITEM.POINTER_LEAVE": {
            actions: ["clearHighlightedValue"]
          },
          "LAYER.INTERACT_OUTSIDE": [
{
              guard: and$7("isOpenControlled", "isCustomValue", not$6("allowCustomValue")),
              actions: ["revertInputValue", "invokeOnClose"]
            },
            {
              guard: and$7("isCustomValue", not$6("allowCustomValue")),
              target: "idle",
              actions: ["revertInputValue", "invokeOnClose"]
            },
{
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose"]
            }
          ],
          "ITEM.CLICK": [
            {
              guard: and$7("isOpenControlled", "closeOnSelect"),
              actions: ["selectItem", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
            },
            {
              actions: ["selectItem"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose", "setFinalFocus"]
            }
          ],
          "VALUE.CLEAR": [
            {
              guard: "isOpenControlled",
              actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
            }
          ]
        }
      }
    },
    implementations: {
      guards: {
        isInputValueEmpty: ({ computed }) => computed("isInputValueEmpty"),
        autoComplete: ({ computed, prop }) => computed("autoComplete") && !prop("multiple"),
        autoHighlight: ({ computed }) => computed("autoHighlight"),
        isFirstItemHighlighted: ({ prop, context }) => prop("collection").firstValue === context.get("highlightedValue"),
        isLastItemHighlighted: ({ prop, context }) => prop("collection").lastValue === context.get("highlightedValue"),
        isCustomValue: ({ computed }) => computed("isCustomValue"),
        allowCustomValue: ({ prop }) => !!prop("allowCustomValue"),
        hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
        closeOnSelect: ({ prop }) => !!prop("closeOnSelect"),
        isOpenControlled: ({ prop }) => prop("open") != null,
        openOnChange: ({ prop, context }) => {
          const openOnChange = prop("openOnChange");
          if (isBoolean(openOnChange)) return openOnChange;
          return !!openOnChange?.({ inputValue: context.get("inputValue") });
        },
        restoreFocus: ({ event }) => {
          const restoreFocus = event.restoreFocus ?? event.previousEvent?.restoreFocus;
          return restoreFocus == null ? true : !!restoreFocus;
        },
        isChangeEvent: ({ event }) => event.previousEvent?.type === "INPUT.CHANGE",
        autoFocus: ({ prop }) => !!prop("autoFocus"),
        isHighlightedItemRemoved: ({ prop, context }) => !prop("collection").has(context.get("highlightedValue")),
        hasCollectionItems: ({ prop }) => prop("collection").size > 0
      },
      effects: {
        trackDismissableLayer({ send, prop, scope }) {
          if (prop("disableLayer")) return;
          const contentEl = () => getContentEl$6(scope);
          return trackDismissableElement(contentEl, {
            type: "listbox",
            defer: true,
            exclude: () => [getInputEl$2(scope), getTriggerEl$5(scope), getClearTriggerEl$1(scope)],
            onFocusOutside: prop("onFocusOutside"),
            onPointerDownOutside: prop("onPointerDownOutside"),
            onInteractOutside: prop("onInteractOutside"),
            onEscapeKeyDown(event) {
              event.preventDefault();
              event.stopPropagation();
              send({ type: "LAYER.ESCAPE", src: "escape-key" });
            },
            onDismiss() {
              send({ type: "LAYER.INTERACT_OUTSIDE", src: "interact-outside", restoreFocus: false });
            }
          });
        },
        trackPlacement({ context, prop, scope }) {
          const anchorEl = () => getControlEl(scope) || getTriggerEl$5(scope);
          const positionerEl = () => getPositionerEl$4(scope);
          context.set("currentPlacement", prop("positioning").placement);
          return getPlacement(anchorEl, positionerEl, {
            ...prop("positioning"),
            defer: true,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        scrollToHighlightedItem({ context, prop, scope, event }) {
          const inputEl = getInputEl$2(scope);
          let cleanups = [];
          const exec = (immediate) => {
            const pointer = event.current().type.includes("POINTER");
            const highlightedValue = context.get("highlightedValue");
            if (pointer || !highlightedValue) return;
            const contentEl = getContentEl$6(scope);
            const scrollToIndexFn = prop("scrollToIndexFn");
            if (scrollToIndexFn) {
              const highlightedIndex = prop("collection").indexOf(highlightedValue);
              scrollToIndexFn({
                index: highlightedIndex,
                immediate,
                getElement: () => getItemEl$3(scope, highlightedValue)
              });
              return;
            }
            const itemEl = getItemEl$3(scope, highlightedValue);
            const raf_cleanup = raf(() => {
              scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
            });
            cleanups.push(raf_cleanup);
          };
          const rafCleanup = raf(() => exec(true));
          cleanups.push(rafCleanup);
          const observerCleanup = observeAttributes(inputEl, {
            attributes: ["aria-activedescendant"],
            callback: () => exec(false)
          });
          cleanups.push(observerCleanup);
          return () => {
            cleanups.forEach((cleanup) => cleanup());
          };
        }
      },
      actions: {
        reposition({ context, prop, scope, event }) {
          const controlEl = () => getControlEl(scope);
          const positionerEl = () => getPositionerEl$4(scope);
          getPlacement(controlEl, positionerEl, {
            ...prop("positioning"),
            ...event.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        setHighlightedValue({ context, event }) {
          if (event.value == null) return;
          context.set("highlightedValue", event.value);
        },
        clearHighlightedValue({ context }) {
          context.set("highlightedValue", null);
        },
        selectHighlightedItem(params) {
          const { context, prop } = params;
          const collection2 = prop("collection");
          const highlightedValue = context.get("highlightedValue");
          if (!highlightedValue || !collection2.has(highlightedValue)) return;
          const nextValue = prop("multiple") ? addOrRemove(context.get("value"), highlightedValue) : [highlightedValue];
          prop("onSelect")?.({ value: nextValue, itemValue: highlightedValue });
          context.set("value", nextValue);
          const inputValue = match$2(prop("selectionBehavior"), {
            preserve: context.get("inputValue"),
            replace: collection2.stringifyMany(nextValue),
            clear: ""
          });
          context.set("inputValue", inputValue);
        },
        scrollToHighlightedItem({ context, prop, scope }) {
          nextTick(() => {
            const highlightedValue = context.get("highlightedValue");
            if (highlightedValue == null) return;
            const itemEl = getItemEl$3(scope, highlightedValue);
            const contentEl = getContentEl$6(scope);
            const scrollToIndexFn = prop("scrollToIndexFn");
            if (scrollToIndexFn) {
              const highlightedIndex = prop("collection").indexOf(highlightedValue);
              scrollToIndexFn({
                index: highlightedIndex,
                immediate: true,
                getElement: () => getItemEl$3(scope, highlightedValue)
              });
              return;
            }
            scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
          });
        },
        selectItem(params) {
          const { context, event, flush: flush2, prop } = params;
          if (event.value == null) return;
          flush2(() => {
            const nextValue = prop("multiple") ? addOrRemove(context.get("value"), event.value) : [event.value];
            prop("onSelect")?.({ value: nextValue, itemValue: event.value });
            context.set("value", nextValue);
            const inputValue = match$2(prop("selectionBehavior"), {
              preserve: context.get("inputValue"),
              replace: prop("collection").stringifyMany(nextValue),
              clear: ""
            });
            context.set("inputValue", inputValue);
          });
        },
        clearItem(params) {
          const { context, event, flush: flush2, prop } = params;
          if (event.value == null) return;
          flush2(() => {
            const nextValue = remove$1(context.get("value"), event.value);
            context.set("value", nextValue);
            const inputValue = match$2(prop("selectionBehavior"), {
              preserve: context.get("inputValue"),
              replace: prop("collection").stringifyMany(nextValue),
              clear: ""
            });
            context.set("inputValue", inputValue);
          });
        },
        setInitialFocus({ scope }) {
          raf(() => {
            focusInputEl(scope);
          });
        },
        setFinalFocus({ scope }) {
          raf(() => {
            const triggerEl = getTriggerEl$5(scope);
            if (triggerEl?.dataset.focusable == null) {
              focusInputEl(scope);
            } else {
              focusTriggerEl(scope);
            }
          });
        },
        syncInputValue({ context, scope, event }) {
          const inputEl = getInputEl$2(scope);
          if (!inputEl) return;
          inputEl.value = context.get("inputValue");
          queueMicrotask(() => {
            if (event.current().type === "INPUT.CHANGE") return;
            setCaretToEnd(inputEl);
          });
        },
        setInputValue({ context, event }) {
          context.set("inputValue", event.value);
        },
        clearInputValue({ context }) {
          context.set("inputValue", "");
        },
        revertInputValue({ context, prop, computed }) {
          const selectionBehavior = prop("selectionBehavior");
          const inputValue = match$2(selectionBehavior, {
            replace: computed("hasSelectedItems") ? computed("valueAsString") : "",
            preserve: context.get("inputValue"),
            clear: ""
          });
          context.set("inputValue", inputValue);
        },
        setValue(params) {
          const { context, flush: flush2, event, prop } = params;
          flush2(() => {
            context.set("value", event.value);
            const inputValue = match$2(prop("selectionBehavior"), {
              preserve: context.get("inputValue"),
              replace: prop("collection").stringifyMany(event.value),
              clear: ""
            });
            context.set("inputValue", inputValue);
          });
        },
        clearSelectedItems(params) {
          const { context, flush: flush2, prop } = params;
          flush2(() => {
            context.set("value", []);
            const inputValue = match$2(prop("selectionBehavior"), {
              preserve: context.get("inputValue"),
              replace: prop("collection").stringifyMany([]),
              clear: ""
            });
            context.set("inputValue", inputValue);
          });
        },
        scrollContentToTop({ prop, scope }) {
          const scrollToIndexFn = prop("scrollToIndexFn");
          if (scrollToIndexFn) {
            const firstValue = prop("collection").firstValue;
            scrollToIndexFn({
              index: 0,
              immediate: true,
              getElement: () => getItemEl$3(scope, firstValue)
            });
          } else {
            const contentEl = getContentEl$6(scope);
            if (!contentEl) return;
            contentEl.scrollTop = 0;
          }
        },
        invokeOnOpen({ prop, event, context }) {
          const reason = getOpenChangeReason(event);
          prop("onOpenChange")?.({ open: true, reason, value: context.get("value") });
        },
        invokeOnClose({ prop, event, context }) {
          const reason = getOpenChangeReason(event);
          prop("onOpenChange")?.({ open: false, reason, value: context.get("value") });
        },
        highlightFirstItem({ context, prop, scope }) {
          const exec = getContentEl$6(scope) ? queueMicrotask : raf;
          exec(() => {
            const value = prop("collection").firstValue;
            if (value) context.set("highlightedValue", value);
          });
        },
        highlightFirstItemIfNeeded({ computed, action }) {
          if (!computed("autoHighlight")) return;
          action(["highlightFirstItem"]);
        },
        highlightLastItem({ context, prop, scope }) {
          const exec = getContentEl$6(scope) ? queueMicrotask : raf;
          exec(() => {
            const value = prop("collection").lastValue;
            if (value) context.set("highlightedValue", value);
          });
        },
        highlightNextItem({ context, prop }) {
          let value = null;
          const highlightedValue = context.get("highlightedValue");
          const collection2 = prop("collection");
          if (highlightedValue) {
            value = collection2.getNextValue(highlightedValue);
            if (!value && prop("loopFocus")) value = collection2.firstValue;
          } else {
            value = collection2.firstValue;
          }
          if (value) context.set("highlightedValue", value);
        },
        highlightPrevItem({ context, prop }) {
          let value = null;
          const highlightedValue = context.get("highlightedValue");
          const collection2 = prop("collection");
          if (highlightedValue) {
            value = collection2.getPreviousValue(highlightedValue);
            if (!value && prop("loopFocus")) value = collection2.lastValue;
          } else {
            value = collection2.lastValue;
          }
          if (value) context.set("highlightedValue", value);
        },
        highlightFirstSelectedItem({ context, prop }) {
          raf(() => {
            const [value] = prop("collection").sort(context.get("value"));
            if (value) context.set("highlightedValue", value);
          });
        },
        highlightFirstOrSelectedItem({ context, prop, computed }) {
          raf(() => {
            let value = null;
            if (computed("hasSelectedItems")) {
              value = prop("collection").sort(context.get("value"))[0];
            } else {
              value = prop("collection").firstValue;
            }
            if (value) context.set("highlightedValue", value);
          });
        },
        highlightLastOrSelectedItem({ context, prop, computed }) {
          raf(() => {
            const collection2 = prop("collection");
            let value = null;
            if (computed("hasSelectedItems")) {
              value = collection2.sort(context.get("value"))[0];
            } else {
              value = collection2.lastValue;
            }
            if (value) context.set("highlightedValue", value);
          });
        },
        autofillInputValue({ context, computed, prop, event, scope }) {
          const inputEl = getInputEl$2(scope);
          const collection2 = prop("collection");
          if (!computed("autoComplete") || !inputEl || !event.keypress) return;
          const valueText = collection2.stringify(context.get("highlightedValue"));
          raf(() => {
            inputEl.value = valueText || context.get("inputValue");
          });
        },
        syncSelectedItems(params) {
          queueMicrotask(() => {
            const { context, prop } = params;
            const collection2 = prop("collection");
            const value = context.get("value");
            const selectedItems = value.map((v) => {
              const item = context.get("selectedItems").find((item2) => collection2.getItemValue(item2) === v);
              return item || collection2.find(v);
            });
            context.set("selectedItems", selectedItems);
            const inputValue = match$2(prop("selectionBehavior"), {
              preserve: context.get("inputValue"),
              replace: collection2.stringifyMany(value),
              clear: ""
            });
            context.set("inputValue", inputValue);
          });
        },
        syncHighlightedItem({ context, prop }) {
          const item = prop("collection").find(context.get("highlightedValue"));
          context.set("highlightedItem", item);
        },
        toggleVisibility({ event, send, prop }) {
          send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
        }
      }
    }
  });
  function getOpenChangeReason(event) {
    return (event.previousEvent || event).src;
  }
  createProps$1()([
    "allowCustomValue",
    "autoFocus",
    "closeOnSelect",
    "collection",
    "composite",
    "defaultHighlightedValue",
    "defaultInputValue",
    "defaultOpen",
    "defaultValue",
    "dir",
    "disabled",
    "disableLayer",
    "form",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "inputBehavior",
    "inputValue",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "navigate",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onOpenChange",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "onValueChange",
    "open",
    "openOnChange",
    "openOnClick",
    "openOnKeyPress",
    "placeholder",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "selectionBehavior",
    "translations",
    "value",
    "alwaysSubmitOnEnter"
  ]);
  createProps$1()(["htmlFor"]);
  createProps$1()(["id"]);
  createProps$1()(["item", "persistFocus"]);
  const comboboxAnatomy$1 = anatomy$l.extendWith("empty");
  var anatomy$k = createAnatomy("dialog").parts(
    "trigger",
    "backdrop",
    "positioner",
    "content",
    "title",
    "description",
    "closeTrigger"
  );
  anatomy$k.build();
  createProps$1()([
    "aria-label",
    "closeOnEscape",
    "closeOnInteractOutside",
    "dir",
    "finalFocusEl",
    "getRootNode",
    "getRootNode",
    "id",
    "id",
    "ids",
    "initialFocusEl",
    "modal",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onRequestDismiss",
    "defaultOpen",
    "open",
    "persistentElements",
    "preventScroll",
    "restoreFocus",
    "role",
    "trapFocus"
  ]);
  var anatomy$j = createAnatomy("editable").parts(
    "root",
    "area",
    "label",
    "preview",
    "input",
    "editTrigger",
    "submitTrigger",
    "cancelTrigger",
    "control"
  );
  anatomy$j.build();
  createProps$1()([
    "activationMode",
    "autoResize",
    "dir",
    "disabled",
    "finalFocusEl",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEditChange",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "edit",
    "defaultEdit",
    "submitMode",
    "translations",
    "defaultValue",
    "value"
  ]);
  const fieldAnatomy$1 = createAnatomy("field").parts(
    "root",
    "errorText",
    "helperText",
    "input",
    "label",
    "select",
    "textarea",
    "requiredIndicator"
  );
  fieldAnatomy$1.build();
  function getVisualStyles(node2) {
    if (!node2) return;
    const style = getComputedStyle$3(node2);
    return "box-sizing:" + style.boxSizing + ";border-left:" + style.borderLeftWidth + " solid red;border-right:" + style.borderRightWidth + " solid red;font-family:" + style.fontFamily + ";font-feature-settings:" + style.fontFeatureSettings + ";font-kerning:" + style.fontKerning + ";font-size:" + style.fontSize + ";font-stretch:" + style.fontStretch + ";font-style:" + style.fontStyle + ";font-variant:" + style.fontVariant + ";font-variant-caps:" + style.fontVariantCaps + ";font-variant-ligatures:" + style.fontVariantLigatures + ";font-variant-numeric:" + style.fontVariantNumeric + ";font-weight:" + style.fontWeight + ";letter-spacing:" + style.letterSpacing + ";margin-left:" + style.marginLeft + ";margin-right:" + style.marginRight + ";padding-left:" + style.paddingLeft + ";padding-right:" + style.paddingRight + ";text-indent:" + style.textIndent + ";text-transform:" + style.textTransform;
  }
  function createGhostElement(doc) {
    var el = doc.createElement("div");
    el.id = "ghost";
    el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
    doc.body.appendChild(el);
    return el;
  }
  function autoResizeInput(input) {
    if (!input) return;
    const doc = getDocument(input);
    const win = getWindow$1(input);
    const ghost = createGhostElement(doc);
    const cssText = getVisualStyles(input);
    if (cssText) ghost.style.cssText += cssText;
    function resize() {
      win.requestAnimationFrame(() => {
        ghost.innerHTML = input.value;
        const rect = win.getComputedStyle(ghost);
        input?.style.setProperty("width", rect.width);
      });
    }
    resize();
    input?.addEventListener("input", resize);
    input?.addEventListener("change", resize);
    return () => {
      doc.body.removeChild(ghost);
      input?.removeEventListener("input", resize);
      input?.removeEventListener("change", resize);
    };
  }
  const fieldsetAnatomy$1 = createAnatomy("fieldset").parts("root", "errorText", "helperText", "legend");
  fieldsetAnatomy$1.build();
  var anatomy$i = createAnatomy("file-upload").parts(
    "root",
    "dropzone",
    "item",
    "itemDeleteTrigger",
    "itemGroup",
    "itemName",
    "itemPreview",
    "itemPreviewImage",
    "itemSizeText",
    "label",
    "trigger",
    "clearTrigger"
  );
  anatomy$i.build();
  createProps$1()([
    "accept",
    "acceptedFiles",
    "allowDrop",
    "capture",
    "defaultAcceptedFiles",
    "dir",
    "directory",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "preventDocumentDrop",
    "required",
    "transformFiles",
    "translations",
    "validate"
  ]);
  createProps$1()(["file", "type"]);
  var anatomy$h = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
  anatomy$h.build();
  var getTriggerId$4 = (ctx) => ctx.ids?.trigger ?? `hover-card:${ctx.id}:trigger`;
  var getContentId$5 = (ctx) => ctx.ids?.content ?? `hover-card:${ctx.id}:content`;
  var getPositionerId$3 = (ctx) => ctx.ids?.positioner ?? `hover-card:${ctx.id}:popper`;
  var getTriggerEl$4 = (ctx) => ctx.getById(getTriggerId$4(ctx));
  var getContentEl$5 = (ctx) => ctx.getById(getContentId$5(ctx));
  var getPositionerEl$3 = (ctx) => ctx.getById(getPositionerId$3(ctx));
  var { not: not$5, and: and$6 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        disabled: false,
        openDelay: 600,
        closeDelay: 300,
        ...props2,
        positioning: {
          placement: "bottom",
          ...props2.positioning
        }
      };
    },
    initialState({ prop }) {
      const open = prop("open") || prop("defaultOpen");
      return open ? "open" : "closed";
    },
    context({ prop, bindable }) {
      return {
        open: bindable(() => ({
          defaultValue: prop("defaultOpen"),
          value: prop("open"),
          onChange(value) {
            prop("onOpenChange")?.({ open: value });
          }
        })),
        currentPlacement: bindable(() => ({
          defaultValue: void 0
        })),
        isPointer: bindable(() => ({
          defaultValue: false
        }))
      };
    },
    watch({ track, context, action, prop, send }) {
      track([() => prop("disabled")], () => {
        if (prop("disabled")) {
          send({ type: "CLOSE", src: "disabled.change" });
        }
      });
      track([() => context.get("open")], () => {
        action(["toggleVisibility"]);
      });
    },
    states: {
      closed: {
        tags: ["closed"],
        entry: ["clearIsPointer"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open"
          },
          POINTER_ENTER: {
            target: "opening",
            actions: ["setIsPointer"]
          },
          TRIGGER_FOCUS: {
            target: "opening"
          },
          OPEN: {
            target: "opening"
          }
        }
      },
      opening: {
        tags: ["closed"],
        effects: ["waitForOpenDelay"],
        on: {
          OPEN_DELAY: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ],
          "CONTROLLED.OPEN": {
            target: "open"
          },
          "CONTROLLED.CLOSE": {
            target: "closed"
          },
          POINTER_LEAVE: [
            {
              guard: "isOpenControlled",
actions: ["invokeOnClose", "toggleVisibility"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          TRIGGER_BLUR: [
            {
              guard: and$6("isOpenControlled", not$5("isPointer")),
actions: ["invokeOnClose", "toggleVisibility"]
            },
            {
              guard: not$5("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
actions: ["invokeOnClose", "toggleVisibility"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ]
        }
      },
      open: {
        tags: ["open"],
        effects: ["trackDismissableElement", "trackPositioning"],
        on: {
          "CONTROLLED.CLOSE": {
            target: "closed"
          },
          POINTER_ENTER: {
            actions: ["setIsPointer"]
          },
          POINTER_LEAVE: {
            target: "closing"
          },
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          TRIGGER_BLUR: [
            {
              guard: and$6("isOpenControlled", not$5("isPointer")),
              actions: ["invokeOnClose"]
            },
            {
              guard: not$5("isPointer"),
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "POSITIONING.SET": {
            actions: ["reposition"]
          }
        }
      },
      closing: {
        tags: ["open"],
        effects: ["trackPositioning", "waitForCloseDelay"],
        on: {
          CLOSE_DELAY: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "CONTROLLED.CLOSE": {
            target: "closed"
          },
          "CONTROLLED.OPEN": {
            target: "open"
          },
          POINTER_ENTER: {
            target: "open",
actions: ["setIsPointer"]
          }
        }
      }
    },
    implementations: {
      guards: {
        isPointer: ({ context }) => !!context.get("isPointer"),
        isOpenControlled: ({ prop }) => prop("open") != null
      },
      effects: {
        waitForOpenDelay({ send, prop }) {
          const id2 = setTimeout(() => {
            send({ type: "OPEN_DELAY" });
          }, prop("openDelay"));
          return () => clearTimeout(id2);
        },
        waitForCloseDelay({ send, prop }) {
          const id2 = setTimeout(() => {
            send({ type: "CLOSE_DELAY" });
          }, prop("closeDelay"));
          return () => clearTimeout(id2);
        },
        trackPositioning({ context, prop, scope }) {
          if (!context.get("currentPlacement")) {
            context.set("currentPlacement", prop("positioning").placement);
          }
          const getPositionerEl2 = () => getPositionerEl$3(scope);
          return getPlacement(getTriggerEl$4(scope), getPositionerEl2, {
            ...prop("positioning"),
            defer: true,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        trackDismissableElement({ send, scope, prop }) {
          const getContentEl2 = () => getContentEl$5(scope);
          return trackDismissableElement(getContentEl2, {
            type: "popover",
            defer: true,
            exclude: [getTriggerEl$4(scope)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onInteractOutside: prop("onInteractOutside"),
            onPointerDownOutside: prop("onPointerDownOutside"),
            onFocusOutside(event) {
              event.preventDefault();
              prop("onFocusOutside")?.(event);
            }
          });
        }
      },
      actions: {
        invokeOnClose({ prop }) {
          prop("onOpenChange")?.({ open: false });
        },
        invokeOnOpen({ prop }) {
          prop("onOpenChange")?.({ open: true });
        },
        setIsPointer({ context }) {
          context.set("isPointer", true);
        },
        clearIsPointer({ context }) {
          context.set("isPointer", false);
        },
        reposition({ context, prop, scope, event }) {
          const getPositionerEl2 = () => getPositionerEl$3(scope);
          getPlacement(getTriggerEl$4(scope), getPositionerEl2, {
            ...prop("positioning"),
            ...event.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        toggleVisibility({ prop, event, send }) {
          queueMicrotask(() => {
            send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
          });
        }
      }
    }
  });
  createProps$1()([
    "closeDelay",
    "dir",
    "getRootNode",
    "id",
    "ids",
    "disabled",
    "onOpenChange",
    "defaultOpen",
    "open",
    "openDelay",
    "positioning",
    "onInteractOutside",
    "onPointerDownOutside",
    "onFocusOutside"
  ]);
  var anatomy$g = createAnatomy("tree-view").parts(
    "branch",
    "branchContent",
    "branchControl",
    "branchIndentGuide",
    "branchIndicator",
    "branchText",
    "branchTrigger",
    "item",
    "itemIndicator",
    "itemText",
    "label",
    "nodeCheckbox",
    "nodeRenameInput",
    "root",
    "tree"
  );
  anatomy$g.build();
  var collection$2 = (options) => {
    return new TreeCollection(options);
  };
  collection$2.empty = () => {
    return new TreeCollection({ rootNode: { children: [] } });
  };
  var getNodeId = (ctx, value) => ctx.ids?.node?.(value) ?? `tree:${ctx.id}:node:${value}`;
  var focusNode = (ctx, value) => {
    if (value == null) return;
    ctx.getById(getNodeId(ctx, value))?.focus();
  };
  var getRenameInputId = (ctx, value) => `tree:${ctx.id}:rename-input:${value}`;
  var getRenameInputEl = (ctx, value) => {
    return ctx.getById(getRenameInputId(ctx, value));
  };
  function toggleBranchChecked(collection2, value, checkedValue) {
    const childValues = collection2.getDescendantValues(value);
    const allChecked = childValues.every((child) => checkedValue.includes(child));
    return uniq(allChecked ? remove$1(checkedValue, ...childValues) : add$1(checkedValue, ...childValues));
  }
  function expandBranches(params, values) {
    const { context, prop, refs } = params;
    if (!prop("loadChildren")) {
      context.set("expandedValue", (prev2) => uniq(add$1(prev2, ...values)));
      return;
    }
    const loadingStatus = context.get("loadingStatus");
    const [loadedValues, loadingValues] = partition(values, (value) => loadingStatus[value] === "loaded");
    if (loadedValues.length > 0) {
      context.set("expandedValue", (prev2) => uniq(add$1(prev2, ...loadedValues)));
    }
    if (loadingValues.length === 0) return;
    const collection2 = prop("collection");
    const [nodeWithChildren, nodeWithoutChildren] = partition(loadingValues, (id2) => {
      const node2 = collection2.findNode(id2);
      return collection2.getNodeChildren(node2).length > 0;
    });
    if (nodeWithChildren.length > 0) {
      context.set("expandedValue", (prev2) => uniq(add$1(prev2, ...nodeWithChildren)));
    }
    if (nodeWithoutChildren.length === 0) return;
    context.set("loadingStatus", (prev2) => ({
      ...prev2,
      ...nodeWithoutChildren.reduce((acc, id2) => ({ ...acc, [id2]: "loading" }), {})
    }));
    const nodesToLoad = nodeWithoutChildren.map((id2) => {
      const indexPath = collection2.getIndexPath(id2);
      const valuePath = collection2.getValuePath(indexPath);
      const node2 = collection2.findNode(id2);
      return { id: id2, indexPath, valuePath, node: node2 };
    });
    const pendingAborts = refs.get("pendingAborts");
    const loadChildren = prop("loadChildren");
    ensure(loadChildren, () => "[zag-js/tree-view] `loadChildren` is required for async expansion");
    const proms = nodesToLoad.map(({ id: id2, indexPath, valuePath, node: node2 }) => {
      const existingAbort = pendingAborts.get(id2);
      if (existingAbort) {
        existingAbort.abort();
        pendingAborts.delete(id2);
      }
      const abortController = new AbortController();
      pendingAborts.set(id2, abortController);
      return loadChildren({
        valuePath,
        indexPath,
        node: node2,
        signal: abortController.signal
      });
    });
    Promise.allSettled(proms).then((results) => {
      const loadedValues2 = [];
      const nodeWithErrors = [];
      const nextLoadingStatus = context.get("loadingStatus");
      let collection3 = prop("collection");
      results.forEach((result, index) => {
        const { id: id2, indexPath, node: node2, valuePath } = nodesToLoad[index];
        if (result.status === "fulfilled") {
          nextLoadingStatus[id2] = "loaded";
          loadedValues2.push(id2);
          collection3 = collection3.replace(indexPath, { ...node2, children: result.value });
        } else {
          pendingAborts.delete(id2);
          Reflect.deleteProperty(nextLoadingStatus, id2);
          nodeWithErrors.push({ node: node2, error: result.reason, indexPath, valuePath });
        }
      });
      context.set("loadingStatus", nextLoadingStatus);
      if (loadedValues2.length) {
        context.set("expandedValue", (prev2) => uniq(add$1(prev2, ...loadedValues2)));
        prop("onLoadChildrenComplete")?.({ collection: collection3 });
      }
      if (nodeWithErrors.length) {
        prop("onLoadChildrenError")?.({ nodes: nodeWithErrors });
      }
    });
  }
  function skipFn(params) {
    const { prop, context } = params;
    return function skip({ indexPath }) {
      const paths = prop("collection").getValuePath(indexPath).slice(0, -1);
      return paths.some((value) => !context.get("expandedValue").includes(value));
    };
  }
  var { and: and$5 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        selectionMode: "single",
        collection: collection$2.empty(),
        typeahead: true,
        expandOnClick: true,
        defaultExpandedValue: [],
        defaultSelectedValue: [],
        ...props2
      };
    },
    initialState() {
      return "idle";
    },
    context({ prop, bindable, getContext }) {
      return {
        expandedValue: bindable(() => ({
          defaultValue: prop("defaultExpandedValue"),
          value: prop("expandedValue"),
          isEqual,
          onChange(expandedValue) {
            const ctx = getContext();
            const focusedValue = ctx.get("focusedValue");
            prop("onExpandedChange")?.({
              expandedValue,
              focusedValue,
              get expandedNodes() {
                return prop("collection").findNodes(expandedValue);
              }
            });
          }
        })),
        selectedValue: bindable(() => ({
          defaultValue: prop("defaultSelectedValue"),
          value: prop("selectedValue"),
          isEqual,
          onChange(selectedValue) {
            const ctx = getContext();
            const focusedValue = ctx.get("focusedValue");
            prop("onSelectionChange")?.({
              selectedValue,
              focusedValue,
              get selectedNodes() {
                return prop("collection").findNodes(selectedValue);
              }
            });
          }
        })),
        focusedValue: bindable(() => ({
          defaultValue: prop("defaultFocusedValue") || null,
          value: prop("focusedValue"),
          onChange(focusedValue) {
            prop("onFocusChange")?.({
              focusedValue,
              get focusedNode() {
                return focusedValue ? prop("collection").findNode(focusedValue) : null;
              }
            });
          }
        })),
        loadingStatus: bindable(() => ({
          defaultValue: {}
        })),
        checkedValue: bindable(() => ({
          defaultValue: prop("defaultCheckedValue") || [],
          value: prop("checkedValue"),
          isEqual,
          onChange(value) {
            prop("onCheckedChange")?.({ checkedValue: value });
          }
        })),
        renamingValue: bindable(() => ({
          sync: true,
          defaultValue: null
        }))
      };
    },
    refs() {
      return {
        typeaheadState: { ...getByTypeahead.defaultOptions },
        pendingAborts: new Map()
      };
    },
    computed: {
      isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
      isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar.length > 0,
      visibleNodes: ({ prop, context }) => {
        const nodes = [];
        prop("collection").visit({
          skip: skipFn({ prop, context }),
          onEnter: (node2, indexPath) => {
            nodes.push({ node: node2, indexPath });
          }
        });
        return nodes;
      }
    },
    on: {
      "EXPANDED.SET": {
        actions: ["setExpanded"]
      },
      "EXPANDED.CLEAR": {
        actions: ["clearExpanded"]
      },
      "EXPANDED.ALL": {
        actions: ["expandAllBranches"]
      },
      "BRANCH.EXPAND": {
        actions: ["expandBranches"]
      },
      "BRANCH.COLLAPSE": {
        actions: ["collapseBranches"]
      },
      "SELECTED.SET": {
        actions: ["setSelected"]
      },
      "SELECTED.ALL": [
        {
          guard: and$5("isMultipleSelection", "moveFocus"),
          actions: ["selectAllNodes", "focusTreeLastNode"]
        },
        {
          guard: "isMultipleSelection",
          actions: ["selectAllNodes"]
        }
      ],
      "SELECTED.CLEAR": {
        actions: ["clearSelected"]
      },
      "NODE.SELECT": {
        actions: ["selectNode"]
      },
      "NODE.DESELECT": {
        actions: ["deselectNode"]
      },
      "CHECKED.TOGGLE": {
        actions: ["toggleChecked"]
      },
      "CHECKED.SET": {
        actions: ["setChecked"]
      },
      "CHECKED.CLEAR": {
        actions: ["clearChecked"]
      },
      "NODE.FOCUS": {
        actions: ["setFocusedNode"]
      },
      "NODE.ARROW_DOWN": [
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["focusTreeNextNode", "extendSelectionToNextNode"]
        },
        {
          actions: ["focusTreeNextNode"]
        }
      ],
      "NODE.ARROW_UP": [
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["focusTreePrevNode", "extendSelectionToPrevNode"]
        },
        {
          actions: ["focusTreePrevNode"]
        }
      ],
      "NODE.ARROW_LEFT": {
        actions: ["focusBranchNode"]
      },
      "BRANCH_NODE.ARROW_LEFT": [
        {
          guard: "isBranchExpanded",
          actions: ["collapseBranch"]
        },
        {
          actions: ["focusBranchNode"]
        }
      ],
      "BRANCH_NODE.ARROW_RIGHT": [
        {
          guard: and$5("isBranchFocused", "isBranchExpanded"),
          actions: ["focusBranchFirstNode"]
        },
        {
          actions: ["expandBranch"]
        }
      ],
      "SIBLINGS.EXPAND": {
        actions: ["expandSiblingBranches"]
      },
      "NODE.HOME": [
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["extendSelectionToFirstNode", "focusTreeFirstNode"]
        },
        {
          actions: ["focusTreeFirstNode"]
        }
      ],
      "NODE.END": [
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["extendSelectionToLastNode", "focusTreeLastNode"]
        },
        {
          actions: ["focusTreeLastNode"]
        }
      ],
      "NODE.CLICK": [
        {
          guard: and$5("isCtrlKey", "isMultipleSelection"),
          actions: ["toggleNodeSelection"]
        },
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["extendSelectionToNode"]
        },
        {
          actions: ["selectNode"]
        }
      ],
      "BRANCH_NODE.CLICK": [
        {
          guard: and$5("isCtrlKey", "isMultipleSelection"),
          actions: ["toggleNodeSelection"]
        },
        {
          guard: and$5("isShiftKey", "isMultipleSelection"),
          actions: ["extendSelectionToNode"]
        },
        {
          guard: "expandOnClick",
          actions: ["selectNode", "toggleBranchNode"]
        },
        {
          actions: ["selectNode"]
        }
      ],
      "BRANCH_TOGGLE.CLICK": {
        actions: ["toggleBranchNode"]
      },
      "TREE.TYPEAHEAD": {
        actions: ["focusMatchedNode"]
      }
    },
    exit: ["clearPendingAborts"],
    states: {
      idle: {
        on: {
          "NODE.RENAME": {
            target: "renaming",
            actions: ["setRenamingValue"]
          }
        }
      },
      renaming: {
        entry: ["syncRenameInput", "focusRenameInput"],
        on: {
          "RENAME.SUBMIT": {
            guard: "isRenameLabelValid",
            target: "idle",
            actions: ["submitRenaming"]
          },
          "RENAME.CANCEL": {
            target: "idle",
            actions: ["cancelRenaming"]
          }
        }
      }
    },
    implementations: {
      guards: {
        isBranchFocused: ({ context, event }) => context.get("focusedValue") === event.id,
        isBranchExpanded: ({ context, event }) => context.get("expandedValue").includes(event.id),
        isShiftKey: ({ event }) => event.shiftKey,
        isCtrlKey: ({ event }) => event.ctrlKey,
        hasSelectedItems: ({ context }) => context.get("selectedValue").length > 0,
        isMultipleSelection: ({ prop }) => prop("selectionMode") === "multiple",
        moveFocus: ({ event }) => !!event.moveFocus,
        expandOnClick: ({ prop }) => !!prop("expandOnClick"),
        isRenameLabelValid: ({ event }) => event.label.trim() !== ""
      },
      actions: {
        selectNode({ context, event }) {
          const value = event.id || event.value;
          context.set("selectedValue", (prev2) => {
            if (value == null) return prev2;
            if (!event.isTrusted && isArray(value)) return prev2.concat(...value);
            return [isArray(value) ? last(value) : value].filter(Boolean);
          });
        },
        deselectNode({ context, event }) {
          const value = toArray(event.id || event.value);
          context.set("selectedValue", (prev2) => remove$1(prev2, ...value));
        },
        setFocusedNode({ context, event }) {
          context.set("focusedValue", event.id);
        },
        clearFocusedNode({ context }) {
          context.set("focusedValue", null);
        },
        clearSelectedItem({ context }) {
          context.set("selectedValue", []);
        },
        toggleBranchNode({ context, event, action }) {
          const isExpanded = context.get("expandedValue").includes(event.id);
          action(isExpanded ? ["collapseBranch"] : ["expandBranch"]);
        },
        expandBranch(params) {
          const { event } = params;
          expandBranches(params, [event.id]);
        },
        expandBranches(params) {
          const { context, event } = params;
          const valuesToExpand = toArray(event.value);
          expandBranches(params, diff$1(valuesToExpand, context.get("expandedValue")));
        },
        collapseBranch({ context, event }) {
          context.set("expandedValue", (prev2) => remove$1(prev2, event.id));
        },
        collapseBranches(params) {
          const { context, event } = params;
          const value = toArray(event.value);
          context.set("expandedValue", (prev2) => remove$1(prev2, ...value));
        },
        setExpanded({ context, event }) {
          if (!isArray(event.value)) return;
          context.set("expandedValue", event.value);
        },
        clearExpanded({ context }) {
          context.set("expandedValue", []);
        },
        setSelected({ context, event }) {
          if (!isArray(event.value)) return;
          context.set("selectedValue", event.value);
        },
        clearSelected({ context }) {
          context.set("selectedValue", []);
        },
        focusTreeFirstNode({ prop, scope }) {
          const collection2 = prop("collection");
          const firstNode = collection2.getFirstNode();
          const firstValue = collection2.getNodeValue(firstNode);
          focusNode(scope, firstValue);
        },
        focusTreeLastNode(params) {
          const { prop, scope } = params;
          const collection2 = prop("collection");
          const lastNode = collection2.getLastNode(void 0, { skip: skipFn(params) });
          const lastValue = collection2.getNodeValue(lastNode);
          focusNode(scope, lastValue);
        },
        focusBranchFirstNode({ event, prop, scope }) {
          const collection2 = prop("collection");
          const branchNode = collection2.findNode(event.id);
          const firstNode = collection2.getFirstNode(branchNode);
          const firstValue = collection2.getNodeValue(firstNode);
          focusNode(scope, firstValue);
        },
        focusTreeNextNode(params) {
          const { event, prop, scope } = params;
          const collection2 = prop("collection");
          const nextNode = collection2.getNextNode(event.id, { skip: skipFn(params) });
          if (!nextNode) return;
          const nextValue = collection2.getNodeValue(nextNode);
          focusNode(scope, nextValue);
        },
        focusTreePrevNode(params) {
          const { event, prop, scope } = params;
          const collection2 = prop("collection");
          const prevNode = collection2.getPreviousNode(event.id, { skip: skipFn(params) });
          if (!prevNode) return;
          const prevValue = collection2.getNodeValue(prevNode);
          focusNode(scope, prevValue);
        },
        focusBranchNode({ event, prop, scope }) {
          const collection2 = prop("collection");
          const parentNode = collection2.getParentNode(event.id);
          const parentValue = parentNode ? collection2.getNodeValue(parentNode) : void 0;
          focusNode(scope, parentValue);
        },
        selectAllNodes({ context, prop }) {
          context.set("selectedValue", prop("collection").getValues());
        },
        focusMatchedNode(params) {
          const { context, prop, refs, event, scope, computed } = params;
          const nodes = computed("visibleNodes");
          const elements = nodes.map(({ node: node22 }) => ({
            textContent: prop("collection").stringifyNode(node22),
            id: prop("collection").getNodeValue(node22)
          }));
          const node2 = getByTypeahead(elements, {
            state: refs.get("typeaheadState"),
            activeId: context.get("focusedValue"),
            key: event.key
          });
          focusNode(scope, node2?.id);
        },
        toggleNodeSelection({ context, event }) {
          const selectedValue = addOrRemove(context.get("selectedValue"), event.id);
          context.set("selectedValue", selectedValue);
        },
        expandAllBranches(params) {
          const { context, prop } = params;
          const branchValues = prop("collection").getBranchValues();
          const valuesToExpand = diff$1(branchValues, context.get("expandedValue"));
          expandBranches(params, valuesToExpand);
        },
        expandSiblingBranches(params) {
          const { context, event, prop } = params;
          const collection2 = prop("collection");
          const indexPath = collection2.getIndexPath(event.id);
          if (!indexPath) return;
          const nodes = collection2.getSiblingNodes(indexPath);
          const values = nodes.map((node2) => collection2.getNodeValue(node2));
          const valuesToExpand = diff$1(values, context.get("expandedValue"));
          expandBranches(params, valuesToExpand);
        },
        extendSelectionToNode(params) {
          const { context, event, prop, computed } = params;
          const collection2 = prop("collection");
          const anchorValue = first(context.get("selectedValue")) || collection2.getNodeValue(collection2.getFirstNode());
          const targetValue = event.id;
          let values = [anchorValue, targetValue];
          let hits = 0;
          const visibleNodes = computed("visibleNodes");
          visibleNodes.forEach(({ node: node2 }) => {
            const nodeValue = collection2.getNodeValue(node2);
            if (hits === 1) values.push(nodeValue);
            if (nodeValue === anchorValue || nodeValue === targetValue) hits++;
          });
          context.set("selectedValue", uniq(values));
        },
        extendSelectionToNextNode(params) {
          const { context, event, prop } = params;
          const collection2 = prop("collection");
          const nextNode = collection2.getNextNode(event.id, { skip: skipFn(params) });
          if (!nextNode) return;
          const values = new Set(context.get("selectedValue"));
          const nextValue = collection2.getNodeValue(nextNode);
          if (nextValue == null) return;
          if (values.has(event.id) && values.has(nextValue)) {
            values.delete(event.id);
          } else if (!values.has(nextValue)) {
            values.add(nextValue);
          }
          context.set("selectedValue", Array.from(values));
        },
        extendSelectionToPrevNode(params) {
          const { context, event, prop } = params;
          const collection2 = prop("collection");
          const prevNode = collection2.getPreviousNode(event.id, { skip: skipFn(params) });
          if (!prevNode) return;
          const values = new Set(context.get("selectedValue"));
          const prevValue = collection2.getNodeValue(prevNode);
          if (prevValue == null) return;
          if (values.has(event.id) && values.has(prevValue)) {
            values.delete(event.id);
          } else if (!values.has(prevValue)) {
            values.add(prevValue);
          }
          context.set("selectedValue", Array.from(values));
        },
        extendSelectionToFirstNode(params) {
          const { context, prop } = params;
          const collection2 = prop("collection");
          const currentSelection = first(context.get("selectedValue"));
          const values = [];
          collection2.visit({
            skip: skipFn(params),
            onEnter: (node2) => {
              const nodeValue = collection2.getNodeValue(node2);
              values.push(nodeValue);
              if (nodeValue === currentSelection) {
                return "stop";
              }
            }
          });
          context.set("selectedValue", values);
        },
        extendSelectionToLastNode(params) {
          const { context, prop } = params;
          const collection2 = prop("collection");
          const currentSelection = first(context.get("selectedValue"));
          const values = [];
          let current = false;
          collection2.visit({
            skip: skipFn(params),
            onEnter: (node2) => {
              const nodeValue = collection2.getNodeValue(node2);
              if (nodeValue === currentSelection) current = true;
              if (current) values.push(nodeValue);
            }
          });
          context.set("selectedValue", values);
        },
        clearPendingAborts({ refs }) {
          const aborts = refs.get("pendingAborts");
          aborts.forEach((abort) => abort.abort());
          aborts.clear();
        },
        toggleChecked({ context, event, prop }) {
          const collection2 = prop("collection");
          context.set(
            "checkedValue",
            (prev2) => event.isBranch ? toggleBranchChecked(collection2, event.value, prev2) : addOrRemove(prev2, event.value)
          );
        },
        setChecked({ context, event }) {
          context.set("checkedValue", event.value);
        },
        clearChecked({ context }) {
          context.set("checkedValue", []);
        },
        setRenamingValue({ context, event, prop }) {
          context.set("renamingValue", event.value);
          const onRenameStartFn = prop("onRenameStart");
          if (onRenameStartFn) {
            const collection2 = prop("collection");
            const indexPath = collection2.getIndexPath(event.value);
            if (indexPath) {
              const node2 = collection2.at(indexPath);
              if (node2) {
                onRenameStartFn({
                  value: event.value,
                  node: node2,
                  indexPath
                });
              }
            }
          }
        },
        submitRenaming({ context, event, prop, scope }) {
          const renamingValue = context.get("renamingValue");
          if (!renamingValue) return;
          const collection2 = prop("collection");
          const indexPath = collection2.getIndexPath(renamingValue);
          if (!indexPath) return;
          const trimmedLabel = event.label.trim();
          const onBeforeRenameFn = prop("onBeforeRename");
          if (onBeforeRenameFn) {
            const details = {
              value: renamingValue,
              label: trimmedLabel,
              indexPath
            };
            const shouldRename = onBeforeRenameFn(details);
            if (!shouldRename) {
              context.set("renamingValue", null);
              focusNode(scope, renamingValue);
              return;
            }
          }
          prop("onRenameComplete")?.({
            value: renamingValue,
            label: trimmedLabel,
            indexPath
          });
          context.set("renamingValue", null);
          focusNode(scope, renamingValue);
        },
        cancelRenaming({ context, scope }) {
          const renamingValue = context.get("renamingValue");
          context.set("renamingValue", null);
          if (renamingValue) {
            focusNode(scope, renamingValue);
          }
        },
        syncRenameInput({ context, scope, prop }) {
          const renamingValue = context.get("renamingValue");
          if (!renamingValue) return;
          const collection2 = prop("collection");
          const node2 = collection2.findNode(renamingValue);
          if (!node2) return;
          const label = collection2.stringifyNode(node2);
          const inputEl = getRenameInputEl(scope, renamingValue);
          setElementValue(inputEl, label);
        },
        focusRenameInput({ context, scope }) {
          const renamingValue = context.get("renamingValue");
          if (!renamingValue) return;
          const inputEl = getRenameInputEl(scope, renamingValue);
          if (!inputEl) return;
          inputEl.focus();
          inputEl.select();
        }
      }
    }
  });
  createProps$1()([
    "ids",
    "collection",
    "dir",
    "expandedValue",
    "expandOnClick",
    "defaultFocusedValue",
    "focusedValue",
    "getRootNode",
    "id",
    "onExpandedChange",
    "onFocusChange",
    "onSelectionChange",
    "checkedValue",
    "selectedValue",
    "selectionMode",
    "typeahead",
    "defaultExpandedValue",
    "defaultSelectedValue",
    "defaultCheckedValue",
    "onCheckedChange",
    "onLoadChildrenComplete",
    "onLoadChildrenError",
    "loadChildren",
    "canRename",
    "onRenameStart",
    "onBeforeRename",
    "onRenameComplete"
  ]);
  createProps$1()(["node", "indexPath"]);
  var anatomy$f = createAnatomy("listbox").parts(
    "label",
    "input",
    "item",
    "itemText",
    "itemIndicator",
    "itemGroup",
    "itemGroupLabel",
    "content",
    "root",
    "valueText"
  );
  anatomy$f.build();
  var collection$1 = (options) => {
    return new ListCollection(options);
  };
  collection$1.empty = () => {
    return new ListCollection({ items: [] });
  };
  var getContentId$4 = (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`;
  var getItemId$3 = (ctx, id2) => ctx.ids?.item?.(id2) ?? `select:${ctx.id}:option:${id2}`;
  var getContentEl$4 = (ctx) => ctx.getById(getContentId$4(ctx));
  var getItemEl$2 = (ctx, id2) => ctx.getById(getItemId$3(ctx, id2));
  var { guards: guards$1, createMachine: createMachine$2 } = setup();
  var { or: or$3 } = guards$1;
  createMachine$2({
    props({ props: props2 }) {
      return {
        loopFocus: false,
        composite: true,
        defaultValue: [],
        multiple: false,
        typeahead: true,
        collection: collection$1.empty(),
        orientation: "vertical",
        selectionMode: "single",
        ...props2
      };
    },
    context({ prop, bindable }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          isEqual,
          onChange(value) {
            const items = prop("collection").findMany(value);
            return prop("onValueChange")?.({ value, items });
          }
        })),
        highlightedValue: bindable(() => ({
          defaultValue: prop("defaultHighlightedValue") || null,
          value: prop("highlightedValue"),
          sync: true,
          onChange(value) {
            prop("onHighlightChange")?.({
              highlightedValue: value,
              highlightedItem: prop("collection").find(value),
              highlightedIndex: prop("collection").indexOf(value)
            });
          }
        })),
        highlightedItem: bindable(() => ({
          defaultValue: null
        })),
        selectedItems: bindable(() => {
          const value = prop("value") ?? prop("defaultValue") ?? [];
          const items = prop("collection").findMany(value);
          return { defaultValue: items };
        }),
        focused: bindable(() => ({
          sync: true,
          defaultValue: false
        }))
      };
    },
    refs() {
      return {
        typeahead: { ...getByTypeahead.defaultOptions },
        focusVisible: false
      };
    },
    computed: {
      hasSelectedItems: ({ context }) => context.get("value").length > 0,
      isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
      isInteractive: ({ prop }) => !prop("disabled"),
      selection: ({ context, prop }) => {
        const selection = new Selection(context.get("value"));
        selection.selectionMode = prop("selectionMode");
        selection.deselectable = !!prop("deselectable");
        return selection;
      },
      multiple: ({ prop }) => prop("selectionMode") === "multiple" || prop("selectionMode") === "extended",
      valueAsString: ({ context, prop }) => prop("collection").stringifyItems(context.get("selectedItems"))
    },
    initialState() {
      return "idle";
    },
    watch({ context, prop, track, action }) {
      track([() => context.get("value").toString()], () => {
        action(["syncSelectedItems"]);
      });
      track([() => context.get("highlightedValue")], () => {
        action(["syncHighlightedItem"]);
      });
      track([() => prop("collection").toString()], () => {
        action(["syncHighlightedValue"]);
      });
    },
    effects: ["trackFocusVisible"],
    on: {
      "HIGHLIGHTED_VALUE.SET": {
        actions: ["setHighlightedItem"]
      },
      "ITEM.SELECT": {
        actions: ["selectItem"]
      },
      "ITEM.CLEAR": {
        actions: ["clearItem"]
      },
      "VALUE.SET": {
        actions: ["setSelectedItems"]
      },
      "VALUE.CLEAR": {
        actions: ["clearSelectedItems"]
      }
    },
    states: {
      idle: {
        effects: ["scrollToHighlightedItem"],
        on: {
          "INPUT.FOCUS": {
            actions: ["setFocused"]
          },
          "CONTENT.FOCUS": [
            {
              guard: or$3("hasSelectedValue", "hasHighlightedValue"),
              actions: ["setFocused"]
            },
            {
              actions: ["setFocused", "setDefaultHighlightedValue"]
            }
          ],
          "CONTENT.BLUR": {
            actions: ["clearFocused"]
          },
          "ITEM.CLICK": {
            actions: ["setHighlightedItem", "selectHighlightedItem"]
          },
          "CONTENT.TYPEAHEAD": {
            actions: ["setFocused", "highlightMatchingItem"]
          },
          "ITEM.POINTER_MOVE": {
            actions: ["highlightItem"]
          },
          "ITEM.POINTER_LEAVE": {
            actions: ["clearHighlightedItem"]
          },
          NAVIGATE: {
            actions: ["setFocused", "setHighlightedItem", "selectWithKeyboard"]
          }
        }
      }
    },
    implementations: {
      guards: {
        hasSelectedValue: ({ context }) => context.get("value").length > 0,
        hasHighlightedValue: ({ context }) => context.get("highlightedValue") != null
      },
      effects: {
        trackFocusVisible: ({ scope, refs }) => {
          return trackFocusVisible({
            root: scope.getRootNode?.(),
            onChange(details) {
              refs.set("focusVisible", details.isFocusVisible);
            }
          });
        },
        scrollToHighlightedItem({ context, prop, scope }) {
          const exec = (immediate) => {
            const highlightedValue = context.get("highlightedValue");
            if (highlightedValue == null) return;
            const modality = getInteractionModality();
            if (modality !== "keyboard") return;
            const contentEl2 = getContentEl$4(scope);
            const scrollToIndexFn = prop("scrollToIndexFn");
            if (scrollToIndexFn) {
              const highlightedIndex = prop("collection").indexOf(highlightedValue);
              scrollToIndexFn?.({
                index: highlightedIndex,
                immediate,
                getElement() {
                  return getItemEl$2(scope, highlightedValue);
                }
              });
              return;
            }
            const itemEl = getItemEl$2(scope, highlightedValue);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec(true));
          const contentEl = () => getContentEl$4(scope);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec(false);
            }
          });
        }
      },
      actions: {
        selectHighlightedItem({ context, prop, event, computed }) {
          const value = event.value ?? context.get("highlightedValue");
          const collection2 = prop("collection");
          if (value == null || !collection2.has(value)) return;
          const selection = computed("selection");
          if (event.shiftKey && computed("multiple") && event.anchorValue) {
            const next2 = selection.extendSelection(collection2, event.anchorValue, value);
            invokeOnSelect(selection, next2, prop("onSelect"));
            context.set("value", Array.from(next2));
          } else {
            const next2 = selection.select(collection2, value, event.metaKey);
            invokeOnSelect(selection, next2, prop("onSelect"));
            context.set("value", Array.from(next2));
          }
        },
        selectWithKeyboard({ context, prop, event, computed }) {
          const selection = computed("selection");
          const collection2 = prop("collection");
          if (event.shiftKey && computed("multiple") && event.anchorValue) {
            const next2 = selection.extendSelection(collection2, event.anchorValue, event.value);
            invokeOnSelect(selection, next2, prop("onSelect"));
            context.set("value", Array.from(next2));
            return;
          }
          if (prop("selectOnHighlight")) {
            const next2 = selection.replaceSelection(collection2, event.value);
            invokeOnSelect(selection, next2, prop("onSelect"));
            context.set("value", Array.from(next2));
          }
        },
        highlightItem({ context, event }) {
          context.set("highlightedValue", event.value);
        },
        highlightMatchingItem({ context, prop, event, refs }) {
          const value = prop("collection").search(event.key, {
            state: refs.get("typeahead"),
            currentValue: context.get("highlightedValue")
          });
          if (value == null) return;
          context.set("highlightedValue", value);
        },
        setHighlightedItem({ context, event }) {
          context.set("highlightedValue", event.value);
        },
        clearHighlightedItem({ context }) {
          context.set("highlightedValue", null);
        },
        selectItem({ context, prop, event, computed }) {
          const collection2 = prop("collection");
          const selection = computed("selection");
          const next2 = selection.select(collection2, event.value);
          invokeOnSelect(selection, next2, prop("onSelect"));
          context.set("value", Array.from(next2));
        },
        clearItem({ context, event, computed }) {
          const selection = computed("selection");
          const value = selection.deselect(event.value);
          context.set("value", Array.from(value));
        },
        setSelectedItems({ context, event }) {
          context.set("value", event.value);
        },
        clearSelectedItems({ context }) {
          context.set("value", []);
        },
        syncSelectedItems({ context, prop }) {
          const collection2 = prop("collection");
          const prevSelectedItems = context.get("selectedItems");
          const value = context.get("value");
          const selectedItems = value.map((value2) => {
            const item = prevSelectedItems.find((item2) => collection2.getItemValue(item2) === value2);
            return item || collection2.find(value2);
          });
          context.set("selectedItems", selectedItems);
        },
        syncHighlightedItem({ context, prop }) {
          const collection2 = prop("collection");
          const highlightedValue = context.get("highlightedValue");
          const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;
          context.set("highlightedItem", highlightedItem);
        },
        syncHighlightedValue({ context, prop }) {
          const collection2 = prop("collection");
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue != null && !collection2.has(highlightedValue)) {
            context.set("highlightedValue", null);
          }
        },
        setFocused({ context }) {
          context.set("focused", true);
        },
        setDefaultHighlightedValue({ context, prop }) {
          const collection2 = prop("collection");
          const firstValue = collection2.firstValue;
          if (firstValue != null) {
            context.set("highlightedValue", firstValue);
          }
        },
        clearFocused({ context }) {
          context.set("focused", false);
        }
      }
    }
  });
  var diff = (a, b2) => {
    const result = new Set(a);
    for (const item of b2) result.delete(item);
    return result;
  };
  function invokeOnSelect(current, next2, onSelect) {
    const added = diff(next2, current);
    for (const item of added) {
      onSelect?.({ value: item });
    }
  }
  createProps$1()([
    "collection",
    "defaultHighlightedValue",
    "defaultValue",
    "dir",
    "disabled",
    "deselectable",
    "disallowSelectAll",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "onHighlightChange",
    "onSelect",
    "onValueChange",
    "orientation",
    "scrollToIndexFn",
    "selectionMode",
    "selectOnHighlight",
    "typeahead",
    "value"
  ]);
  createProps$1()(["item", "highlightOnHover"]);
  createProps$1()(["id"]);
  createProps$1()(["htmlFor"]);
  const listboxAnatomy$1 = anatomy$f.extendWith("empty");
  var anatomy$e = createAnatomy("menu").parts(
    "arrow",
    "arrowTip",
    "content",
    "contextTrigger",
    "indicator",
    "item",
    "itemGroup",
    "itemGroupLabel",
    "itemIndicator",
    "itemText",
    "positioner",
    "separator",
    "trigger",
    "triggerItem"
  );
  anatomy$e.build();
  var getTriggerId$3 = (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;
  var getContextTriggerId = (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;
  var getContentId$3 = (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`;
  var getPositionerId$2 = (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;
  var getItemId$2 = (ctx, id2) => `${ctx.id}/${id2}`;
  var getItemValue = (el) => el?.dataset.value ?? null;
  var getContentEl$3 = (ctx) => ctx.getById(getContentId$3(ctx));
  var getPositionerEl$2 = (ctx) => ctx.getById(getPositionerId$2(ctx));
  var getTriggerEl$3 = (ctx) => ctx.getById(getTriggerId$3(ctx));
  var getItemEl$1 = (ctx, value) => value ? ctx.getById(getItemId$2(ctx, value)) : null;
  var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
  var getElements$1 = (ctx) => {
    const ownerId = CSS.escape(getContentId$3(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(getContentEl$3(ctx), selector);
  };
  var getFirstEl$1 = (ctx) => first(getElements$1(ctx));
  var getLastEl$1 = (ctx) => last(getElements$1(ctx));
  var isMatch = (el, value) => {
    if (!value) return false;
    return el.id === value || el.dataset.value === value;
  };
  var getNextEl$1 = (ctx, opts) => {
    const items = getElements$1(ctx);
    const index = items.findIndex((el) => isMatch(el, opts.value));
    return next(items, index, { loop: opts.loop ?? opts.loopFocus });
  };
  var getPrevEl$1 = (ctx, opts) => {
    const items = getElements$1(ctx);
    const index = items.findIndex((el) => isMatch(el, opts.value));
    return prev(items, index, { loop: opts.loop ?? opts.loopFocus });
  };
  var getElemByKey = (ctx, opts) => {
    const items = getElements$1(ctx);
    const item = items.find((el) => isMatch(el, opts.value));
    return getByTypeahead(items, { state: opts.typeaheadState, key: opts.key, activeId: item?.id ?? null });
  };
  var isTriggerItem = (el) => {
    return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("aria-controls");
  };
  var itemSelectEvent = "menu:select";
  function dispatchSelectionEvent(el, value) {
    if (!el) return;
    const win = getWindow$1(el);
    const event = new win.CustomEvent(itemSelectEvent, { detail: { value } });
    el.dispatchEvent(event);
  }
  var { not: not$4, and: and$4, or: or$2 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        loopFocus: false,
        navigate(details) {
          clickIfLink(details.node);
        },
        ...props2,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...props2.positioning
        }
      };
    },
    initialState({ prop }) {
      const open = prop("open") || prop("defaultOpen");
      return open ? "open" : "idle";
    },
    context({ bindable, prop }) {
      return {
        suspendPointer: bindable(() => ({
          defaultValue: false
        })),
        highlightedValue: bindable(() => ({
          defaultValue: prop("defaultHighlightedValue") || null,
          value: prop("highlightedValue"),
          onChange(value) {
            prop("onHighlightChange")?.({ highlightedValue: value });
          }
        })),
        lastHighlightedValue: bindable(() => ({
          defaultValue: null
        })),
        currentPlacement: bindable(() => ({
          defaultValue: void 0
        })),
        intentPolygon: bindable(() => ({
          defaultValue: null
        })),
        anchorPoint: bindable(() => ({
          defaultValue: null,
          hash(value) {
            return `x: ${value?.x}, y: ${value?.y}`;
          }
        })),
        isSubmenu: bindable(() => ({
          defaultValue: false
        }))
      };
    },
    refs() {
      return {
        parent: null,
        children: {},
        typeaheadState: { ...getByTypeahead.defaultOptions },
        positioningOverride: {}
      };
    },
    computed: {
      isRtl: ({ prop }) => prop("dir") === "rtl",
      isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== "",
      highlightedId: ({ context, scope, refs }) => resolveItemId(refs.get("children"), context.get("highlightedValue"), scope)
    },
    watch({ track, action, context, prop }) {
      track([() => context.get("isSubmenu")], () => {
        action(["setSubmenuPlacement"]);
      });
      track([() => context.hash("anchorPoint")], () => {
        if (!context.get("anchorPoint")) return;
        action(["reposition"]);
      });
      track([() => prop("open")], () => {
        action(["toggleVisibility"]);
      });
    },
    on: {
      "PARENT.SET": {
        actions: ["setParentMenu"]
      },
      "CHILD.SET": {
        actions: ["setChildMenu"]
      },
      OPEN: [
        {
          guard: "isOpenControlled",
          actions: ["invokeOnOpen"]
        },
        {
          target: "open",
          actions: ["invokeOnOpen"]
        }
      ],
      OPEN_AUTOFOCUS: [
        {
          guard: "isOpenControlled",
          actions: ["invokeOnOpen"]
        },
        {
target: "open",
          actions: ["highlightFirstItem", "invokeOnOpen"]
        }
      ],
      CLOSE: [
        {
          guard: "isOpenControlled",
          actions: ["invokeOnClose"]
        },
        {
          target: "closed",
          actions: ["invokeOnClose"]
        }
      ],
      "HIGHLIGHTED.RESTORE": {
        actions: ["restoreHighlightedItem"]
      },
      "HIGHLIGHTED.SET": {
        actions: ["setHighlightedItem"]
      }
    },
    states: {
      idle: {
        tags: ["closed"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open"
          },
          "CONTROLLED.CLOSE": {
            target: "closed"
          },
          CONTEXT_MENU_START: {
            target: "opening:contextmenu",
            actions: ["setAnchorPoint"]
          },
          CONTEXT_MENU: [
            {
              guard: "isOpenControlled",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            }
          ],
          TRIGGER_CLICK: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ],
          TRIGGER_FOCUS: {
            guard: not$4("isSubmenu"),
            target: "closed"
          },
          TRIGGER_POINTERMOVE: {
            guard: "isSubmenu",
            target: "opening"
          }
        }
      },
      "opening:contextmenu": {
        tags: ["closed"],
        effects: ["waitForLongPress"],
        on: {
          "CONTROLLED.OPEN": { target: "open" },
          "CONTROLLED.CLOSE": { target: "closed" },
          CONTEXT_MENU_CANCEL: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "LONG_PRESS.OPEN": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ]
        }
      },
      opening: {
        tags: ["closed"],
        effects: ["waitForOpenDelay"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open"
          },
          "CONTROLLED.CLOSE": {
            target: "closed"
          },
          BLUR: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          TRIGGER_POINTERLEAVE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "DELAY.OPEN": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ]
        }
      },
      closing: {
        tags: ["open"],
        effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
        on: {
          "CONTROLLED.OPEN": {
            target: "open"
          },
          "CONTROLLED.CLOSE": {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          },
MENU_POINTERENTER: {
            target: "open",
            actions: ["clearIntentPolygon"]
          },
          POINTER_MOVED_AWAY_FROM_SUBMENU: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHighlightedItem"]
            }
          ],
          "DELAY.CLOSE": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
            }
          ]
        }
      },
      closed: {
        tags: ["closed"],
        entry: ["clearHighlightedItem", "focusTrigger", "resumePointer", "clearAnchorPoint"],
        on: {
          "CONTROLLED.OPEN": [
            {
              guard: or$2("isOpenAutoFocusEvent", "isArrowDownEvent"),
              target: "open",
              actions: ["highlightFirstItem"]
            },
            {
              guard: "isArrowUpEvent",
              target: "open",
              actions: ["highlightLastItem"]
            },
            {
              target: "open"
            }
          ],
          CONTEXT_MENU_START: {
            target: "opening:contextmenu",
            actions: ["setAnchorPoint"]
          },
          CONTEXT_MENU: [
            {
              guard: "isOpenControlled",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setAnchorPoint", "invokeOnOpen"]
            }
          ],
          TRIGGER_CLICK: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ],
          TRIGGER_POINTERMOVE: {
            guard: "isTriggerItem",
            target: "opening"
          },
          TRIGGER_BLUR: { target: "idle" },
          ARROW_DOWN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["highlightFirstItem", "invokeOnOpen"]
            }
          ],
          ARROW_UP: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["highlightLastItem", "invokeOnOpen"]
            }
          ]
        }
      },
      open: {
        tags: ["open"],
        effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
        entry: ["focusMenu", "resumePointer"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              target: "closed",
              guard: "isArrowLeftEvent",
              actions: ["focusParentMenu"]
            },
            {
              target: "closed"
            }
          ],
          TRIGGER_CLICK: [
            {
              guard: and$4(not$4("isTriggerItem"), "isOpenControlled"),
              actions: ["invokeOnClose"]
            },
            {
              guard: not$4("isTriggerItem"),
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          CONTEXT_MENU: {
            actions: ["setAnchorPoint", "focusMenu"]
          },
          ARROW_UP: {
            actions: ["highlightPrevItem", "focusMenu"]
          },
          ARROW_DOWN: {
            actions: ["highlightNextItem", "focusMenu"]
          },
          ARROW_LEFT: [
            {
              guard: and$4("isSubmenu", "isOpenControlled"),
              actions: ["invokeOnClose"]
            },
            {
              guard: "isSubmenu",
              target: "closed",
              actions: ["focusParentMenu", "invokeOnClose"]
            }
          ],
          HOME: {
            actions: ["highlightFirstItem", "focusMenu"]
          },
          END: {
            actions: ["highlightLastItem", "focusMenu"]
          },
          ARROW_RIGHT: {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          ENTER: [
            {
              guard: "isTriggerItemHighlighted",
              actions: ["openSubmenu"]
            },
            {
              actions: ["clickHighlightedItem"]
            }
          ],
          ITEM_POINTERMOVE: [
            {
              guard: not$4("isPointerSuspended"),
              actions: ["setHighlightedItem", "focusMenu"]
            },
            {
              actions: ["setLastHighlightedItem"]
            }
          ],
          ITEM_POINTERLEAVE: {
            guard: and$4(not$4("isPointerSuspended"), not$4("isTriggerItem")),
            actions: ["clearHighlightedItem"]
          },
          ITEM_CLICK: [
{
              guard: and$4(
                not$4("isTriggerItemHighlighted"),
                not$4("isHighlightedItemEditable"),
                "closeOnSelect",
                "isOpenControlled"
              ),
              actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
            },
            {
              guard: and$4(not$4("isTriggerItemHighlighted"), not$4("isHighlightedItemEditable"), "closeOnSelect"),
              target: "closed",
              actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
            },
{
              guard: and$4(not$4("isTriggerItemHighlighted"), not$4("isHighlightedItemEditable")),
              actions: ["invokeOnSelect", "setOptionState"]
            },
            { actions: ["setHighlightedItem"] }
          ],
          TRIGGER_POINTERMOVE: {
            guard: "isTriggerItem",
            actions: ["setIntentPolygon"]
          },
          TRIGGER_POINTERLEAVE: {
            target: "closing"
          },
          ITEM_POINTERDOWN: {
            actions: ["setHighlightedItem"]
          },
          TYPEAHEAD: {
            actions: ["highlightMatchedItem"]
          },
          FOCUS_MENU: {
            actions: ["focusMenu"]
          },
          "POSITIONING.SET": {
            actions: ["reposition"]
          }
        }
      }
    },
    implementations: {
      guards: {
        closeOnSelect: ({ prop, event }) => !!(event?.closeOnSelect ?? prop("closeOnSelect")),
isTriggerItem: ({ event }) => isTriggerItem(event.target),
isTriggerItemHighlighted: ({ event, scope, computed }) => {
          const target = event.target ?? scope.getById(computed("highlightedId"));
          return !!target?.hasAttribute("aria-controls");
        },
        isSubmenu: ({ context }) => context.get("isSubmenu"),
        isPointerSuspended: ({ context }) => context.get("suspendPointer"),
        isHighlightedItemEditable: ({ scope, computed }) => isEditableElement(scope.getById(computed("highlightedId"))),
isOpenControlled: ({ prop }) => prop("open") !== void 0,
        isArrowLeftEvent: ({ event }) => event.previousEvent?.type === "ARROW_LEFT",
        isArrowUpEvent: ({ event }) => event.previousEvent?.type === "ARROW_UP",
        isArrowDownEvent: ({ event }) => event.previousEvent?.type === "ARROW_DOWN",
        isOpenAutoFocusEvent: ({ event }) => event.previousEvent?.type === "OPEN_AUTOFOCUS"
      },
      effects: {
        waitForOpenDelay({ send }) {
          const timer = setTimeout(() => {
            send({ type: "DELAY.OPEN" });
          }, 100);
          return () => clearTimeout(timer);
        },
        waitForCloseDelay({ send }) {
          const timer = setTimeout(() => {
            send({ type: "DELAY.CLOSE" });
          }, 300);
          return () => clearTimeout(timer);
        },
        waitForLongPress({ send }) {
          const timer = setTimeout(() => {
            send({ type: "LONG_PRESS.OPEN" });
          }, 700);
          return () => clearTimeout(timer);
        },
        trackPositioning({ context, prop, scope, refs }) {
          if (!!getContextTriggerEl(scope)) return;
          const positioning = {
            ...prop("positioning"),
            ...refs.get("positioningOverride")
          };
          context.set("currentPlacement", positioning.placement);
          const getPositionerEl2 = () => getPositionerEl$2(scope);
          return getPlacement(getTriggerEl$3(scope), getPositionerEl2, {
            ...positioning,
            defer: true,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        trackInteractOutside({ refs, scope, prop, context, send }) {
          const getContentEl2 = () => getContentEl$3(scope);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl2, {
            type: "menu",
            defer: true,
            exclude: [getTriggerEl$3(scope)],
            onInteractOutside: prop("onInteractOutside"),
            onRequestDismiss: prop("onRequestDismiss"),
            onFocusOutside(event) {
              prop("onFocusOutside")?.(event);
              const target = getEventTarget(event.detail.originalEvent);
              const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
              if (isWithinContextTrigger) {
                event.preventDefault();
                return;
              }
            },
            onEscapeKeyDown(event) {
              prop("onEscapeKeyDown")?.(event);
              if (context.get("isSubmenu")) event.preventDefault();
              closeRootMenu({ parent: refs.get("parent") });
            },
            onPointerDownOutside(event) {
              prop("onPointerDownOutside")?.(event);
              const target = getEventTarget(event.detail.originalEvent);
              const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
              if (isWithinContextTrigger && event.detail.contextmenu) {
                event.preventDefault();
                return;
              }
              restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        trackPointerMove({ context, scope, send, refs, flush: flush2 }) {
          const parent = refs.get("parent");
          flush2(() => {
            parent.context.set("suspendPointer", true);
          });
          const doc = scope.getDoc();
          return addDomEvent$1(doc, "pointermove", (e) => {
            const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
              x: e.clientX,
              y: e.clientY
            });
            if (!isMovingToSubmenu) {
              send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
              parent.context.set("suspendPointer", false);
            }
          });
        },
        scrollToHighlightedItem({ event, scope, computed }) {
          const exec = () => {
            if (event.current().type.startsWith("ITEM_POINTER")) return;
            const itemEl = scope.getById(computed("highlightedId"));
            const contentEl2 = getContentEl$3(scope);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec());
          const contentEl = () => getContentEl$3(scope);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec
          });
        }
      },
      actions: {
        setAnchorPoint({ context, event }) {
          context.set("anchorPoint", (prev2) => isEqual(prev2, event.point) ? prev2 : event.point);
        },
        setSubmenuPlacement({ context, computed, refs }) {
          if (!context.get("isSubmenu")) return;
          const placement = computed("isRtl") ? "left-start" : "right-start";
          refs.set("positioningOverride", { placement, gutter: 0 });
        },
        reposition({ context, scope, prop, event, refs }) {
          const getPositionerEl2 = () => getPositionerEl$2(scope);
          const anchorPoint = context.get("anchorPoint");
          const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
          const positioning = {
            ...prop("positioning"),
            ...refs.get("positioningOverride")
          };
          getPlacement(getTriggerEl$3(scope), getPositionerEl2, {
            ...positioning,
            defer: true,
            getAnchorRect,
            ...event.options ?? {},
            listeners: false,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        setOptionState({ event }) {
          if (!event.option) return;
          const { checked, onCheckedChange, type } = event.option;
          if (type === "radio") {
            onCheckedChange?.(true);
          } else if (type === "checkbox") {
            onCheckedChange?.(!checked);
          }
        },
        clickHighlightedItem({ scope, computed, prop, context }) {
          const itemEl = scope.getById(computed("highlightedId"));
          if (!itemEl || itemEl.dataset.disabled) return;
          const highlightedValue = context.get("highlightedValue");
          if (isAnchorElement(itemEl)) {
            prop("navigate")?.({ value: highlightedValue, node: itemEl, href: itemEl.href });
          } else {
            queueMicrotask(() => itemEl.click());
          }
        },
        setIntentPolygon({ context, scope, event }) {
          const menu = getContentEl$3(scope);
          const placement = context.get("currentPlacement");
          if (!menu || !placement) return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon) return;
          const rightSide = getPlacementSide(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
        },
        clearIntentPolygon({ context }) {
          context.set("intentPolygon", null);
        },
        clearAnchorPoint({ context }) {
          context.set("anchorPoint", null);
        },
        resumePointer({ refs, flush: flush2 }) {
          const parent = refs.get("parent");
          if (!parent) return;
          flush2(() => {
            parent.context.set("suspendPointer", false);
          });
        },
        setHighlightedItem({ context, event }) {
          const value = event.value || getItemValue(event.target);
          context.set("highlightedValue", value);
        },
        clearHighlightedItem({ context }) {
          context.set("highlightedValue", null);
        },
        focusMenu({ scope }) {
          raf(() => {
            const contentEl = getContentEl$3(scope);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, scope.getActiveElement()),
              filter(node2) {
                return !node2.role?.startsWith("menuitem");
              }
            });
            initialFocusEl?.focus({ preventScroll: true });
          });
        },
        highlightFirstItem({ context, scope }) {
          const fn = getContentEl$3(scope) ? queueMicrotask : raf;
          fn(() => {
            const first2 = getFirstEl$1(scope);
            if (!first2) return;
            context.set("highlightedValue", getItemValue(first2));
          });
        },
        highlightLastItem({ context, scope }) {
          const fn = getContentEl$3(scope) ? queueMicrotask : raf;
          fn(() => {
            const last2 = getLastEl$1(scope);
            if (!last2) return;
            context.set("highlightedValue", getItemValue(last2));
          });
        },
        highlightNextItem({ context, scope, event, prop }) {
          const next2 = getNextEl$1(scope, {
            loop: event.loop,
            value: context.get("highlightedValue"),
            loopFocus: prop("loopFocus")
          });
          context.set("highlightedValue", getItemValue(next2));
        },
        highlightPrevItem({ context, scope, event, prop }) {
          const prev2 = getPrevEl$1(scope, {
            loop: event.loop,
            value: context.get("highlightedValue"),
            loopFocus: prop("loopFocus")
          });
          context.set("highlightedValue", getItemValue(prev2));
        },
        invokeOnSelect({ context, prop, scope }) {
          const value = context.get("highlightedValue");
          if (value == null) return;
          const node2 = getItemEl$1(scope, value);
          dispatchSelectionEvent(node2, value);
          prop("onSelect")?.({ value });
        },
        focusTrigger({ scope, context, event }) {
          if (context.get("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
          queueMicrotask(() => getTriggerEl$3(scope)?.focus({ preventScroll: true }));
        },
        highlightMatchedItem({ scope, context, event, refs }) {
          const node2 = getElemByKey(scope, {
            key: event.key,
            value: context.get("highlightedValue"),
            typeaheadState: refs.get("typeaheadState")
          });
          if (!node2) return;
          context.set("highlightedValue", getItemValue(node2));
        },
        setParentMenu({ refs, event, context }) {
          refs.set("parent", event.value);
          context.set("isSubmenu", true);
        },
        setChildMenu({ refs, event }) {
          const children = refs.get("children");
          children[event.id] = event.value;
          refs.set("children", children);
        },
        closeRootMenu({ refs }) {
          closeRootMenu({ parent: refs.get("parent") });
        },
        openSubmenu({ refs, scope, computed }) {
          const item = scope.getById(computed("highlightedId"));
          const id2 = item?.getAttribute("data-uid");
          const children = refs.get("children");
          const child = id2 ? children[id2] : null;
          child?.send({ type: "OPEN_AUTOFOCUS" });
        },
        focusParentMenu({ refs }) {
          refs.get("parent")?.send({ type: "FOCUS_MENU" });
        },
        setLastHighlightedItem({ context, event }) {
          context.set("lastHighlightedValue", getItemValue(event.target));
        },
        restoreHighlightedItem({ context }) {
          if (!context.get("lastHighlightedValue")) return;
          context.set("highlightedValue", context.get("lastHighlightedValue"));
          context.set("lastHighlightedValue", null);
        },
        restoreParentHighlightedItem({ refs }) {
          refs.get("parent")?.send({ type: "HIGHLIGHTED.RESTORE" });
        },
        invokeOnOpen({ prop }) {
          prop("onOpenChange")?.({ open: true });
        },
        invokeOnClose({ prop }) {
          prop("onOpenChange")?.({ open: false });
        },
        toggleVisibility({ prop, event, send }) {
          send({
            type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
            previousEvent: event
          });
        }
      }
    }
  });
  function closeRootMenu(ctx) {
    let parent = ctx.parent;
    while (parent && parent.context.get("isSubmenu")) {
      parent = parent.refs.get("parent");
    }
    parent?.send({ type: "CLOSE" });
  }
  function isWithinPolygon(polygon, point) {
    if (!polygon) return false;
    return isPointInPolygon(polygon, point);
  }
  function resolveItemId(children, value, scope) {
    const hasChildren = Object.keys(children).length > 0;
    if (!value) return null;
    if (!hasChildren) {
      return getItemId$2(scope, value);
    }
    for (const id2 in children) {
      const childMenu = children[id2];
      const childTriggerId = getTriggerId$3(childMenu.scope);
      if (childTriggerId === value) {
        return childTriggerId;
      }
    }
    return getItemId$2(scope, value);
  }
  createProps$1()([
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "dir",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onRequestDismiss",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  createProps$1()(["closeOnSelect", "disabled", "value", "valueText"]);
  createProps$1()(["htmlFor"]);
  createProps$1()(["id"]);
  createProps$1()([
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "type",
    "value",
    "valueText"
  ]);
  let $488c6ddbf4ef74c2$var$formatterCache = new Map();
  let $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
  try {
    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
      signDisplay: "exceptZero"
    }).resolvedOptions().signDisplay === "exceptZero";
  } catch {
  }
  let $488c6ddbf4ef74c2$var$supportsUnit = false;
  try {
    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
      style: "unit",
      unit: "degree"
    }).resolvedOptions().style === "unit";
  } catch {
  }
  const $488c6ddbf4ef74c2$var$UNITS = {
    degree: {
      narrow: {
        default: "",
        "ja-JP": " ",
        "zh-TW": "",
        "sl-SI": " "
      }
    }
  };
  class $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {
format(value) {
      let res = "";
      if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
      else res = this.numberFormatter.format(value);
      if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
        var _UNITS_unit;
        let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
        if (!unit) return res;
        let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
        res += values[locale] || values.default;
      }
      return res;
    }
formatToParts(value) {
      return this.numberFormatter.formatToParts(value);
    }
formatRange(start, end) {
      if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
      if (end < start) throw new RangeError("End date must be >= start date");
      return `${this.format(start)}  ${this.format(end)}`;
    }
formatRangeToParts(start, end) {
      if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
      if (end < start) throw new RangeError("End date must be >= start date");
      let startParts = this.numberFormatter.formatToParts(start);
      let endParts = this.numberFormatter.formatToParts(end);
      return [
        ...startParts.map((p) => ({
          ...p,
          source: "startRange"
        })),
        {
          type: "literal",
          value: "  ",
          source: "shared"
        },
        ...endParts.map((p) => ({
          ...p,
          source: "endRange"
        }))
      ];
    }
resolvedOptions() {
      let options = this.numberFormatter.resolvedOptions();
      if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
        ...options,
        signDisplay: this.options.signDisplay
      };
      if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
        ...options,
        style: "unit",
        unit: this.options.unit,
        unitDisplay: this.options.unitDisplay
      };
      return options;
    }
    constructor(locale, options = {}) {
      this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
      this.options = options;
    }
  }
  function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
    let { numberingSystem } = options;
    if (numberingSystem && locale.includes("-nu-")) {
      if (!locale.includes("-u-")) locale += "-u-";
      locale += `-nu-${numberingSystem}`;
    }
    if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short" } = options;
      if (!unit) throw new Error('unit option must be provided with style: "unit"');
      if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
      options = {
        ...options,
        style: "decimal"
      };
    }
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
    let numberFormatter = new Intl.NumberFormat(locale, options);
    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
    return numberFormatter;
  }
  function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
    if (signDisplay === "auto") return numberFormat.format(num);
    else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
    else {
      let needsPositiveSign = false;
      if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
      else if (signDisplay === "exceptZero") {
        if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
        else needsPositiveSign = num > 0;
      }
      if (needsPositiveSign) {
        let negative = numberFormat.format(-num);
        let noSign = numberFormat.format(num);
        let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
        if ([
          ...minus
        ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
        let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
        return positive;
      } else return numberFormat.format(num);
    }
  }
  const $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
  const $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
    "latn",
    "arab",
    "hanidec",
    "deva",
    "beng",
    "fullwide"
  ];
  class $6c7bd7858deea686$export$cd11ab140839f11d {
parse(value) {
      return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
    }
isValidPartialNumber(value, minValue, maxValue2) {
      return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue2);
    }
getNumberingSystem(value) {
      return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
    }
    constructor(locale, options = {}) {
      this.locale = locale;
      this.options = options;
    }
  }
  const $6c7bd7858deea686$var$numberParserCache = new Map();
  function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
    if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
      for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
        let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
        if (parser.isValidPartialNumber(value)) return parser;
      }
    }
    return defaultParser;
  }
  function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
    let cacheKey = locale + (options ? Object.entries(options).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
    if (!parser) {
      parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
      $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
    }
    return parser;
  }
  class $6c7bd7858deea686$var$NumberParserImpl {
    parse(value) {
      let fullySanitizedValue = this.sanitize(value);
      if (this.symbols.group)
        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
      if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
      if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
      if (this.options.style === "percent") {
        let isNegative = fullySanitizedValue.indexOf("-");
        fullySanitizedValue = fullySanitizedValue.replace("-", "");
        fullySanitizedValue = fullySanitizedValue.replace("+", "");
        let index = fullySanitizedValue.indexOf(".");
        if (index === -1) index = fullySanitizedValue.length;
        fullySanitizedValue = fullySanitizedValue.replace(".", "");
        if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
        else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
        else if (index - 2 === -2) fullySanitizedValue = "0.00";
        else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
        if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
      }
      let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
      if (isNaN(newValue)) return NaN;
      if (this.options.style === "percent") {
        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
        let options = {
          ...this.options,
          style: "decimal",
          minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
          maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
        };
        return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(this.locale, options).format(newValue));
      }
      if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
      return newValue;
    }
    sanitize(value) {
      value = value.replace(this.symbols.literals, "");
      if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
      if (this.options.numberingSystem === "arab") {
        if (this.symbols.decimal) {
          value = value.replace(",", this.symbols.decimal);
          value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
        }
        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
      }
      if (this.symbols.group === "" && value.includes("'")) value = $6c7bd7858deea686$var$replaceAll(value, "'", this.symbols.group);
      if (this.options.locale === "fr-FR" && this.symbols.group) {
        value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
        value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
      }
      return value;
    }
    isValidPartialNumber(value, minValue = -Infinity, maxValue2 = Infinity) {
      value = this.sanitize(value);
      if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
      else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue2 > 0) value = value.slice(this.symbols.plusSign.length);
      if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
      if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
      value = value.replace(this.symbols.numeral, "");
      if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
      return value.length === 0;
    }
    constructor(locale, options = {}) {
      this.locale = locale;
      if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
        if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
          options.maximumFractionDigits = 0;
          options.minimumFractionDigits = 0;
        } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
        else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
      }
      this.formatter = new Intl.NumberFormat(locale, options);
      this.options = this.formatter.resolvedOptions();
      this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
    }
  }
  const $6c7bd7858deea686$var$nonLiteralParts = new Set([
    "decimal",
    "fraction",
    "integer",
    "minusSign",
    "plusSign",
    "group"
  ]);
  const $6c7bd7858deea686$var$pluralNumbers = [
    0,
    4,
    2,
    1,
    11,
    20,
    3,
    7,
    100,
    21,
    0.1,
    1.1
  ];
  function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
    let symbolFormatter = new Intl.NumberFormat(locale, {
      ...intlOptions,
minimumSignificantDigits: 1,
      maximumSignificantDigits: 21,
      roundingIncrement: 1,
      roundingPriority: "auto",
      roundingMode: "halfExpand"
    });
    let allParts = symbolFormatter.formatToParts(-10000.111);
    let posAllParts = symbolFormatter.formatToParts(10000.111);
    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
    var _allParts_find_value;
    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
    let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
    let decimalParts = new Intl.NumberFormat(locale, {
      ...intlOptions,
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).formatToParts(1e-3);
    let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
    let group = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
    let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
    let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
    let sortedLiterals = [
      ... new Set([
        ...allPartsLiterals,
        ...pluralPartsLiterals
      ])
    ].sort((a, b2) => b2.length - a.length);
    let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
    let numerals = [
      ...new Intl.NumberFormat(intlOptions.locale, {
        useGrouping: false
      }).format(9876543210)
    ].reverse();
    let indexes = new Map(numerals.map((d, i) => [
      d,
      i
    ]));
    let numeral = new RegExp(`[${numerals.join("")}]`, "g");
    let index = (d) => String(indexes.get(d));
    return {
      minusSign,
      plusSign,
      decimal,
      group,
      literals,
      numeral,
      index
    };
  }
  function $6c7bd7858deea686$var$replaceAll(str, find2, replace2) {
    if (str.replaceAll) return str.replaceAll(find2, replace2);
    return str.split(find2).join(replace2);
  }
  function $6c7bd7858deea686$var$escapeRegex(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  var anatomy$d = createAnatomy("numberInput").parts(
    "root",
    "label",
    "input",
    "control",
    "valueText",
    "incrementTrigger",
    "decrementTrigger",
    "scrubber"
  );
  anatomy$d.build();
  var getInputId$1 = (ctx) => ctx.ids?.input ?? `number-input:${ctx.id}:input`;
  var getIncrementTriggerId = (ctx) => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`;
  var getDecrementTriggerId = (ctx) => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`;
  var getCursorId = (ctx) => `number-input:${ctx.id}:cursor`;
  var getInputEl$1 = (ctx) => ctx.getById(getInputId$1(ctx));
  var getIncrementTriggerEl = (ctx) => ctx.getById(getIncrementTriggerId(ctx));
  var getDecrementTriggerEl = (ctx) => ctx.getById(getDecrementTriggerId(ctx));
  var getCursorEl = (ctx) => ctx.getDoc().getElementById(getCursorId(ctx));
  var getPressedTriggerEl = (ctx, hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = getDecrementTriggerEl(ctx);
    }
    return btnEl;
  };
  var setupVirtualCursor = (ctx, point) => {
    if (isSafari()) return;
    createVirtualCursor(ctx, point);
    return () => {
      getCursorEl(ctx)?.remove();
    };
  };
  var preventTextSelection = (ctx) => {
    const doc = ctx.getDoc();
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  };
  var getMousemoveValue = (ctx, opts) => {
    const { point, isRtl, event } = opts;
    const win = ctx.getWin();
    const x2 = roundToDpr(event.movementX, win.devicePixelRatio);
    const y = roundToDpr(event.movementY, win.devicePixelRatio);
    let hint = x2 > 0 ? "increment" : x2 < 0 ? "decrement" : null;
    if (isRtl && hint === "increment") hint = "decrement";
    if (isRtl && hint === "decrement") hint = "increment";
    const newPoint = { x: point.x + x2, y: point.y + y };
    const width = win.innerWidth;
    const half = roundToDpr(7.5, win.devicePixelRatio);
    newPoint.x = wrap$2(newPoint.x + half, width) - half;
    return { hint, point: newPoint };
  };
  var createVirtualCursor = (ctx, point) => {
    const doc = ctx.getDoc();
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
      <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
        <g transform="translate(2 3)">
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
        </g>
      </svg>`;
    doc.body.appendChild(el);
  };
  function restoreCursor(inputEl, selection, scope) {
    if (!inputEl || !scope.isActiveElement(inputEl)) return;
    if (!selection) {
      const len = inputEl.value.length;
      inputEl.setSelectionRange(len, len);
      return;
    }
    try {
      const newValue = inputEl.value;
      const { start, end, value: oldValue } = selection;
      if (newValue === oldValue) {
        inputEl.setSelectionRange(start, end);
        return;
      }
      const newStart = getNewCursorPosition(oldValue, newValue, start);
      const newEnd = start === end ? newStart : getNewCursorPosition(oldValue, newValue, end);
      const clampedStart = Math.max(0, Math.min(newStart, newValue.length));
      const clampedEnd = Math.max(clampedStart, Math.min(newEnd, newValue.length));
      inputEl.setSelectionRange(clampedStart, clampedEnd);
    } catch {
      const len = inputEl.value.length;
      inputEl.setSelectionRange(len, len);
    }
  }
  function getNewCursorPosition(oldValue, newValue, oldPosition) {
    const beforeCursor = oldValue.slice(0, oldPosition);
    const afterCursor = oldValue.slice(oldPosition);
    let prefixLength = 0;
    const maxPrefixLength = Math.min(beforeCursor.length, newValue.length);
    for (let i = 0; i < maxPrefixLength; i++) {
      if (beforeCursor[i] === newValue[i]) {
        prefixLength = i + 1;
      } else {
        break;
      }
    }
    let suffixLength = 0;
    const maxSuffixLength = Math.min(afterCursor.length, newValue.length - prefixLength);
    for (let i = 0; i < maxSuffixLength; i++) {
      const oldIndex = afterCursor.length - 1 - i;
      const newIndex = newValue.length - 1 - i;
      if (afterCursor[oldIndex] === newValue[newIndex]) {
        suffixLength = i + 1;
      } else {
        break;
      }
    }
    if (prefixLength >= beforeCursor.length) {
      return prefixLength;
    }
    if (suffixLength >= afterCursor.length) {
      return newValue.length - suffixLength;
    }
    if (prefixLength > 0) {
      return prefixLength;
    }
    if (suffixLength > 0) {
      return newValue.length - suffixLength;
    }
    if (oldValue.length > 0) {
      const ratio = oldPosition / oldValue.length;
      return Math.round(ratio * newValue.length);
    }
    return newValue.length;
  }
  var createFormatter = (locale, options = {}) => {
    return new Intl.NumberFormat(locale, options);
  };
  var createParser = (locale, options = {}) => {
    return new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options);
  };
  var parseValue = (value, params) => {
    const { prop, computed } = params;
    if (!prop("formatOptions")) return parseFloat(value);
    if (value === "") return Number.NaN;
    return computed("parser").parse(value);
  };
  var formatValue = (value, params) => {
    const { prop, computed } = params;
    if (Number.isNaN(value)) return "";
    if (!prop("formatOptions")) return value.toString();
    return computed("formatter").format(value);
  };
  var getDefaultStep = (step, formatOptions) => {
    let defaultStep = step !== void 0 && !Number.isNaN(step) ? step : 1;
    if (formatOptions?.style === "percent" && (step === void 0 || Number.isNaN(step))) {
      defaultStep = 0.01;
    }
    return defaultStep;
  };
  var { choose, guards, createMachine: createMachine$1 } = setup();
  var { not: not$3, and: and$3 } = guards;
  createMachine$1({
    props({ props: props2 }) {
      const step = getDefaultStep(props2.step, props2.formatOptions);
      return {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: !props2.allowOverflow,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "-?[0-9]*(.[0-9]+)?",
        defaultValue: "",
        step,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        spinOnPress: true,
        ...props2,
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...props2.translations
        }
      };
    },
    initialState() {
      return "idle";
    },
    context({ prop, bindable, getComputed }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          onChange(value) {
            const computed = getComputed();
            const valueAsNumber = parseValue(value, { computed, prop });
            prop("onValueChange")?.({ value, valueAsNumber });
          }
        })),
        hint: bindable(() => ({ defaultValue: null })),
        scrubberCursorPoint: bindable(() => ({
          defaultValue: null,
          hash(value) {
            return value ? `x:${value.x}, y:${value.y}` : "";
          }
        })),
        fieldsetDisabled: bindable(() => ({ defaultValue: false }))
      };
    },
    computed: {
      isRtl: ({ prop }) => prop("dir") === "rtl",
      valueAsNumber: ({ context, computed, prop }) => parseValue(context.get("value"), { computed, prop }),
      formattedValue: ({ computed, prop }) => formatValue(computed("valueAsNumber"), { computed, prop }),
      isAtMin: ({ computed, prop }) => isValueAtMin(computed("valueAsNumber"), prop("min")),
      isAtMax: ({ computed, prop }) => isValueAtMax(computed("valueAsNumber"), prop("max")),
      isOutOfRange: ({ computed, prop }) => !isValueWithinRange(computed("valueAsNumber"), prop("min"), prop("max")),
      isValueEmpty: ({ context }) => context.get("value") === "",
      isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
      canIncrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMax"),
      canDecrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMin"),
      valueText: ({ prop, context }) => prop("translations").valueText?.(context.get("value")),
      formatter: memo$3(
        ({ prop }) => [prop("locale"), prop("formatOptions")],
        ([locale, formatOptions]) => createFormatter(locale, formatOptions)
      ),
      parser: memo$3(
        ({ prop }) => [prop("locale"), prop("formatOptions")],
        ([locale, formatOptions]) => createParser(locale, formatOptions)
      )
    },
    watch({ track, action, context, computed, prop }) {
      track([() => context.get("value"), () => prop("locale")], () => {
        action(["syncInputElement"]);
      });
      track([() => computed("isOutOfRange")], () => {
        action(["invokeOnInvalid"]);
      });
      track([() => context.hash("scrubberCursorPoint")], () => {
        action(["setVirtualCursorPosition"]);
      });
    },
    effects: ["trackFormControl"],
    on: {
      "VALUE.SET": {
        actions: ["setRawValue"]
      },
      "VALUE.CLEAR": {
        actions: ["clearValue"]
      },
      "VALUE.INCREMENT": {
        actions: ["increment"]
      },
      "VALUE.DECREMENT": {
        actions: ["decrement"]
      }
    },
    states: {
      idle: {
        on: {
          "TRIGGER.PRESS_DOWN": [
            { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
            {
              target: "before:spin",
              actions: ["focusInput", "invokeOnFocus", "setHint"]
            }
          ],
          "SCRUBBER.PRESS_DOWN": {
            target: "scrubbing",
            actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
          },
          "INPUT.FOCUS": {
            target: "focused",
            actions: ["focusInput", "invokeOnFocus"]
          }
        }
      },
      focused: {
        tags: ["focus"],
        effects: ["attachWheelListener"],
        on: {
          "TRIGGER.PRESS_DOWN": [
            { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
            { target: "before:spin", actions: ["focusInput", "setHint"] }
          ],
          "SCRUBBER.PRESS_DOWN": {
            target: "scrubbing",
            actions: ["focusInput", "setHint", "setCursorPoint"]
          },
          "INPUT.ARROW_UP": {
            actions: ["increment"]
          },
          "INPUT.ARROW_DOWN": {
            actions: ["decrement"]
          },
          "INPUT.HOME": {
            actions: ["decrementToMin"]
          },
          "INPUT.END": {
            actions: ["incrementToMax"]
          },
          "INPUT.CHANGE": {
            actions: ["setValue", "setHint"]
          },
          "INPUT.BLUR": [
            {
              guard: and$3("clampValueOnBlur", not$3("isInRange")),
              target: "idle",
              actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
            },
            {
              guard: not$3("isInRange"),
              target: "idle",
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur", "invokeOnInvalid"]
            },
            {
              target: "idle",
              actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
            }
          ],
          "INPUT.ENTER": {
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
          }
        }
      },
      "before:spin": {
        tags: ["focus"],
        effects: ["trackButtonDisabled", "waitForChangeDelay"],
        entry: choose([
          { guard: "isIncrementHint", actions: ["increment"] },
          { guard: "isDecrementHint", actions: ["decrement"] }
        ]),
        on: {
          CHANGE_DELAY: {
            target: "spinning",
            guard: and$3("isInRange", "spinOnPress")
          },
          "TRIGGER.PRESS_UP": [
            { guard: "isTouchPointer", target: "focused", actions: ["clearHint"] },
            { target: "focused", actions: ["focusInput", "clearHint"] }
          ]
        }
      },
      spinning: {
        tags: ["focus"],
        effects: ["trackButtonDisabled", "spinValue"],
        on: {
          SPIN: [
            {
              guard: "isIncrementHint",
              actions: ["increment"]
            },
            {
              guard: "isDecrementHint",
              actions: ["decrement"]
            }
          ],
          "TRIGGER.PRESS_UP": {
            target: "focused",
            actions: ["focusInput", "clearHint"]
          }
        }
      },
      scrubbing: {
        tags: ["focus"],
        effects: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
        on: {
          "SCRUBBER.POINTER_UP": {
            target: "focused",
            actions: ["focusInput", "clearCursorPoint"]
          },
          "SCRUBBER.POINTER_MOVE": [
            {
              guard: "isIncrementHint",
              actions: ["increment", "setCursorPoint"]
            },
            {
              guard: "isDecrementHint",
              actions: ["decrement", "setCursorPoint"]
            }
          ]
        }
      }
    },
    implementations: {
      guards: {
        clampValueOnBlur: ({ prop }) => prop("clampValueOnBlur"),
        spinOnPress: ({ prop }) => !!prop("spinOnPress"),
        isInRange: ({ computed }) => !computed("isOutOfRange"),
        isDecrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "decrement",
        isIncrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "increment",
        isTouchPointer: ({ event }) => event.pointerType === "touch"
      },
      effects: {
        waitForChangeDelay({ send }) {
          const id2 = setTimeout(() => {
            send({ type: "CHANGE_DELAY" });
          }, 300);
          return () => clearTimeout(id2);
        },
        spinValue({ send }) {
          const id2 = setInterval(() => {
            send({ type: "SPIN" });
          }, 50);
          return () => clearInterval(id2);
        },
        trackFormControl({ context, scope }) {
          const inputEl = getInputEl$1(scope);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              context.set("fieldsetDisabled", disabled);
            },
            onFormReset() {
              context.set("value", context.initial("value"));
            }
          });
        },
        setupVirtualCursor({ context, scope }) {
          const point = context.get("scrubberCursorPoint");
          return setupVirtualCursor(scope, point);
        },
        preventTextSelection({ scope }) {
          return preventTextSelection(scope);
        },
        trackButtonDisabled({ context, scope, send }) {
          const hint = context.get("hint");
          const btn = getPressedTriggerEl(scope, hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener({ scope, send, prop }) {
          const inputEl = getInputEl$1(scope);
          if (!inputEl || !scope.isActiveElement(inputEl) || !prop("allowMouseWheel")) return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send({ type: "VALUE.INCREMENT" });
            } else if (dir === -1) {
              send({ type: "VALUE.DECREMENT" });
            }
          }
          return addDomEvent$1(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock({ scope }) {
          if (isSafari()) return;
          return requestPointerLock(scope.getDoc());
        },
        trackMousemove({ scope, send, context, computed }) {
          const doc = scope.getDoc();
          function onMousemove(event) {
            const point = context.get("scrubberCursorPoint");
            const isRtl = computed("isRtl");
            const value = getMousemoveValue(scope, { point, isRtl, event });
            if (!value.hint) return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send({ type: "SCRUBBER.POINTER_UP" });
          }
          return callAll(addDomEvent$1(doc, "mousemove", onMousemove, false), addDomEvent$1(doc, "mouseup", onMouseup, false));
        }
      },
      actions: {
        focusInput({ scope, prop }) {
          if (!prop("focusInputOnChange")) return;
          const inputEl = getInputEl$1(scope);
          if (scope.isActiveElement(inputEl)) return;
          raf(() => inputEl?.focus({ preventScroll: true }));
        },
        increment({ context, event, prop, computed }) {
          let nextValue = incrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
          if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
          context.set("value", formatValue(nextValue, { computed, prop }));
        },
        decrement({ context, event, prop, computed }) {
          let nextValue = decrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
          if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
          context.set("value", formatValue(nextValue, { computed, prop }));
        },
        setClampedValue({ context, prop, computed }) {
          const nextValue = clampValue(computed("valueAsNumber"), prop("min"), prop("max"));
          context.set("value", formatValue(nextValue, { computed, prop }));
        },
        setRawValue({ context, event, prop, computed }) {
          let nextValue = parseValue(event.value, { computed, prop });
          if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
          context.set("value", formatValue(nextValue, { computed, prop }));
        },
        setValue({ context, event }) {
          const value = event.target?.value ?? event.value;
          context.set("value", value);
        },
        clearValue({ context }) {
          context.set("value", "");
        },
        incrementToMax({ context, prop, computed }) {
          const value = formatValue(prop("max"), { computed, prop });
          context.set("value", value);
        },
        decrementToMin({ context, prop, computed }) {
          const value = formatValue(prop("min"), { computed, prop });
          context.set("value", value);
        },
        setHint({ context, event }) {
          context.set("hint", event.hint);
        },
        clearHint({ context }) {
          context.set("hint", null);
        },
        invokeOnFocus({ computed, prop }) {
          prop("onFocusChange")?.({
            focused: true,
            value: computed("formattedValue"),
            valueAsNumber: computed("valueAsNumber")
          });
        },
        invokeOnBlur({ computed, prop }) {
          prop("onFocusChange")?.({
            focused: false,
            value: computed("formattedValue"),
            valueAsNumber: computed("valueAsNumber")
          });
        },
        invokeOnInvalid({ computed, prop, event }) {
          if (event.type === "INPUT.CHANGE") return;
          const reason = computed("valueAsNumber") > prop("max") ? "rangeOverflow" : "rangeUnderflow";
          prop("onValueInvalid")?.({
            reason,
            value: computed("formattedValue"),
            valueAsNumber: computed("valueAsNumber")
          });
        },
        syncInputElement({ context, event, computed, scope }) {
          const value = event.type.endsWith("CHANGE") ? context.get("value") : computed("formattedValue");
          const inputEl = getInputEl$1(scope);
          const sel = event.selection;
          raf(() => {
            setElementValue(inputEl, value);
            restoreCursor(inputEl, sel, scope);
          });
        },
        setFormattedValue({ context, computed }) {
          context.set("value", computed("formattedValue"));
        },
        setCursorPoint({ context, event }) {
          context.set("scrubberCursorPoint", event.point);
        },
        clearCursorPoint({ context }) {
          context.set("scrubberCursorPoint", null);
        },
        setVirtualCursorPosition({ context, scope }) {
          const cursorEl = getCursorEl(scope);
          const point = context.get("scrubberCursorPoint");
          if (!cursorEl || !point) return;
          cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;
        }
      }
    }
  });
  createProps$1()([
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "dir",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "getRootNode",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "required",
    "readOnly",
    "spinOnPress",
    "step",
    "translations",
    "value",
    "defaultValue"
  ]);
  var anatomy$c = createAnatomy("pinInput").parts("root", "label", "input", "control");
  anatomy$c.build();
  createProps$1()([
    "autoFocus",
    "blurOnComplete",
    "count",
    "defaultValue",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "readOnly",
    "required",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  var anatomy$b = createAnatomy("popover").parts(
    "arrow",
    "arrowTip",
    "anchor",
    "trigger",
    "indicator",
    "positioner",
    "content",
    "title",
    "description",
    "closeTrigger"
  );
  anatomy$b.build();
  createProps$1()([
    "autoFocus",
    "closeOnEscape",
    "closeOnInteractOutside",
    "dir",
    "getRootNode",
    "id",
    "ids",
    "initialFocusEl",
    "modal",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onRequestDismiss",
    "defaultOpen",
    "open",
    "persistentElements",
    "portalled",
    "positioning"
  ]);
  var anatomy$a = createAnatomy("progress").parts(
    "root",
    "label",
    "track",
    "range",
    "valueText",
    "view",
    "circle",
    "circleTrack",
    "circleRange"
  );
  anatomy$a.build();
  createProps$1()([
    "dir",
    "getRootNode",
    "id",
    "ids",
    "max",
    "min",
    "orientation",
    "translations",
    "value",
    "onValueChange",
    "defaultValue",
    "formatOptions",
    "locale"
  ]);
  var anatomy$9 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay", "downloadTrigger");
  anatomy$9.build();
  createProps$1()([
    "ids",
    "defaultValue",
    "value",
    "id",
    "encoding",
    "dir",
    "getRootNode",
    "onValueChange",
    "pixelSize"
  ]);
  var anatomy$8 = createAnatomy("radio-group").parts(
    "root",
    "label",
    "item",
    "itemText",
    "itemControl",
    "indicator"
  );
  anatomy$8.build();
  createProps$1()([
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value",
    "defaultValue"
  ]);
  createProps$1()(["value", "disabled", "invalid"]);
  var anatomy$7 = createAnatomy("rating-group").parts("root", "label", "item", "control");
  anatomy$7.build();
  createProps$1()([
    "allowHalf",
    "autoFocus",
    "count",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "required",
    "readOnly",
    "translations",
    "value",
    "defaultValue"
  ]);
  createProps$1()(["index"]);
  const [ScrollAreaProvider, useScrollAreaContext] = createContext({
    name: "ScrollAreaContext",
    hookName: "useScrollAreaContext",
    providerName: "<ScrollAreaProvider />"
  });
  const ScrollAreaContent$1 = reactExports.forwardRef((props, ref) => {
    const scrollArea = useScrollAreaContext();
    const mergedProps = mergeProps(scrollArea.getContentProps(), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  ScrollAreaContent$1.displayName = "ScrollAreaContent";
  const ScrollAreaCorner = reactExports.forwardRef((props, ref) => {
    const scrollArea = useScrollAreaContext();
    const mergedProps = mergeProps(scrollArea.getCornerProps(), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  ScrollAreaCorner.displayName = "ScrollAreaCorner";
  var __defProp$1 = Object.defineProperty;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  var anatomy$6 = createAnatomy("scroll-area").parts("root", "viewport", "content", "scrollbar", "thumb", "corner");
  var parts$1 = anatomy$6.build();
  var getRootId$2 = (ctx) => ctx.ids?.root ?? `scroll-area-${ctx.id}`;
  var getViewportId = (ctx) => ctx.ids?.viewport ?? `scroll-area-${ctx.id}:viewport`;
  var getContentId$2 = (ctx) => ctx.ids?.content ?? `scroll-area-${ctx.id}:content`;
  var getRootEl$1 = (ctx) => ctx.getById(getRootId$2(ctx));
  var getViewportEl = (ctx) => ctx.getById(getViewportId(ctx));
  var getContentEl$2 = (ctx) => ctx.getById(getContentId$2(ctx));
  var getScrollbarXEl = (ctx) => query(getRootEl$1(ctx), `[data-part=scrollbar][data-orientation=horizontal][data-ownedby="${getRootId$2(ctx)}"]`);
  var getScrollbarYEl = (ctx) => query(getRootEl$1(ctx), `[data-part=scrollbar][data-orientation=vertical][data-ownedby="${getRootId$2(ctx)}"]`);
  var getThumbXEl = (ctx) => query(getScrollbarXEl(ctx), `[data-part=thumb][data-orientation=horizontal][data-ownedby="${getRootId$2(ctx)}"]`);
  var getThumbYEl = (ctx) => query(getScrollbarYEl(ctx), `[data-part=thumb][data-orientation=vertical][data-ownedby="${getRootId$2(ctx)}"]`);
  var getCornerEl = (ctx) => query(getRootEl$1(ctx), `[data-part=corner][data-ownedby="${getRootId$2(ctx)}"]`);
  function getScrollProgress(element, scrollThreshold) {
    if (!element) return EMPTY_SCROLL_PROGRESS;
    let progressX = 0;
    let progressY = 0;
    const maxScrollX = element.scrollWidth - element.clientWidth;
    if (maxScrollX > scrollThreshold) {
      progressX = Math.min(1, Math.max(0, element.scrollLeft / maxScrollX));
    }
    const maxScrollY = element.scrollHeight - element.clientHeight;
    if (maxScrollY > scrollThreshold) {
      progressY = Math.min(1, Math.max(0, element.scrollTop / maxScrollY));
    }
    return { x: progressX, y: progressY };
  }
  var EMPTY_SCROLL_PROGRESS = { x: 0, y: 0 };
  var DURATION = 300;
  var EASE_OUT_QUAD = (t) => t * (2 - t);
  function smoothScroll(node2, options = {}) {
    const { top, left, duration = DURATION, easing = EASE_OUT_QUAD, onComplete } = options;
    if (!node2) return;
    const state2 = {
      startTime: 0,
      startScrollTop: node2.scrollTop,
      startScrollLeft: node2.scrollLeft,
      targetScrollTop: top ?? node2.scrollTop,
      targetScrollLeft: left ?? node2.scrollLeft
    };
    let cancelled = false;
    const cleanup = () => {
      if (state2.rafId) {
        cancelAnimationFrame(state2.rafId);
        state2.rafId = void 0;
      }
      cancelled = true;
    };
    const animate = (currentTime) => {
      if (cancelled) return;
      if (state2.startTime === 0) {
        state2.startTime = currentTime;
      }
      const elapsed = currentTime - state2.startTime;
      const progress2 = Math.min(elapsed / duration, 1);
      const easedProgress = easing(progress2);
      const deltaTop = state2.targetScrollTop - state2.startScrollTop;
      const deltaLeft = state2.targetScrollLeft - state2.startScrollLeft;
      node2.scrollTop = state2.startScrollTop + deltaTop * easedProgress;
      node2.scrollLeft = state2.startScrollLeft + deltaLeft * easedProgress;
      if (progress2 < 1) {
        state2.rafId = requestAnimationFrame(animate);
      } else {
        onComplete?.();
      }
    };
    state2.rafId = requestAnimationFrame(animate);
    return cleanup;
  }
  function scrollTo(node2, options = {}) {
    if (!node2) return;
    const { top, left, behavior = "smooth", easing, duration } = options;
    if (behavior === "smooth") {
      smoothScroll(node2, { top, left, easing, duration });
    } else {
      const scrollOptions = compact({ behavior, top, left });
      node2.scrollTo(scrollOptions);
    }
  }
  function scrollToEdge(node2, edge, dir, behavior = "smooth", easing, duration) {
    if (!node2) return;
    const maxLeft = node2.scrollWidth - node2.clientWidth;
    const maxTop = node2.scrollHeight - node2.clientHeight;
    const isRtl = dir === "rtl";
    let targetScrollTop;
    let targetScrollLeft;
    switch (edge) {
      case "top":
        targetScrollTop = 0;
        break;
      case "bottom":
        targetScrollTop = maxTop;
        break;
      case "left":
        if (isRtl) {
          const negative = node2.scrollLeft <= 0;
          targetScrollLeft = negative ? -maxLeft : 0;
        } else {
          targetScrollLeft = 0;
        }
        break;
      case "right":
        if (isRtl) {
          const negative = node2.scrollLeft <= 0;
          targetScrollLeft = negative ? 0 : maxLeft;
        } else {
          targetScrollLeft = maxLeft;
        }
        break;
    }
    if (behavior === "smooth") {
      smoothScroll(node2, { top: targetScrollTop, left: targetScrollLeft, easing, duration });
    } else {
      const options = compact({ left: targetScrollLeft, top: targetScrollTop, behavior });
      node2.scrollTo(options);
    }
  }
  function connect$1(service, normalize2) {
    const { state: state2, send, context, prop, scope } = service;
    const dragging = state2.matches("dragging");
    const hovering = context.get("hovering");
    const cornerSize = context.get("cornerSize");
    const thumbSize = context.get("thumbSize");
    const hiddenState = context.get("hiddenState");
    const atSides = context.get("atSides");
    return {
      isAtTop: atSides.top,
      isAtBottom: atSides.bottom,
      isAtLeft: atSides.left,
      isAtRight: atSides.right,
      hasOverflowX: !hiddenState.scrollbarXHidden,
      hasOverflowY: !hiddenState.scrollbarYHidden,
      getScrollProgress() {
        return getScrollProgress(getViewportEl(scope), 0);
      },
      scrollToEdge(details) {
        const { edge, behavior } = details;
        return scrollToEdge(getViewportEl(scope), edge, prop("dir"), behavior);
      },
      scrollTo(details) {
        return scrollTo(getViewportEl(scope), details);
      },
      getScrollbarState(props2) {
        const horizontal = props2.orientation === "horizontal";
        return {
          hovering,
          dragging,
          scrolling: context.get(horizontal ? "scrollingX" : "scrollingY"),
          hidden: horizontal ? hiddenState.scrollbarXHidden : hiddenState.scrollbarYHidden
        };
      },
      getRootProps() {
        return normalize2.element({
          ...parts$1.root.attrs,
          id: getRootId$2(scope),
          dir: prop("dir"),
          role: "presentation",
          "data-overflow-x": dataAttr$1(!hiddenState.scrollbarXHidden),
          "data-overflow-y": dataAttr$1(!hiddenState.scrollbarYHidden),
          onPointerEnter(event) {
            const target = getEventTarget(event);
            if (!contains(event.currentTarget, target)) return;
            send({ type: "root.pointerenter", pointerType: event.pointerType });
          },
          onPointerMove(event) {
            const target = getEventTarget(event);
            if (!contains(event.currentTarget, target)) return;
            send({ type: "root.pointerenter", pointerType: event.pointerType });
          },
          onPointerDown({ pointerType }) {
            send({ type: "root.pointerdown", pointerType });
          },
          onPointerLeave(event) {
            if (contains(event.currentTarget, event.relatedTarget)) return;
            send({ type: "root.pointerleave" });
          },
          style: {
            position: "relative",
            "--corner-width": toPx$1(cornerSize?.width),
            "--corner-height": toPx$1(cornerSize?.height),
            "--thumb-width": toPx$1(thumbSize?.width),
            "--thumb-height": toPx$1(thumbSize?.height)
          }
        });
      },
      getViewportProps() {
        const handleUserInteraction = () => {
          send({ type: "user.scroll" });
        };
        return normalize2.element({
          ...parts$1.viewport.attrs,
          role: "presentation",
          "data-ownedby": getRootId$2(scope),
          id: getViewportId(scope),
          "data-at-top": dataAttr$1(atSides.top),
          "data-at-bottom": dataAttr$1(atSides.bottom),
          "data-at-left": dataAttr$1(atSides.left),
          "data-at-right": dataAttr$1(atSides.right),
          "data-overflow-x": dataAttr$1(!hiddenState.scrollbarXHidden),
          "data-overflow-y": dataAttr$1(!hiddenState.scrollbarYHidden),
          tabIndex: hiddenState.scrollbarXHidden || hiddenState.scrollbarYHidden ? void 0 : 0,
          style: {
            overflow: "auto"
          },
          onScroll(event) {
            send({ type: "viewport.scroll", target: event.currentTarget });
          },
          onWheel: handleUserInteraction,
          onTouchMove: handleUserInteraction,
          onPointerMove: handleUserInteraction,
          onPointerEnter: handleUserInteraction,
          onKeyDown: handleUserInteraction
        });
      },
      getContentProps() {
        return normalize2.element({
          ...parts$1.content.attrs,
          id: getContentId$2(scope),
          role: "presentation",
          "data-overflow-x": dataAttr$1(!hiddenState.scrollbarXHidden),
          "data-overflow-y": dataAttr$1(!hiddenState.scrollbarYHidden),
          style: {
            minWidth: "fit-content"
          }
        });
      },
      getScrollbarProps(props2 = {}) {
        const { orientation = "vertical" } = props2;
        return normalize2.element({
          ...parts$1.scrollbar.attrs,
          "data-ownedby": getRootId$2(scope),
          "data-orientation": orientation,
          "data-scrolling": dataAttr$1(context.get(orientation === "horizontal" ? "scrollingX" : "scrollingY")),
          "data-hover": dataAttr$1(hovering),
          "data-dragging": dataAttr$1(dragging),
          "data-overflow-x": dataAttr$1(!hiddenState.scrollbarXHidden),
          "data-overflow-y": dataAttr$1(!hiddenState.scrollbarYHidden),
          onPointerUp() {
            send({ type: "scrollbar.pointerup", orientation });
          },
          onPointerDown(event) {
            if (event.button !== 0) {
              return;
            }
            if (event.currentTarget !== event.target) {
              return;
            }
            const point = getEventPoint(event);
            send({ type: "scrollbar.pointerdown", orientation, point });
            event.stopPropagation();
          },
          style: {
            position: "absolute",
            touchAction: "none",
            WebkitUserSelect: "none",
            userSelect: "none",
            ...orientation === "vertical" && {
              top: 0,
              bottom: `var(--corner-height)`,
              insetInlineEnd: 0
            },
            ...orientation === "horizontal" && {
              insetInlineStart: 0,
              insetInlineEnd: `var(--corner-width)`,
              bottom: 0
            }
          }
        });
      },
      getThumbProps(props2 = {}) {
        const { orientation = "vertical" } = props2;
        return normalize2.element({
          ...parts$1.thumb.attrs,
          "data-ownedby": getRootId$2(scope),
          "data-orientation": orientation,
          "data-hover": dataAttr$1(hovering),
          "data-dragging": dataAttr$1(dragging),
          onPointerDown(event) {
            if (event.button !== 0) return;
            const point = getEventPoint(event);
            send({ type: "thumb.pointerdown", orientation, point });
          },
          style: {
            ...orientation === "vertical" && {
              height: "var(--thumb-height)"
            },
            ...orientation === "horizontal" && {
              width: "var(--thumb-width)"
            }
          }
        });
      },
      getCornerProps() {
        return normalize2.element({
          ...parts$1.corner.attrs,
          "data-ownedby": getRootId$2(scope),
          "data-hover": dataAttr$1(hovering),
          "data-state": hiddenState.cornerHidden ? "hidden" : "visible",
          "data-overflow-x": dataAttr$1(!hiddenState.scrollbarXHidden),
          "data-overflow-y": dataAttr$1(!hiddenState.scrollbarYHidden),
          style: {
            position: "absolute",
            bottom: 0,
            insetInlineEnd: 0,
            width: "var(--corner-width)",
            height: "var(--corner-height)"
          }
        });
      }
    };
  }
  function getScrollOffset(element, prop, axis) {
    if (!element) return 0;
    const styles = getComputedStyle$3(element);
    const propAxis = axis === "x" ? "Inline" : "Block";
    if (axis === "x" && prop === "margin") {
      return parseFloat(styles[`${prop}InlineStart`]) * 2;
    }
    return parseFloat(styles[`${prop}${propAxis}Start`]) + parseFloat(styles[`${prop}${propAxis}End`]);
  }
  function getScrollSides(node2, dir) {
    const scrollTop = node2.scrollTop;
    const scrollLeft = node2.scrollLeft;
    const isRtl = dir === "rtl";
    const threshold = 1;
    const hasVerticalScroll = node2.scrollHeight - node2.clientHeight > threshold;
    const hasHorizontalScroll = node2.scrollWidth - node2.clientWidth > threshold;
    const maxScrollLeft = node2.scrollWidth - node2.clientWidth;
    const maxScrollTop = node2.scrollHeight - node2.clientHeight;
    let atLeft = false;
    let atRight = false;
    let atTop = false;
    let atBottom = false;
    if (hasHorizontalScroll) {
      if (isRtl) {
        if (scrollLeft <= 0) {
          atLeft = Math.abs(scrollLeft) >= maxScrollLeft - threshold;
          atRight = Math.abs(scrollLeft) <= threshold;
        } else {
          atLeft = scrollLeft <= threshold;
          atRight = scrollLeft >= maxScrollLeft - threshold;
        }
      } else {
        atLeft = scrollLeft <= threshold;
        atRight = scrollLeft >= maxScrollLeft - threshold;
      }
    }
    if (hasVerticalScroll) {
      atTop = scrollTop <= threshold;
      atBottom = scrollTop >= maxScrollTop - threshold;
    }
    return {
      top: atTop,
      right: atRight,
      bottom: atBottom,
      left: atLeft
    };
  }
  var EMPTY = 0;
  var Timeout = class {
    constructor() {
      __publicField$1(this, "currentId", EMPTY);
      __publicField$1(this, "clear", () => {
        if (this.currentId !== EMPTY) {
          clearTimeout(this.currentId);
          this.currentId = EMPTY;
        }
      });
      __publicField$1(this, "disposeEffect", () => {
        return this.clear;
      });
    }
    start(delay2, fn) {
      this.clear();
      this.currentId = setTimeout(() => {
        this.currentId = EMPTY;
        fn();
      }, delay2);
    }
    isStarted() {
      return this.currentId !== EMPTY;
    }
  };
  var MIN_THUMB_SIZE = 20;
  var SCROLL_TIMEOUT = 1e3;
  var machine$1 = createMachine$4({
    props({ props: props2 }) {
      ensureProps(props2, ["id"]);
      return props2;
    },
    context({ bindable }) {
      return {
        scrollingX: bindable(() => ({ defaultValue: false })),
        scrollingY: bindable(() => ({ defaultValue: false })),
        hovering: bindable(() => ({ defaultValue: false })),
        dragging: bindable(() => ({ defaultValue: false })),
        touchModality: bindable(() => ({ defaultValue: false })),
        atSides: bindable(() => ({
          defaultValue: { top: true, right: false, bottom: false, left: true }
        })),
        cornerSize: bindable(() => ({
          defaultValue: { width: 0, height: 0 }
        })),
        thumbSize: bindable(() => ({
          defaultValue: { width: 0, height: 0 }
        })),
        hiddenState: bindable(() => ({
          defaultValue: {
            scrollbarYHidden: false,
            scrollbarXHidden: false,
            cornerHidden: false
          },
          hash(a) {
            return `Y:${a.scrollbarYHidden} X:${a.scrollbarXHidden} C:${a.cornerHidden}`;
          }
        }))
      };
    },
    refs() {
      return {
        orientation: "vertical",
        scrollPosition: { x: 0, y: 0 },
        scrollYTimeout: new Timeout(),
        scrollXTimeout: new Timeout(),
        scrollEndTimeout: new Timeout(),
        startX: 0,
        startY: 0,
        startScrollTop: 0,
        startScrollLeft: 0,
        programmaticScroll: true
      };
    },
    initialState() {
      return "idle";
    },
    watch({ track, prop, context, send }) {
      track([() => prop("dir"), () => context.hash("hiddenState")], () => {
        send({ type: "thumb.measure" });
      });
    },
    effects: ["trackContentResize", "trackViewportVisibility", "trackWheelEvent"],
    entry: ["checkHovering"],
    exit: ["clearTimeouts"],
    on: {
      "thumb.measure": {
        actions: ["setThumbSize"]
      },
      "viewport.scroll": {
        actions: ["setThumbSize", "setScrolling", "setProgrammaticScroll"]
      },
      "root.pointerenter": {
        actions: ["setTouchModality", "setHovering"]
      },
      "root.pointerdown": {
        actions: ["setTouchModality"]
      },
      "root.pointerleave": {
        actions: ["clearHovering"]
      }
    },
    states: {
      idle: {
        on: {
          "scrollbar.pointerdown": {
            target: "dragging",
            actions: ["scrollToPointer", "startDragging"]
          },
          "thumb.pointerdown": {
            target: "dragging",
            actions: ["startDragging"]
          }
        }
      },
      dragging: {
        effects: ["trackPointerMove"],
        on: {
          "thumb.pointermove": {
            actions: ["setDraggingScroll"]
          },
          "scrollbar.pointerup": {
            target: "idle",
            actions: ["stopDragging"]
          },
          "thumb.pointerup": {
            target: "idle",
            actions: ["clearScrolling", "stopDragging"]
          }
        }
      }
    },
    implementations: {
      actions: {
        setTouchModality({ context, event }) {
          context.set("touchModality", event.pointerType === "touch");
        },
        setHovering({ context }) {
          context.set("hovering", true);
        },
        clearHovering({ context }) {
          context.set("hovering", false);
        },
        setProgrammaticScroll({ refs }) {
          const scrollEndTimeout = refs.get("scrollEndTimeout");
          scrollEndTimeout.start(100, () => {
            refs.set("programmaticScroll", true);
          });
        },
        clearScrolling({ context, event }) {
          context.set(event.orientation === "vertical" ? "scrollingY" : "scrollingX", false);
        },
        setThumbSize({ context, scope, prop }) {
          const viewportEl = getViewportEl(scope);
          if (!viewportEl) return;
          const scrollableContentHeight = viewportEl.scrollHeight;
          const scrollableContentWidth = viewportEl.scrollWidth;
          if (scrollableContentHeight === 0 || scrollableContentWidth === 0) return;
          const scrollbarYEl = getScrollbarYEl(scope);
          const scrollbarXEl = getScrollbarXEl(scope);
          const thumbYEl = getThumbYEl(scope);
          const thumbXEl = getThumbXEl(scope);
          const viewportHeight = viewportEl.clientHeight;
          const viewportWidth = viewportEl.clientWidth;
          const scrollTop = viewportEl.scrollTop;
          const scrollLeft = viewportEl.scrollLeft;
          const scrollbarYHidden = viewportHeight >= scrollableContentHeight;
          const scrollbarXHidden = viewportWidth >= scrollableContentWidth;
          const ratioX = viewportWidth / scrollableContentWidth;
          const ratioY = viewportHeight / scrollableContentHeight;
          const nextWidth = scrollbarXHidden ? 0 : viewportWidth;
          const nextHeight = scrollbarYHidden ? 0 : viewportHeight;
          const scrollbarXOffset = getScrollOffset(scrollbarXEl, "padding", "x");
          const scrollbarYOffset = getScrollOffset(scrollbarYEl, "padding", "y");
          const thumbXOffset = getScrollOffset(thumbXEl, "margin", "x");
          const thumbYOffset = getScrollOffset(thumbYEl, "margin", "y");
          const idealNextWidth = nextWidth - scrollbarXOffset - thumbXOffset;
          const idealNextHeight = nextHeight - scrollbarYOffset - thumbYOffset;
          const maxNextWidth = scrollbarXEl ? Math.min(scrollbarXEl.offsetWidth, idealNextWidth) : idealNextWidth;
          const maxNextHeight = scrollbarYEl ? Math.min(scrollbarYEl.offsetHeight, idealNextHeight) : idealNextHeight;
          const clampedNextWidth = Math.max(MIN_THUMB_SIZE, maxNextWidth * ratioX);
          const clampedNextHeight = Math.max(MIN_THUMB_SIZE, maxNextHeight * ratioY);
          context.set("thumbSize", (prevSize) => {
            if (prevSize.height === clampedNextHeight && prevSize.width === clampedNextWidth) {
              return prevSize;
            }
            return {
              width: clampedNextWidth,
              height: clampedNextHeight
            };
          });
          if (scrollbarYEl && thumbYEl) {
            const maxThumbOffsetY = scrollbarYEl.offsetHeight - clampedNextHeight - scrollbarYOffset - thumbYOffset;
            const scrollRatioY = scrollTop / (scrollableContentHeight - viewportHeight);
            const thumbOffsetY = Math.min(maxThumbOffsetY, Math.max(0, scrollRatioY * maxThumbOffsetY));
            thumbYEl.style.transform = `translate3d(0,${thumbOffsetY}px,0)`;
          }
          if (scrollbarXEl && thumbXEl) {
            const maxThumbOffsetX = scrollbarXEl.offsetWidth - clampedNextWidth - scrollbarXOffset - thumbXOffset;
            const scrollRatioX = scrollLeft / (scrollableContentWidth - viewportWidth);
            const thumbOffsetX = prop("dir") === "rtl" ? clampValue(scrollRatioX * maxThumbOffsetX, -maxThumbOffsetX, 0) : clampValue(scrollRatioX * maxThumbOffsetX, 0, maxThumbOffsetX);
            thumbXEl.style.transform = `translate3d(${thumbOffsetX}px,0,0)`;
          }
          const cornerEl = getCornerEl(scope);
          if (cornerEl) {
            if (scrollbarXHidden || scrollbarYHidden) {
              context.set("cornerSize", { width: 0, height: 0 });
            } else if (!scrollbarXHidden && !scrollbarYHidden) {
              const width = scrollbarYEl?.offsetWidth || 0;
              const height = scrollbarXEl?.offsetHeight || 0;
              context.set("cornerSize", { width, height });
            }
          }
          context.set("hiddenState", (prevState) => {
            const cornerHidden = scrollbarYHidden || scrollbarXHidden;
            if (prevState.scrollbarYHidden === scrollbarYHidden && prevState.scrollbarXHidden === scrollbarXHidden && prevState.cornerHidden === cornerHidden) {
              return prevState;
            }
            return {
              scrollbarYHidden,
              scrollbarXHidden,
              cornerHidden
            };
          });
          context.set("atSides", (prev2) => {
            const next2 = getScrollSides(viewportEl, prop("dir"));
            if (isEqual(prev2, next2)) return prev2;
            return next2;
          });
        },
        checkHovering({ scope, context }) {
          const viewportEl = getViewportEl(scope);
          if (viewportEl?.matches(":hover")) {
            context.set("hovering", true);
          }
        },
        setScrolling({ event, refs, context, prop }) {
          const scrollPosition = {
            x: event.target.scrollLeft,
            y: event.target.scrollTop
          };
          const scrollPositionRef = refs.get("scrollPosition");
          const offsetX = scrollPosition.x - scrollPositionRef.x;
          const offsetY = scrollPosition.y - scrollPositionRef.y;
          refs.set("scrollPosition", scrollPosition);
          context.set("atSides", (prev2) => {
            const next2 = getScrollSides(event.target, prop("dir"));
            if (isEqual(prev2, next2)) return prev2;
            return next2;
          });
          if (offsetY !== 0) {
            context.set("scrollingY", true);
            refs.get("scrollYTimeout").start(SCROLL_TIMEOUT, () => {
              context.set("scrollingY", false);
            });
          }
          if (offsetX !== 0) {
            context.set("scrollingX", true);
            refs.get("scrollXTimeout").start(SCROLL_TIMEOUT, () => {
              context.set("scrollingX", false);
            });
          }
        },
        scrollToPointer({ event, scope, prop }) {
          const viewportEl = getViewportEl(scope);
          if (!viewportEl) return;
          const thumbYRef = getThumbYEl(scope);
          const scrollbarYRef = getScrollbarYEl(scope);
          const thumbXRef = getThumbXEl(scope);
          const scrollbarXRef = getScrollbarXEl(scope);
          const client2 = event.point;
          if (thumbYRef && scrollbarYRef && event.orientation === "vertical") {
            const thumbYOffset = getScrollOffset(thumbYRef, "margin", "y");
            const scrollbarYOffset = getScrollOffset(scrollbarYRef, "padding", "y");
            const thumbHeight = thumbYRef.offsetHeight;
            const trackRectY = scrollbarYRef.getBoundingClientRect();
            const clickY = client2.y - trackRectY.top - thumbHeight / 2 - scrollbarYOffset + thumbYOffset / 2;
            const scrollableContentHeight = viewportEl.scrollHeight;
            const viewportHeight = viewportEl.clientHeight;
            const maxThumbOffsetY = scrollbarYRef.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
            const scrollRatioY = clickY / maxThumbOffsetY;
            const newScrollTop = scrollRatioY * (scrollableContentHeight - viewportHeight);
            viewportEl.scrollTop = newScrollTop;
          }
          if (thumbXRef && scrollbarXRef && event.orientation === "horizontal") {
            const thumbXOffset = getScrollOffset(thumbXRef, "margin", "x");
            const scrollbarXOffset = getScrollOffset(scrollbarXRef, "padding", "x");
            const thumbWidth = thumbXRef.offsetWidth;
            const trackRectX = scrollbarXRef.getBoundingClientRect();
            const clickX = client2.x - trackRectX.left - thumbWidth / 2 - scrollbarXOffset + thumbXOffset / 2;
            const scrollableContentWidth = viewportEl.scrollWidth;
            const viewportWidth = viewportEl.clientWidth;
            const maxThumbOffsetX = scrollbarXRef.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
            const scrollRatioX = clickX / maxThumbOffsetX;
            let newScrollLeft;
            if (prop("dir") === "rtl") {
              newScrollLeft = (1 - scrollRatioX) * (scrollableContentWidth - viewportWidth);
              if (viewportEl.scrollLeft <= 0) {
                newScrollLeft = -newScrollLeft;
              }
            } else {
              newScrollLeft = scrollRatioX * (scrollableContentWidth - viewportWidth);
            }
            viewportEl.scrollLeft = newScrollLeft;
          }
        },
        startDragging({ event, refs, scope }) {
          refs.set("startX", event.point.x);
          refs.set("startY", event.point.y);
          refs.set("orientation", event.orientation);
          const viewportEl = getViewportEl(scope);
          if (!viewportEl) return;
          refs.set("startScrollTop", viewportEl.scrollTop);
          refs.set("startScrollLeft", viewportEl.scrollLeft);
        },
        setDraggingScroll({ event, refs, scope, context }) {
          const startY = refs.get("startY");
          const startX = refs.get("startX");
          const startScrollTop = refs.get("startScrollTop");
          const startScrollLeft = refs.get("startScrollLeft");
          const client2 = event.point;
          const deltaY = client2.y - startY;
          const deltaX = client2.x - startX;
          const viewportEl = getViewportEl(scope);
          if (!viewportEl) return;
          const scrollableContentHeight = viewportEl.scrollHeight;
          const viewportHeight = viewportEl.clientHeight;
          const scrollableContentWidth = viewportEl.scrollWidth;
          const viewportWidth = viewportEl.clientWidth;
          const orientation = refs.get("orientation");
          const thumbYEl = getThumbYEl(scope);
          const scrollbarYEl = getScrollbarYEl(scope);
          if (thumbYEl && scrollbarYEl && orientation === "vertical") {
            const scrollbarYOffset = getScrollOffset(scrollbarYEl, "padding", "y");
            const thumbYOffset = getScrollOffset(thumbYEl, "margin", "y");
            const thumbHeight = thumbYEl.offsetHeight;
            const maxThumbOffsetY = scrollbarYEl.offsetHeight - thumbHeight - scrollbarYOffset - thumbYOffset;
            const scrollRatioY = deltaY / maxThumbOffsetY;
            viewportEl.scrollTop = startScrollTop + scrollRatioY * (scrollableContentHeight - viewportHeight);
            context.set("scrollingY", true);
            refs.get("scrollYTimeout").start(SCROLL_TIMEOUT, () => {
              context.set("scrollingY", false);
            });
          }
          const thumbXEl = getThumbXEl(scope);
          const scrollbarXEl = getScrollbarXEl(scope);
          if (thumbXEl && scrollbarXEl && orientation === "horizontal") {
            const scrollbarXOffset = getScrollOffset(scrollbarXEl, "padding", "x");
            const thumbXOffset = getScrollOffset(thumbXEl, "margin", "x");
            const thumbWidth = thumbXEl.offsetWidth;
            const maxThumbOffsetX = scrollbarXEl.offsetWidth - thumbWidth - scrollbarXOffset - thumbXOffset;
            const scrollRatioX = deltaX / maxThumbOffsetX;
            viewportEl.scrollLeft = startScrollLeft + scrollRatioX * (scrollableContentWidth - viewportWidth);
            context.set("scrollingX", true);
            refs.get("scrollXTimeout").start(SCROLL_TIMEOUT, () => {
              context.set("scrollingX", false);
            });
          }
        },
        stopDragging({ refs }) {
          refs.set("orientation", null);
        },
        clearTimeouts({ refs }) {
          refs.get("scrollYTimeout").clear();
          refs.get("scrollXTimeout").clear();
          refs.get("scrollEndTimeout").clear();
        }
      },
      effects: {
        trackContentResize({ scope, send }) {
          const contentEl = getContentEl$2(scope);
          const rootEl = getRootEl$1(scope);
          if (!contentEl || !rootEl) return;
          const win = scope.getWin();
          const obs = new win.ResizeObserver(() => {
            setTimeout(() => {
              send({ type: "thumb.measure" });
            }, 1);
          });
          obs.observe(contentEl);
          obs.observe(rootEl);
          return () => {
            obs.disconnect();
          };
        },
        trackViewportVisibility({ scope, send }) {
          const win = scope.getWin();
          const viewportEl = getViewportEl(scope);
          if (!viewportEl) return;
          const observer = new win.IntersectionObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.intersectionRatio > 0) {
                send({ type: "thumb.measure" });
                observer.disconnect();
              }
            });
          });
          observer.observe(viewportEl);
          return () => {
            observer.disconnect();
          };
        },
        trackWheelEvent({ scope }) {
          const scrollbarYEl = getScrollbarYEl(scope);
          const scrollbarXEl = getScrollbarXEl(scope);
          if (!scrollbarYEl && !scrollbarXEl) return;
          const onWheel = (event) => {
            const viewportEl = getViewportEl(scope);
            if (!viewportEl || event.ctrlKey) return;
            const orientation = event.currentTarget.dataset.orientation;
            if (orientation === "vertical") {
              const canScrollY = viewportEl.scrollHeight > viewportEl.clientHeight;
              const atTop = viewportEl.scrollTop === 0 && event.deltaY < 0;
              const atBottom = viewportEl.scrollTop === viewportEl.scrollHeight - viewportEl.clientHeight && event.deltaY > 0;
              const shouldScroll = canScrollY && event.deltaY !== 0 && !(atTop || atBottom);
              if (!shouldScroll) return;
              event.preventDefault();
              viewportEl.scrollTop += event.deltaY;
            } else if (orientation === "horizontal") {
              const canScrollX = viewportEl.scrollWidth > viewportEl.clientWidth;
              const atLeft = viewportEl.scrollLeft === 0 && event.deltaX < 0;
              const atRight = viewportEl.scrollLeft === viewportEl.scrollWidth - viewportEl.clientWidth && event.deltaX > 0;
              const shouldScroll = canScrollX && event.deltaX !== 0 && !(atLeft || atRight);
              if (!shouldScroll) return;
              event.preventDefault();
              viewportEl.scrollLeft += event.deltaX;
            }
          };
          return callAll(
            scrollbarYEl && addDomEvent$1(scrollbarYEl, "wheel", onWheel, { passive: false }),
            scrollbarXEl && addDomEvent$1(scrollbarXEl, "wheel", onWheel, { passive: false })
          );
        },
        trackPointerMove({ scope, send, refs }) {
          const doc = scope.getDoc();
          const orientation = refs.get("orientation");
          return trackPointerMove(doc, {
            onPointerMove({ point }) {
              send({ type: "thumb.pointermove", orientation, point });
            },
            onPointerUp() {
              send({ type: "thumb.pointerup", orientation });
            }
          });
        }
      }
    }
  });
  createProps$1()(["dir", "getRootNode", "ids", "id"]);
  const useScrollArea = (props) => {
    const id2 = reactExports.useId();
    const { getRootNode: getRootNode2 } = useEnvironmentContext();
    const { dir } = useLocaleContext();
    const context = {
      id: id2,
      dir,
      getRootNode: getRootNode2,
      ...props
    };
    const service = useMachine(machine$1, context);
    return connect$1(service, normalizeProps);
  };
  const splitRootProps$1 = createSplitProps();
  const ScrollAreaRoot$1 = reactExports.forwardRef((props, ref) => {
    const [useScrollAreaProps, localProps] = splitRootProps$1(props, ["id", "ids"]);
    const scrollArea = useScrollArea(useScrollAreaProps);
    const mergedProps = mergeProps(scrollArea.getRootProps(), localProps);
    return jsxRuntimeExports.jsx(ScrollAreaProvider, { value: scrollArea, children: jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
  });
  ScrollAreaRoot$1.displayName = "ScrollAreaRoot";
  const splitRootProviderProps$1 = createSplitProps();
  const ScrollAreaRootProvider = reactExports.forwardRef((props, ref) => {
    const [{ value: scrollArea }, localProps] = splitRootProviderProps$1(props, ["value"]);
    const mergedProps = mergeProps(scrollArea.getRootProps(), localProps);
    return jsxRuntimeExports.jsx(ScrollAreaProvider, { value: scrollArea, children: jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
  });
  ScrollAreaRootProvider.displayName = "ScrollAreaRootProvider";
  const [ScrollAreaScrollbarProvider, useScrollAreaScrollbarContext] = createContext({
    name: "ScrollAreaScrollbarContext",
    hookName: "useScrollAreaScrollbarContext",
    providerName: "<ScrollAreaScrollbarProvider />"
  });
  const splitScrollbarProps = createSplitProps();
  const ScrollAreaScrollbar = reactExports.forwardRef((props, ref) => {
    const [scrollbarProps, localProps] = splitScrollbarProps(props, ["orientation"]);
    const scrollAreaApi = useScrollAreaContext();
    const mergedProps = mergeProps(scrollAreaApi.getScrollbarProps(scrollbarProps), localProps);
    return jsxRuntimeExports.jsx(ScrollAreaScrollbarProvider, { value: scrollbarProps, children: jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) });
  });
  ScrollAreaScrollbar.displayName = "ScrollAreaScrollbar";
  const ScrollAreaThumb$1 = reactExports.forwardRef((props, ref) => {
    const scrollAreaApi = useScrollAreaContext();
    const scrollbarProps = useScrollAreaScrollbarContext();
    const mergedProps = mergeProps(scrollAreaApi.getThumbProps(scrollbarProps), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  ScrollAreaThumb$1.displayName = "ScrollAreaThumb";
  const ScrollAreaViewport$1 = reactExports.forwardRef((props, ref) => {
    const scrollArea = useScrollAreaContext();
    const mergedProps = mergeProps(scrollArea.getViewportProps(), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  ScrollAreaViewport$1.displayName = "ScrollAreaViewport";
  const segmentGroupAnatomy = anatomy$8.rename("segment-group");
  segmentGroupAnatomy.build();
  var anatomy$5 = createAnatomy("select").parts(
    "label",
    "positioner",
    "trigger",
    "indicator",
    "clearTrigger",
    "item",
    "itemText",
    "itemIndicator",
    "itemGroup",
    "itemGroupLabel",
    "list",
    "content",
    "root",
    "control",
    "valueText"
  );
  anatomy$5.build();
  var collection = (options) => {
    return new ListCollection(options);
  };
  collection.empty = () => {
    return new ListCollection({ items: [] });
  };
  var getContentId$1 = (ctx) => ctx.ids?.content ?? `select:${ctx.id}:content`;
  var getTriggerId$2 = (ctx) => ctx.ids?.trigger ?? `select:${ctx.id}:trigger`;
  var getClearTriggerId = (ctx) => ctx.ids?.clearTrigger ?? `select:${ctx.id}:clear-trigger`;
  var getItemId$1 = (ctx, id2) => ctx.ids?.item?.(id2) ?? `select:${ctx.id}:option:${id2}`;
  var getHiddenSelectId = (ctx) => ctx.ids?.hiddenSelect ?? `select:${ctx.id}:select`;
  var getPositionerId$1 = (ctx) => ctx.ids?.positioner ?? `select:${ctx.id}:positioner`;
  var getHiddenSelectEl = (ctx) => ctx.getById(getHiddenSelectId(ctx));
  var getContentEl$1 = (ctx) => ctx.getById(getContentId$1(ctx));
  var getTriggerEl$2 = (ctx) => ctx.getById(getTriggerId$2(ctx));
  var getClearTriggerEl = (ctx) => ctx.getById(getClearTriggerId(ctx));
  var getPositionerEl$1 = (ctx) => ctx.getById(getPositionerId$1(ctx));
  var getItemEl = (ctx, id2) => {
    if (id2 == null) return null;
    return ctx.getById(getItemId$1(ctx, id2));
  };
  var { and: and$2, not: not$2, or: or$1 } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        loopFocus: false,
        closeOnSelect: !props2.multiple,
        composite: true,
        defaultValue: [],
        ...props2,
        collection: props2.collection ?? collection.empty(),
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...props2.positioning
        }
      };
    },
    context({ prop, bindable }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          isEqual,
          onChange(value) {
            const items = prop("collection").findMany(value);
            return prop("onValueChange")?.({ value, items });
          }
        })),
        highlightedValue: bindable(() => ({
          defaultValue: prop("defaultHighlightedValue") || null,
          value: prop("highlightedValue"),
          onChange(value) {
            prop("onHighlightChange")?.({
              highlightedValue: value,
              highlightedItem: prop("collection").find(value),
              highlightedIndex: prop("collection").indexOf(value)
            });
          }
        })),
        currentPlacement: bindable(() => ({
          defaultValue: void 0
        })),
        fieldsetDisabled: bindable(() => ({
          defaultValue: false
        })),
        highlightedItem: bindable(() => ({
          defaultValue: null
        })),
        selectedItems: bindable(() => {
          const value = prop("value") ?? prop("defaultValue") ?? [];
          const items = prop("collection").findMany(value);
          return { defaultValue: items };
        })
      };
    },
    refs() {
      return {
        typeahead: { ...getByTypeahead.defaultOptions }
      };
    },
    computed: {
      hasSelectedItems: ({ context }) => context.get("value").length > 0,
      isTypingAhead: ({ refs }) => refs.get("typeahead").keysSoFar !== "",
      isDisabled: ({ prop, context }) => !!prop("disabled") || !!context.get("fieldsetDisabled"),
      isInteractive: ({ prop }) => !(prop("disabled") || prop("readOnly")),
      valueAsString: ({ context, prop }) => prop("collection").stringifyItems(context.get("selectedItems"))
    },
    initialState({ prop }) {
      const open = prop("open") || prop("defaultOpen");
      return open ? "open" : "idle";
    },
    entry: ["syncSelectElement"],
    watch({ context, prop, track, action }) {
      track([() => context.get("value").toString()], () => {
        action(["syncSelectedItems", "syncSelectElement", "dispatchChangeEvent"]);
      });
      track([() => prop("open")], () => {
        action(["toggleVisibility"]);
      });
      track([() => context.get("highlightedValue")], () => {
        action(["syncHighlightedItem"]);
      });
      track([() => prop("collection").toString()], () => {
        action(["syncCollection"]);
      });
    },
    on: {
      "HIGHLIGHTED_VALUE.SET": {
        actions: ["setHighlightedItem"]
      },
      "HIGHLIGHTED_VALUE.CLEAR": {
        actions: ["clearHighlightedItem"]
      },
      "ITEM.SELECT": {
        actions: ["selectItem"]
      },
      "ITEM.CLEAR": {
        actions: ["clearItem"]
      },
      "VALUE.SET": {
        actions: ["setSelectedItems"]
      },
      "VALUE.CLEAR": {
        actions: ["clearSelectedItems"]
      },
      "CLEAR.CLICK": {
        actions: ["clearSelectedItems", "focusTriggerEl"]
      }
    },
    effects: ["trackFormControlState"],
    states: {
      idle: {
        tags: ["closed"],
        on: {
          "CONTROLLED.OPEN": [
            {
              guard: "isTriggerClickEvent",
              target: "open",
              actions: ["setInitialFocus", "highlightFirstSelectedItem"]
            },
            {
              target: "open",
              actions: ["setInitialFocus"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen", "setInitialFocus", "highlightFirstSelectedItem"]
            }
          ],
          "TRIGGER.FOCUS": {
            target: "focused"
          },
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen"]
            }
          ]
        }
      },
      focused: {
        tags: ["closed"],
        on: {
          "CONTROLLED.OPEN": [
            {
              guard: "isTriggerClickEvent",
              target: "open",
              actions: ["setInitialFocus", "highlightFirstSelectedItem"]
            },
            {
              guard: "isTriggerArrowUpEvent",
              target: "open",
              actions: ["setInitialFocus", "highlightComputedLastItem"]
            },
            {
              guard: or$1("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
              target: "open",
              actions: ["setInitialFocus", "highlightComputedFirstItem"]
            },
            {
              target: "open",
              actions: ["setInitialFocus"]
            }
          ],
          OPEN: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen"]
            }
          ],
          "TRIGGER.BLUR": {
            target: "idle"
          },
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen", "highlightFirstSelectedItem"]
            }
          ],
          "TRIGGER.ENTER": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
            }
          ],
          "TRIGGER.ARROW_UP": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedLastItem"]
            }
          ],
          "TRIGGER.ARROW_DOWN": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setInitialFocus", "invokeOnOpen", "highlightComputedFirstItem"]
            }
          ],
          "TRIGGER.ARROW_LEFT": [
            {
              guard: and$2(not$2("multiple"), "hasSelectedItems"),
              actions: ["selectPreviousItem"]
            },
            {
              guard: not$2("multiple"),
              actions: ["selectLastItem"]
            }
          ],
          "TRIGGER.ARROW_RIGHT": [
            {
              guard: and$2(not$2("multiple"), "hasSelectedItems"),
              actions: ["selectNextItem"]
            },
            {
              guard: not$2("multiple"),
              actions: ["selectFirstItem"]
            }
          ],
          "TRIGGER.HOME": {
            guard: not$2("multiple"),
            actions: ["selectFirstItem"]
          },
          "TRIGGER.END": {
            guard: not$2("multiple"),
            actions: ["selectLastItem"]
          },
          "TRIGGER.TYPEAHEAD": {
            guard: not$2("multiple"),
            actions: ["selectMatchingItem"]
          }
        }
      },
      open: {
        tags: ["open"],
        exit: ["scrollContentToTop"],
        effects: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
        on: {
          "CONTROLLED.CLOSE": [
            {
              guard: "restoreFocus",
              target: "focused",
              actions: ["focusTriggerEl", "clearHighlightedItem"]
            },
            {
              target: "idle",
              actions: ["clearHighlightedItem"]
            }
          ],
          CLOSE: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              guard: "restoreFocus",
              target: "focused",
              actions: ["invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
            },
            {
              target: "idle",
              actions: ["invokeOnClose", "clearHighlightedItem"]
            }
          ],
          "TRIGGER.CLICK": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "focused",
              actions: ["invokeOnClose", "clearHighlightedItem"]
            }
          ],
          "ITEM.CLICK": [
            {
              guard: and$2("closeOnSelect", "isOpenControlled"),
              actions: ["selectHighlightedItem", "invokeOnClose"]
            },
            {
              guard: "closeOnSelect",
              target: "focused",
              actions: ["selectHighlightedItem", "invokeOnClose", "focusTriggerEl", "clearHighlightedItem"]
            },
            {
              actions: ["selectHighlightedItem"]
            }
          ],
          "CONTENT.HOME": {
            actions: ["highlightFirstItem"]
          },
          "CONTENT.END": {
            actions: ["highlightLastItem"]
          },
          "CONTENT.ARROW_DOWN": [
            {
              guard: and$2("hasHighlightedItem", "loop", "isLastItemHighlighted"),
              actions: ["highlightFirstItem"]
            },
            {
              guard: "hasHighlightedItem",
              actions: ["highlightNextItem"]
            },
            {
              actions: ["highlightFirstItem"]
            }
          ],
          "CONTENT.ARROW_UP": [
            {
              guard: and$2("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
              actions: ["highlightLastItem"]
            },
            {
              guard: "hasHighlightedItem",
              actions: ["highlightPreviousItem"]
            },
            {
              actions: ["highlightLastItem"]
            }
          ],
          "CONTENT.TYPEAHEAD": {
            actions: ["highlightMatchingItem"]
          },
          "ITEM.POINTER_MOVE": {
            actions: ["highlightItem"]
          },
          "ITEM.POINTER_LEAVE": {
            actions: ["clearHighlightedItem"]
          },
          "POSITIONING.SET": {
            actions: ["reposition"]
          }
        }
      }
    },
    implementations: {
      guards: {
        loop: ({ prop }) => !!prop("loopFocus"),
        multiple: ({ prop }) => !!prop("multiple"),
        hasSelectedItems: ({ computed }) => !!computed("hasSelectedItems"),
        hasHighlightedItem: ({ context }) => context.get("highlightedValue") != null,
        isFirstItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").firstValue,
        isLastItemHighlighted: ({ context, prop }) => context.get("highlightedValue") === prop("collection").lastValue,
        closeOnSelect: ({ prop, event }) => !!(event.closeOnSelect ?? prop("closeOnSelect")),
        restoreFocus: ({ event }) => restoreFocusFn(event),
isOpenControlled: ({ prop }) => prop("open") !== void 0,
        isTriggerClickEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.CLICK",
        isTriggerEnterEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ENTER",
        isTriggerArrowUpEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_UP",
        isTriggerArrowDownEvent: ({ event }) => event.previousEvent?.type === "TRIGGER.ARROW_DOWN"
      },
      effects: {
        trackFormControlState({ context, scope }) {
          return trackFormControl(getHiddenSelectEl(scope), {
            onFieldsetDisabledChange(disabled) {
              context.set("fieldsetDisabled", disabled);
            },
            onFormReset() {
              const value = context.initial("value");
              context.set("value", value);
            }
          });
        },
        trackDismissableElement({ scope, send, prop }) {
          const contentEl = () => getContentEl$1(scope);
          let restoreFocus = true;
          return trackDismissableElement(contentEl, {
            type: "listbox",
            defer: true,
            exclude: [getTriggerEl$2(scope), getClearTriggerEl(scope)],
            onFocusOutside: prop("onFocusOutside"),
            onPointerDownOutside: prop("onPointerDownOutside"),
            onInteractOutside(event) {
              prop("onInteractOutside")?.(event);
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        computePlacement({ context, prop, scope }) {
          const positioning = prop("positioning");
          context.set("currentPlacement", positioning.placement);
          const triggerEl = () => getTriggerEl$2(scope);
          const positionerEl = () => getPositionerEl$1(scope);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...positioning,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        scrollToHighlightedItem({ context, prop, scope, event }) {
          const exec = (immediate) => {
            const highlightedValue = context.get("highlightedValue");
            if (highlightedValue == null) return;
            if (event.current().type.includes("POINTER")) return;
            const contentEl2 = getContentEl$1(scope);
            const scrollToIndexFn = prop("scrollToIndexFn");
            if (scrollToIndexFn) {
              const highlightedIndex = prop("collection").indexOf(highlightedValue);
              scrollToIndexFn?.({
                index: highlightedIndex,
                immediate,
                getElement: () => getItemEl(scope, highlightedValue)
              });
              return;
            }
            const itemEl = getItemEl(scope, highlightedValue);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec(true));
          const contentEl = () => getContentEl$1(scope);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec(false);
            }
          });
        }
      },
      actions: {
        reposition({ context, prop, scope, event }) {
          const positionerEl = () => getPositionerEl$1(scope);
          getPlacement(getTriggerEl$2(scope), positionerEl, {
            ...prop("positioning"),
            ...event.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        toggleVisibility({ send, prop, event }) {
          send({ type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: event });
        },
        highlightPreviousItem({ context, prop }) {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          const value = prop("collection").getPreviousValue(highlightedValue, 1, prop("loopFocus"));
          if (value == null) return;
          context.set("highlightedValue", value);
        },
        highlightNextItem({ context, prop }) {
          const highlightedValue = context.get("highlightedValue");
          if (highlightedValue == null) return;
          const value = prop("collection").getNextValue(highlightedValue, 1, prop("loopFocus"));
          if (value == null) return;
          context.set("highlightedValue", value);
        },
        highlightFirstItem({ context, prop }) {
          const value = prop("collection").firstValue;
          context.set("highlightedValue", value);
        },
        highlightLastItem({ context, prop }) {
          const value = prop("collection").lastValue;
          context.set("highlightedValue", value);
        },
        setInitialFocus({ scope }) {
          raf(() => {
            const element = getInitialFocus({
              root: getContentEl$1(scope)
            });
            element?.focus({ preventScroll: true });
          });
        },
        focusTriggerEl({ event, scope }) {
          if (!restoreFocusFn(event)) return;
          raf(() => {
            const element = getTriggerEl$2(scope);
            element?.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem({ context, prop, event }) {
          let value = event.value ?? context.get("highlightedValue");
          if (value == null || !prop("collection").has(value)) return;
          prop("onSelect")?.({ value });
          const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(value);
          value = nullable ? null : value;
          context.set("value", (prev2) => {
            if (value == null) return [];
            if (prop("multiple")) return addOrRemove(prev2, value);
            return [value];
          });
        },
        highlightComputedFirstItem({ context, prop, computed }) {
          const collection2 = prop("collection");
          const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.firstValue;
          context.set("highlightedValue", value);
        },
        highlightComputedLastItem({ context, prop, computed }) {
          const collection2 = prop("collection");
          const value = computed("hasSelectedItems") ? collection2.sort(context.get("value"))[0] : collection2.lastValue;
          context.set("highlightedValue", value);
        },
        highlightFirstSelectedItem({ context, prop, computed }) {
          if (!computed("hasSelectedItems")) return;
          const value = prop("collection").sort(context.get("value"))[0];
          context.set("highlightedValue", value);
        },
        highlightItem({ context, event }) {
          context.set("highlightedValue", event.value);
        },
        highlightMatchingItem({ context, prop, event, refs }) {
          const value = prop("collection").search(event.key, {
            state: refs.get("typeahead"),
            currentValue: context.get("highlightedValue")
          });
          if (value == null) return;
          context.set("highlightedValue", value);
        },
        setHighlightedItem({ context, event }) {
          context.set("highlightedValue", event.value);
        },
        clearHighlightedItem({ context }) {
          context.set("highlightedValue", null);
        },
        selectItem({ context, prop, event }) {
          prop("onSelect")?.({ value: event.value });
          const nullable = prop("deselectable") && !prop("multiple") && context.get("value").includes(event.value);
          const value = nullable ? null : event.value;
          context.set("value", (prev2) => {
            if (value == null) return [];
            if (prop("multiple")) return addOrRemove(prev2, value);
            return [value];
          });
        },
        clearItem({ context, event }) {
          context.set("value", (prev2) => prev2.filter((v) => v !== event.value));
        },
        setSelectedItems({ context, event }) {
          context.set("value", event.value);
        },
        clearSelectedItems({ context }) {
          context.set("value", []);
        },
        selectPreviousItem({ context, prop }) {
          const [firstItem] = context.get("value");
          const value = prop("collection").getPreviousValue(firstItem);
          if (value) context.set("value", [value]);
        },
        selectNextItem({ context, prop }) {
          const [firstItem] = context.get("value");
          const value = prop("collection").getNextValue(firstItem);
          if (value) context.set("value", [value]);
        },
        selectFirstItem({ context, prop }) {
          const value = prop("collection").firstValue;
          if (value) context.set("value", [value]);
        },
        selectLastItem({ context, prop }) {
          const value = prop("collection").lastValue;
          if (value) context.set("value", [value]);
        },
        selectMatchingItem({ context, prop, event, refs }) {
          const value = prop("collection").search(event.key, {
            state: refs.get("typeahead"),
            currentValue: context.get("value")[0]
          });
          if (value == null) return;
          context.set("value", [value]);
        },
        scrollContentToTop({ prop, scope }) {
          if (prop("scrollToIndexFn")) {
            const firstValue = prop("collection").firstValue;
            prop("scrollToIndexFn")?.({
              index: 0,
              immediate: true,
              getElement: () => getItemEl(scope, firstValue)
            });
          } else {
            getContentEl$1(scope)?.scrollTo(0, 0);
          }
        },
        invokeOnOpen({ prop, context }) {
          prop("onOpenChange")?.({ open: true, value: context.get("value") });
        },
        invokeOnClose({ prop, context }) {
          prop("onOpenChange")?.({ open: false, value: context.get("value") });
        },
        syncSelectElement({ context, prop, scope }) {
          const selectEl = getHiddenSelectEl(scope);
          if (!selectEl) return;
          if (context.get("value").length === 0 && !prop("multiple")) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = context.get("value").includes(option.value);
          }
        },
        syncCollection({ context, prop }) {
          const collection2 = prop("collection");
          const highlightedItem = collection2.find(context.get("highlightedValue"));
          if (highlightedItem) context.set("highlightedItem", highlightedItem);
          const selectedItems = collection2.findMany(context.get("value"));
          context.set("selectedItems", selectedItems);
        },
        syncSelectedItems({ context, prop }) {
          const collection2 = prop("collection");
          const prevSelectedItems = context.get("selectedItems");
          const value = context.get("value");
          const selectedItems = value.map((value2) => {
            const item = prevSelectedItems.find((item2) => collection2.getItemValue(item2) === value2);
            return item || collection2.find(value2);
          });
          context.set("selectedItems", selectedItems);
        },
        syncHighlightedItem({ context, prop }) {
          const collection2 = prop("collection");
          const highlightedValue = context.get("highlightedValue");
          const highlightedItem = highlightedValue ? collection2.find(highlightedValue) : null;
          context.set("highlightedItem", highlightedItem);
        },
        dispatchChangeEvent({ scope }) {
          queueMicrotask(() => {
            const node2 = getHiddenSelectEl(scope);
            if (!node2) return;
            const win = scope.getWin();
            const changeEvent = new win.Event("change", { bubbles: true, composed: true });
            node2.dispatchEvent(changeEvent);
          });
        }
      }
    }
  });
  function restoreFocusFn(event) {
    const v = event.restoreFocus ?? event.previousEvent?.restoreFocus;
    return v == null || !!v;
  }
  createProps$1()([
    "closeOnSelect",
    "collection",
    "composite",
    "defaultHighlightedValue",
    "defaultOpen",
    "defaultValue",
    "deselectable",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "required",
    "scrollToIndexFn",
    "value"
  ]);
  createProps$1()(["item", "persistFocus"]);
  createProps$1()(["id"]);
  createProps$1()(["htmlFor"]);
  var anatomy$4 = createAnatomy("slider").parts(
    "root",
    "label",
    "thumb",
    "valueText",
    "track",
    "range",
    "control",
    "markerGroup",
    "marker",
    "draggingIndicator"
  );
  anatomy$4.build();
  createProps$1()([
    "aria-label",
    "aria-labelledby",
    "dir",
    "disabled",
    "form",
    "getAriaValueText",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value",
    "defaultValue"
  ]);
  createProps$1()(["index", "name"]);
  createProps$1()(["value"]);
  var anatomy$3 = createAnatomy("switch").parts("root", "label", "control", "thumb");
  anatomy$3.build();
  createProps$1()([
    "checked",
    "defaultChecked",
    "dir",
    "disabled",
    "form",
    "getRootNode",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const [TabsProvider, useTabsContext] = createContext({
    name: "TabsContext",
    hookName: "useTabsContext",
    providerName: "<TabsProvider />"
  });
  const splitContentProps = createSplitProps();
  const TabContent = reactExports.forwardRef((props, ref) => {
    const [contentProps, localProps] = splitContentProps(props, ["value"]);
    const tabs = useTabsContext();
    const renderStrategyProps = useRenderStrategyPropsContext();
    const presence = usePresence$1({
      ...renderStrategyProps,
      present: tabs.value === props.value,
      immediate: true
    });
    const mergedProps = mergeProps(tabs.getContentProps(contentProps), presence.getPresenceProps(), localProps);
    return jsxRuntimeExports.jsx(PresenceProvider, { value: presence, children: presence.unmounted ? null : jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref: composeRefs$1(presence.ref, ref) }) });
  });
  TabContent.displayName = "TabContent";
  const TabIndicator = reactExports.forwardRef((props, ref) => {
    const tabs = useTabsContext();
    const mergedProps = mergeProps(tabs.getIndicatorProps(), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  TabIndicator.displayName = "TabIndicator";
  const TabList = reactExports.forwardRef((props, ref) => {
    const tabs = useTabsContext();
    const mergedProps = mergeProps(tabs.getListProps(), props);
    return jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref });
  });
  TabList.displayName = "TabList";
  const splitTriggerProps = createSplitProps();
  const TabTrigger = reactExports.forwardRef((props, ref) => {
    const [tabProps, localProps] = splitTriggerProps(props, ["disabled", "value"]);
    const tabs = useTabsContext();
    const mergedProps = mergeProps(tabs.getTriggerProps(tabProps), localProps);
    return jsxRuntimeExports.jsx(ark.button, { ...mergedProps, ref });
  });
  TabTrigger.displayName = "TabTrigger";
  var anatomy$2 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
  var parts = anatomy$2.build();
  var getRootId$1 = (ctx) => ctx.ids?.root ?? `tabs:${ctx.id}`;
  var getListId = (ctx) => ctx.ids?.list ?? `tabs:${ctx.id}:list`;
  var getContentId = (ctx, value) => ctx.ids?.content?.(value) ?? `tabs:${ctx.id}:content-${value}`;
  var getTriggerId$1 = (ctx, value) => ctx.ids?.trigger?.(value) ?? `tabs:${ctx.id}:trigger-${value}`;
  var getIndicatorId = (ctx) => ctx.ids?.indicator ?? `tabs:${ctx.id}:indicator`;
  var getListEl = (ctx) => ctx.getById(getListId(ctx));
  var getContentEl = (ctx, value) => ctx.getById(getContentId(ctx, value));
  var getTriggerEl$1 = (ctx, value) => value != null ? ctx.getById(getTriggerId$1(ctx, value)) : null;
  var getIndicatorEl = (ctx) => ctx.getById(getIndicatorId(ctx));
  var getElements = (ctx) => {
    const ownerId = CSS.escape(getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(getListEl(ctx), selector);
  };
  var getFirstTriggerEl = (ctx) => first(getElements(ctx));
  var getLastTriggerEl = (ctx) => last(getElements(ctx));
  var getNextTriggerEl = (ctx, opts) => nextById(getElements(ctx), getTriggerId$1(ctx, opts.value), opts.loopFocus);
  var getPrevTriggerEl = (ctx, opts) => prevById(getElements(ctx), getTriggerId$1(ctx, opts.value), opts.loopFocus);
  var getOffsetRect = (el) => ({
    x: el?.offsetLeft ?? 0,
    y: el?.offsetTop ?? 0,
    width: el?.offsetWidth ?? 0,
    height: el?.offsetHeight ?? 0
  });
  var getRectByValue = (ctx, value) => {
    const tab = itemById(getElements(ctx), getTriggerId$1(ctx, value));
    return getOffsetRect(tab);
  };
  function connect(service, normalize2) {
    const { state: state2, send, context, prop, scope } = service;
    const translations = prop("translations");
    const focused = state2.matches("focused");
    const isVertical = prop("orientation") === "vertical";
    const isHorizontal = prop("orientation") === "horizontal";
    const composite = prop("composite");
    function getTriggerState(props2) {
      return {
        selected: context.get("value") === props2.value,
        focused: context.get("focusedValue") === props2.value,
        disabled: !!props2.disabled
      };
    }
    return {
      value: context.get("value"),
      focusedValue: context.get("focusedValue"),
      setValue(value) {
        send({ type: "SET_VALUE", value });
      },
      clearValue() {
        send({ type: "CLEAR_VALUE" });
      },
      setIndicatorRect(value) {
        const id2 = getTriggerId$1(scope, value);
        send({ type: "SET_INDICATOR_RECT", id: id2 });
      },
      syncTabIndex() {
        send({ type: "SYNC_TAB_INDEX" });
      },
      selectNext(fromValue) {
        send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
        send({ type: "ARROW_NEXT", src: "selectNext" });
      },
      selectPrev(fromValue) {
        send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
        send({ type: "ARROW_PREV", src: "selectPrev" });
      },
      focus() {
        const value = context.get("value");
        if (!value) return;
        getTriggerEl$1(scope, value)?.focus();
      },
      getRootProps() {
        return normalize2.element({
          ...parts.root.attrs,
          id: getRootId$1(scope),
          "data-orientation": prop("orientation"),
          "data-focus": dataAttr$1(focused),
          dir: prop("dir")
        });
      },
      getListProps() {
        return normalize2.element({
          ...parts.list.attrs,
          id: getListId(scope),
          role: "tablist",
          dir: prop("dir"),
          "data-focus": dataAttr$1(focused),
          "aria-orientation": prop("orientation"),
          "data-orientation": prop("orientation"),
          "aria-label": translations?.listLabel,
          onKeyDown(event) {
            if (event.defaultPrevented) return;
            if (isComposingEvent(event)) return;
            if (!contains(event.currentTarget, getEventTarget(event))) return;
            const keyMap2 = {
              ArrowDown() {
                if (isHorizontal) return;
                send({ type: "ARROW_NEXT", key: "ArrowDown" });
              },
              ArrowUp() {
                if (isHorizontal) return;
                send({ type: "ARROW_PREV", key: "ArrowUp" });
              },
              ArrowLeft() {
                if (isVertical) return;
                send({ type: "ARROW_PREV", key: "ArrowLeft" });
              },
              ArrowRight() {
                if (isVertical) return;
                send({ type: "ARROW_NEXT", key: "ArrowRight" });
              },
              Home() {
                send({ type: "HOME" });
              },
              End() {
                send({ type: "END" });
              }
            };
            let key = getEventKey(event, {
              dir: prop("dir"),
              orientation: prop("orientation")
            });
            const exec = keyMap2[key];
            if (exec) {
              event.preventDefault();
              exec(event);
              return;
            }
          }
        });
      },
      getTriggerState,
      getTriggerProps(props2) {
        const { value, disabled } = props2;
        const triggerState = getTriggerState(props2);
        return normalize2.button({
          ...parts.trigger.attrs,
          role: "tab",
          type: "button",
          disabled,
          dir: prop("dir"),
          "data-orientation": prop("orientation"),
          "data-disabled": dataAttr$1(disabled),
          "aria-disabled": disabled,
          "data-value": value,
          "aria-selected": triggerState.selected,
          "data-selected": dataAttr$1(triggerState.selected),
          "data-focus": dataAttr$1(triggerState.focused),
          "aria-controls": triggerState.selected ? getContentId(scope, value) : void 0,
          "data-ownedby": getListId(scope),
          "data-ssr": dataAttr$1(context.get("ssr")),
          id: getTriggerId$1(scope, value),
          tabIndex: triggerState.selected && composite ? 0 : -1,
          onFocus() {
            send({ type: "TAB_FOCUS", value });
          },
          onBlur(event) {
            const target = event.relatedTarget;
            if (target?.getAttribute("role") !== "tab") {
              send({ type: "TAB_BLUR" });
            }
          },
          onClick(event) {
            if (event.defaultPrevented) return;
            if (isOpeningInNewTab(event)) return;
            if (disabled) return;
            if (isSafari()) {
              event.currentTarget.focus();
            }
            send({ type: "TAB_CLICK", value });
          }
        });
      },
      getContentProps(props2) {
        const { value } = props2;
        const selected = context.get("value") === value;
        return normalize2.element({
          ...parts.content.attrs,
          dir: prop("dir"),
          id: getContentId(scope, value),
          tabIndex: composite ? 0 : -1,
          "aria-labelledby": getTriggerId$1(scope, value),
          role: "tabpanel",
          "data-ownedby": getListId(scope),
          "data-selected": dataAttr$1(selected),
          "data-orientation": prop("orientation"),
          hidden: !selected
        });
      },
      getIndicatorProps() {
        const rect = context.get("indicatorRect");
        return normalize2.element({
          id: getIndicatorId(scope),
          ...parts.indicator.attrs,
          dir: prop("dir"),
          "data-orientation": prop("orientation"),
          hidden: rect == null,
          style: {
            "--transition-property": "left, right, top, bottom, width, height",
            "--left": toPx$1(rect?.x),
            "--top": toPx$1(rect?.y),
            "--width": toPx$1(rect?.width),
            "--height": toPx$1(rect?.height),
            position: "absolute",
            willChange: "var(--transition-property)",
            transitionProperty: "var(--transition-property)",
            transitionDuration: "var(--transition-duration, 150ms)",
            transitionTimingFunction: "var(--transition-timing-function)",
            [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
          }
        });
      }
    };
  }
  var { createMachine } = setup();
  var machine = createMachine({
    props({ props: props2 }) {
      return {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        loopFocus: true,
        composite: true,
        navigate(details) {
          clickIfLink(details.node);
        },
        defaultValue: null,
        ...props2
      };
    },
    initialState() {
      return "idle";
    },
    context({ prop, bindable }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          onChange(value) {
            prop("onValueChange")?.({ value });
          }
        })),
        focusedValue: bindable(() => ({
          defaultValue: prop("value") || prop("defaultValue"),
          sync: true,
          onChange(value) {
            prop("onFocusChange")?.({ focusedValue: value });
          }
        })),
        ssr: bindable(() => ({ defaultValue: true })),
        indicatorRect: bindable(() => ({
          defaultValue: null
        }))
      };
    },
    watch({ context, prop, track, action }) {
      track([() => context.get("value")], () => {
        action(["syncIndicatorRect", "syncTabIndex", "navigateIfNeeded"]);
      });
      track([() => prop("dir"), () => prop("orientation")], () => {
        action(["syncIndicatorRect"]);
      });
    },
    on: {
      SET_VALUE: {
        actions: ["setValue"]
      },
      CLEAR_VALUE: {
        actions: ["clearValue"]
      },
      SET_INDICATOR_RECT: {
        actions: ["setIndicatorRect"]
      },
      SYNC_TAB_INDEX: {
        actions: ["syncTabIndex"]
      }
    },
    entry: ["syncIndicatorRect", "syncTabIndex", "syncSsr"],
    exit: ["cleanupObserver"],
    states: {
      idle: {
        on: {
          TAB_FOCUS: {
            target: "focused",
            actions: ["setFocusedValue"]
          },
          TAB_CLICK: {
            target: "focused",
            actions: ["setFocusedValue", "setValue"]
          }
        }
      },
      focused: {
        on: {
          TAB_CLICK: {
            actions: ["setFocusedValue", "setValue"]
          },
          ARROW_PREV: [
            {
              guard: "selectOnFocus",
              actions: ["focusPrevTab", "selectFocusedTab"]
            },
            {
              actions: ["focusPrevTab"]
            }
          ],
          ARROW_NEXT: [
            {
              guard: "selectOnFocus",
              actions: ["focusNextTab", "selectFocusedTab"]
            },
            {
              actions: ["focusNextTab"]
            }
          ],
          HOME: [
            {
              guard: "selectOnFocus",
              actions: ["focusFirstTab", "selectFocusedTab"]
            },
            {
              actions: ["focusFirstTab"]
            }
          ],
          END: [
            {
              guard: "selectOnFocus",
              actions: ["focusLastTab", "selectFocusedTab"]
            },
            {
              actions: ["focusLastTab"]
            }
          ],
          TAB_FOCUS: {
            actions: ["setFocusedValue"]
          },
          TAB_BLUR: {
            target: "idle",
            actions: ["clearFocusedValue"]
          }
        }
      }
    },
    implementations: {
      guards: {
        selectOnFocus: ({ prop }) => prop("activationMode") === "automatic"
      },
      actions: {
        selectFocusedTab({ context, prop }) {
          raf(() => {
            const focusedValue = context.get("focusedValue");
            if (!focusedValue) return;
            const nullable = prop("deselectable") && context.get("value") === focusedValue;
            const value = nullable ? null : focusedValue;
            context.set("value", value);
          });
        },
        setFocusedValue({ context, event, flush: flush2 }) {
          if (event.value == null) return;
          flush2(() => {
            context.set("focusedValue", event.value);
          });
        },
        clearFocusedValue({ context }) {
          context.set("focusedValue", null);
        },
        setValue({ context, event, prop }) {
          const nullable = prop("deselectable") && context.get("value") === context.get("focusedValue");
          context.set("value", nullable ? null : event.value);
        },
        clearValue({ context }) {
          context.set("value", null);
        },
        focusFirstTab({ scope }) {
          raf(() => {
            getFirstTriggerEl(scope)?.focus();
          });
        },
        focusLastTab({ scope }) {
          raf(() => {
            getLastTriggerEl(scope)?.focus();
          });
        },
        focusNextTab({ context, prop, scope, event }) {
          const focusedValue = event.value ?? context.get("focusedValue");
          if (!focusedValue) return;
          const triggerEl = getNextTriggerEl(scope, {
            value: focusedValue,
            loopFocus: prop("loopFocus")
          });
          raf(() => {
            if (prop("composite")) {
              triggerEl?.focus();
            } else if (triggerEl?.dataset.value != null) {
              context.set("focusedValue", triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab({ context, prop, scope, event }) {
          const focusedValue = event.value ?? context.get("focusedValue");
          if (!focusedValue) return;
          const triggerEl = getPrevTriggerEl(scope, {
            value: focusedValue,
            loopFocus: prop("loopFocus")
          });
          raf(() => {
            if (prop("composite")) {
              triggerEl?.focus();
            } else if (triggerEl?.dataset.value != null) {
              context.set("focusedValue", triggerEl.dataset.value);
            }
          });
        },
        syncTabIndex({ context, scope }) {
          raf(() => {
            const value = context.get("value");
            if (!value) return;
            const contentEl = getContentEl(scope, value);
            if (!contentEl) return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver({ refs }) {
          const cleanup = refs.get("indicatorCleanup");
          if (cleanup) cleanup();
        },
        setIndicatorRect({ context, event, scope }) {
          const value = event.id ?? context.get("value");
          const indicatorEl = getIndicatorEl(scope);
          if (!indicatorEl) return;
          if (!value) return;
          const triggerEl = getTriggerEl$1(scope, value);
          if (!triggerEl) return;
          context.set("indicatorRect", getRectByValue(scope, value));
        },
        syncSsr({ context }) {
          context.set("ssr", false);
        },
        syncIndicatorRect({ context, refs, scope }) {
          const cleanup = refs.get("indicatorCleanup");
          if (cleanup) cleanup();
          const indicatorEl = getIndicatorEl(scope);
          if (!indicatorEl) return;
          const exec = () => {
            const triggerEl = getTriggerEl$1(scope, context.get("value"));
            if (!triggerEl) return;
            const rect = getOffsetRect(triggerEl);
            context.set("indicatorRect", (prev2) => isEqual(prev2, rect) ? prev2 : rect);
          };
          exec();
          const triggerEls = getElements(scope);
          const indicatorCleanup = callAll(...triggerEls.map((el) => resizeObserverBorderBox.observe(el, exec)));
          refs.set("indicatorCleanup", indicatorCleanup);
        },
        navigateIfNeeded({ context, prop, scope }) {
          const value = context.get("value");
          if (!value) return;
          const triggerEl = getTriggerEl$1(scope, value);
          if (isAnchorElement(triggerEl)) {
            prop("navigate")?.({ value, node: triggerEl, href: triggerEl.href });
          }
        }
      }
    }
  });
  createProps$1()([
    "activationMode",
    "composite",
    "deselectable",
    "dir",
    "getRootNode",
    "id",
    "ids",
    "loopFocus",
    "navigate",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value",
    "defaultValue"
  ]);
  createProps$1()(["disabled", "value"]);
  createProps$1()(["value"]);
  const useTabs = (props) => {
    const id2 = reactExports.useId();
    const { getRootNode: getRootNode2 } = useEnvironmentContext();
    const { dir } = useLocaleContext();
    const machineProps = {
      id: id2,
      dir,
      getRootNode: getRootNode2,
      ...props
    };
    const service = useMachine(machine, machineProps);
    return connect(service, normalizeProps);
  };
  const splitRootProps = createSplitProps();
  const TabsRoot$1 = reactExports.forwardRef((props, ref) => {
    const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
    const [useTabsProps, localProps] = splitRootProps(tabsProps, [
      "activationMode",
      "composite",
      "defaultValue",
      "deselectable",
      "id",
      "ids",
      "loopFocus",
      "navigate",
      "onFocusChange",
      "onValueChange",
      "orientation",
      "translations",
      "value"
    ]);
    const tabs = useTabs(useTabsProps);
    const mergedProps = mergeProps(tabs.getRootProps(), localProps);
    return jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
  });
  TabsRoot$1.displayName = "TabsRoot";
  const splitRootProviderProps = createSplitProps();
  const TabsRootProvider = reactExports.forwardRef((props, ref) => {
    const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props);
    const [{ value: tabs }, localProps] = splitRootProviderProps(tabsProps, ["value"]);
    const mergedProps = mergeProps(tabs.getRootProps(), localProps);
    return jsxRuntimeExports.jsx(TabsProvider, { value: tabs, children: jsxRuntimeExports.jsx(RenderStrategyPropsProvider, { value: renderStrategyProps, children: jsxRuntimeExports.jsx(ark.div, { ...mergedProps, ref }) }) });
  });
  TabsRootProvider.displayName = "TabsRootProvider";
  var anatomy$1 = createAnatomy("tagsInput").parts(
    "root",
    "label",
    "control",
    "input",
    "clearTrigger",
    "item",
    "itemPreview",
    "itemInput",
    "itemText",
    "itemDeleteTrigger"
  );
  anatomy$1.build();
  var getRootId = (ctx) => ctx.ids?.root ?? `tags-input:${ctx.id}`;
  var getInputId = (ctx) => ctx.ids?.input ?? `tags-input:${ctx.id}:input`;
  var getHiddenInputId = (ctx) => ctx.ids?.hiddenInput ?? `tags-input:${ctx.id}:hidden-input`;
  var getItemId = (ctx, opt) => ctx.ids?.item?.(opt) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
  var getItemInputId = (ctx, opt) => ctx.ids?.itemInput?.(opt) ?? `${getItemId(ctx, opt)}:input`;
  var getEditInputId = (id2) => `${id2}:input`;
  var getEditInputEl = (ctx, id2) => ctx.getById(getEditInputId(id2));
  var getItemEls = (ctx) => queryAll(getRootEl(ctx), `[data-part=item]`);
  var getTagInputEl = (ctx, opt) => ctx.getById(getItemInputId(ctx, opt));
  var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
  var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
  var getHiddenInputEl = (ctx) => ctx.getById(getHiddenInputId(ctx));
  var getTagElements = (ctx) => queryAll(getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`);
  var getFirstEl = (ctx) => getTagElements(ctx)[0];
  var getLastEl = (ctx) => getTagElements(ctx)[getTagElements(ctx).length - 1];
  var getPrevEl = (ctx, id2) => prevById(getTagElements(ctx), id2, false);
  var getNextEl = (ctx, id2) => nextById(getTagElements(ctx), id2, false);
  var getTagElAtIndex = (ctx, index) => getTagElements(ctx)[index];
  var getIndexOfId = (ctx, id2) => indexOfId(getTagElements(ctx), id2);
  var dispatchInputEvent = (ctx, value) => {
    const inputEl = getHiddenInputEl(ctx);
    if (!inputEl) return;
    dispatchInputValueEvent(inputEl, { value });
  };
  var { and: and$1, not: not$1, or } = createGuards();
  createMachine$4({
    props({ props: props2 }) {
      return {
        dir: "ltr",
        addOnPaste: false,
        editable: true,
        validate: () => true,
        delimiter: ",",
        defaultValue: [],
        defaultInputValue: "",
        max: Infinity,
        ...props2,
        translations: {
          clearTriggerLabel: "Clear all tags",
          deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
          tagAdded: (value) => `Added tag ${value}`,
          tagsPasted: (values) => `Pasted ${values.length} tags`,
          tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
          tagUpdated: (value) => `Tag update to ${value}`,
          tagDeleted: (value) => `Tag ${value} deleted`,
          tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
          ...props2.translations
        }
      };
    },
    initialState({ prop }) {
      return prop("autoFocus") ? "focused:input" : "idle";
    },
    refs() {
      return {
        liveRegion: null,
        log: { current: null, prev: null }
      };
    },
    context({ bindable, prop }) {
      return {
        value: bindable(() => ({
          defaultValue: prop("defaultValue"),
          value: prop("value"),
          isEqual,
          hash(value) {
            return value.join(", ");
          },
          onChange(value) {
            prop("onValueChange")?.({ value });
          }
        })),
        inputValue: bindable(() => ({
          sync: true,
          defaultValue: prop("defaultInputValue"),
          value: prop("inputValue"),
          onChange(value) {
            prop("onInputValueChange")?.({ inputValue: value });
          }
        })),
        fieldsetDisabled: bindable(() => ({ defaultValue: false })),
        editedTagValue: bindable(() => ({ defaultValue: "" })),
        editedTagId: bindable(() => ({ defaultValue: null })),
        editedTagIndex: bindable(() => ({
          defaultValue: null,
          sync: true
        })),
        highlightedTagId: bindable(() => ({
          defaultValue: null,
          sync: true,
          onChange(value) {
            prop("onHighlightChange")?.({ highlightedValue: value });
          }
        }))
      };
    },
    computed: {
      count: ({ context }) => context.get("value").length,
      valueAsString: ({ context }) => context.hash("value"),
      trimmedInputValue: ({ context }) => context.get("inputValue").trim(),
      isDisabled: ({ prop }) => !!prop("disabled"),
      isInteractive: ({ prop }) => !(prop("readOnly") || !!prop("disabled")),
      isAtMax: ({ context, prop }) => context.get("value").length === prop("max"),
      isOverflowing: ({ context, prop }) => context.get("value").length > prop("max")
    },
    watch({ track, context, action, computed, refs }) {
      track([() => context.get("editedTagValue")], () => {
        action(["syncEditedTagInputValue"]);
      });
      track([() => context.get("inputValue")], () => {
        action(["syncInputValue"]);
      });
      track([() => context.get("highlightedTagId")], () => {
        action(["logHighlightedTag"]);
      });
      track([() => computed("isOverflowing")], () => {
        action(["invokeOnInvalid"]);
      });
      track([() => JSON.stringify(refs.get("log"))], () => {
        action(["announceLog"]);
      });
    },
    effects: ["trackLiveRegion", "trackFormControlState"],
    exit: ["clearLog"],
    on: {
      DOUBLE_CLICK_TAG: {
guard: "isTagEditable",
        target: "editing:tag",
        actions: ["setEditedId"]
      },
      POINTER_DOWN_TAG: {
target: "navigating:tag",
        actions: ["highlightTag", "focusInput"]
      },
      CLICK_DELETE_TAG: {
        target: "focused:input",
        actions: ["deleteTag"]
      },
      SET_INPUT_VALUE: {
        actions: ["setInputValue"]
      },
      SET_VALUE: {
        actions: ["setValue"]
      },
      CLEAR_TAG: {
        actions: ["deleteTag"]
      },
      SET_VALUE_AT_INDEX: {
        actions: ["setValueAtIndex"]
      },
      CLEAR_VALUE: {
        actions: ["clearTags", "clearInputValue", "focusInput"]
      },
      ADD_TAG: {
        actions: ["addTag"]
      },
      INSERT_TAG: {
guard: and$1(or(not$1("isAtMax"), "allowOverflow"), not$1("isInputValueEmpty")),
        actions: ["addTag", "clearInputValue"]
      },
      EXTERNAL_BLUR: [
        { guard: "addOnBlur", actions: ["raiseInsertTagEvent"] },
        { guard: "clearOnBlur", actions: ["clearInputValue"] }
      ]
    },
    states: {
      idle: {
        on: {
          FOCUS: {
            target: "focused:input"
          },
          POINTER_DOWN: {
            guard: not$1("hasHighlightedTag"),
            target: "focused:input"
          }
        }
      },
      "focused:input": {
        tags: ["focused"],
        entry: ["focusInput", "clearHighlightedId"],
        effects: ["trackInteractOutside"],
        on: {
          TYPE: {
            actions: ["setInputValue"]
          },
          BLUR: [
            {
              guard: "addOnBlur",
              target: "idle",
              actions: ["raiseInsertTagEvent"]
            },
            {
              guard: "clearOnBlur",
              target: "idle",
              actions: ["clearInputValue"]
            },
            { target: "idle" }
          ],
          ENTER: {
            actions: ["raiseInsertTagEvent"]
          },
          DELIMITER_KEY: {
            actions: ["raiseInsertTagEvent"]
          },
          ARROW_LEFT: {
            guard: and$1("hasTags", "isCaretAtStart"),
            target: "navigating:tag",
            actions: ["highlightLastTag"]
          },
          BACKSPACE: {
            target: "navigating:tag",
            guard: and$1("hasTags", "isCaretAtStart"),
            actions: ["highlightLastTag"]
          },
          DELETE: {
            guard: "hasHighlightedTag",
            actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
          },
          PASTE: [
            {
              guard: "addOnPaste",
              actions: ["setInputValue", "addTagFromPaste"]
            },
            {
              actions: ["setInputValue"]
            }
          ]
        }
      },
      "navigating:tag": {
        tags: ["focused"],
        effects: ["trackInteractOutside"],
        on: {
          ARROW_RIGHT: [
            {
              guard: and$1("hasTags", "isCaretAtStart", not$1("isLastTagHighlighted")),
              actions: ["highlightNextTag"]
            },
            { target: "focused:input" }
          ],
          ARROW_LEFT: [
            {
              guard: not$1("isCaretAtStart"),
              target: "focused:input"
            },
            {
              actions: ["highlightPrevTag"]
            }
          ],
          BLUR: {
            target: "idle",
            actions: ["clearHighlightedId"]
          },
          ENTER: {
            guard: and$1("isTagEditable", "hasHighlightedTag"),
            target: "editing:tag",
            actions: ["setEditedId", "focusEditedTagInput"]
          },
          ARROW_DOWN: {
            target: "focused:input"
          },
          ESCAPE: {
            target: "focused:input"
          },
          TYPE: {
            target: "focused:input",
            actions: ["setInputValue"]
          },
          BACKSPACE: [
            {
              guard: not$1("isCaretAtStart"),
              target: "focused:input"
            },
            {
              guard: "isFirstTagHighlighted",
              actions: ["deleteHighlightedTag", "highlightFirstTag"]
            },
            {
              guard: "hasHighlightedTag",
              actions: ["deleteHighlightedTag", "highlightPrevTag"]
            },
            {
              actions: ["highlightLastTag"]
            }
          ],
          DELETE: [
            {
              guard: not$1("isCaretAtStart"),
              target: "focused:input"
            },
            {
              target: "focused:input",
              actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
            }
          ],
          PASTE: [
            {
              guard: "addOnPaste",
              target: "focused:input",
              actions: ["setInputValue", "addTagFromPaste"]
            },
            {
              target: "focused:input",
              actions: ["setInputValue"]
            }
          ]
        }
      },
      "editing:tag": {
        tags: ["editing", "focused"],
        entry: ["focusEditedTagInput"],
        effects: ["autoResize"],
        on: {
          TAG_INPUT_TYPE: {
            actions: ["setEditedTagValue"]
          },
          TAG_INPUT_ESCAPE: {
            target: "navigating:tag",
            actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
          },
          TAG_INPUT_BLUR: [
            {
              guard: "isInputRelatedTarget",
              target: "navigating:tag",
              actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId"]
            },
            {
              target: "idle",
              actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId", "raiseExternalBlurEvent"]
            }
          ],
          TAG_INPUT_ENTER: [
            {
              guard: "isEditedTagEmpty",
              target: "navigating:tag",
              actions: ["deleteHighlightedTag", "focusInput", "clearEditedId", "highlightTagAtIndex"]
            },
            {
              target: "navigating:tag",
              actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
            }
          ]
        }
      }
    },
    implementations: {
      guards: {
        isInputRelatedTarget: ({ scope, event }) => event.relatedTarget === getInputEl(scope),
        isAtMax: ({ computed }) => computed("isAtMax"),
        hasHighlightedTag: ({ context }) => context.get("highlightedTagId") != null,
        isFirstTagHighlighted: ({ context, scope }) => {
          const value = context.get("value");
          const firstItemId = getItemId(scope, { value: value[0], index: 0 });
          return firstItemId === context.get("highlightedTagId");
        },
        isEditedTagEmpty: ({ context }) => context.get("editedTagValue").trim() === "",
        isLastTagHighlighted: ({ context, scope }) => {
          const value = context.get("value");
          const lastIndex = value.length - 1;
          const lastItemId = getItemId(scope, { value: value[lastIndex], index: lastIndex });
          return lastItemId === context.get("highlightedTagId");
        },
        isInputValueEmpty: ({ context }) => context.get("inputValue").trim().length === 0,
        hasTags: ({ context }) => context.get("value").length > 0,
        allowOverflow: ({ prop }) => !!prop("allowOverflow"),
        autoFocus: ({ prop }) => !!prop("autoFocus"),
        addOnBlur: ({ prop }) => prop("blurBehavior") === "add",
        clearOnBlur: ({ prop }) => prop("blurBehavior") === "clear",
        addOnPaste: ({ prop }) => !!prop("addOnPaste"),
        isTagEditable: ({ prop }) => !!prop("editable"),
        isCaretAtStart: ({ scope }) => isCaretAtStart(getInputEl(scope))
      },
      effects: {
        trackInteractOutside({ scope, prop, send }) {
          return trackInteractOutside(getInputEl(scope), {
            exclude(target) {
              const itemEls = getItemEls(scope);
              return itemEls.some((el) => contains(el, target));
            },
            onFocusOutside: prop("onFocusOutside"),
            onPointerDownOutside: prop("onPointerDownOutside"),
            onInteractOutside(event) {
              prop("onInteractOutside")?.(event);
              if (event.defaultPrevented) return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        trackFormControlState({ context, send, scope }) {
          return trackFormControl(getHiddenInputEl(scope), {
            onFieldsetDisabledChange(disabled) {
              context.set("fieldsetDisabled", disabled);
            },
            onFormReset() {
              const value = context.initial("value");
              send({ type: "SET_VALUE", value, src: "form-reset" });
            }
          });
        },
        autoResize({ context, prop, scope }) {
          let fn_cleanup;
          queueMicrotask(() => {
            const editedTagValue = context.get("editedTagValue");
            const editedTagIndex = context.get("editedTagIndex");
            if (!editedTagValue || editedTagIndex == null || !prop("editable")) return;
            const inputEl = getTagInputEl(scope, {
              value: editedTagValue,
              index: editedTagIndex
            });
            fn_cleanup = autoResizeInput(inputEl);
          });
          return () => {
            fn_cleanup?.();
          };
        },
        trackLiveRegion({ scope, refs }) {
          const liveRegion = createLiveRegion({
            level: "assertive",
            document: scope.getDoc()
          });
          refs.set("liveRegion", liveRegion);
          return () => liveRegion.destroy();
        }
      },
      actions: {
        raiseInsertTagEvent({ send }) {
          send({ type: "INSERT_TAG" });
        },
        raiseExternalBlurEvent({ send, event }) {
          send({ type: "EXTERNAL_BLUR", id: event.id });
        },
        dispatchChangeEvent({ scope, computed }) {
          dispatchInputEvent(scope, computed("valueAsString"));
        },
        highlightNextTag({ context, scope }) {
          const highlightedTagId = context.get("highlightedTagId");
          if (highlightedTagId == null) return;
          const next2 = getNextEl(scope, highlightedTagId);
          context.set("highlightedTagId", next2?.id ?? null);
        },
        highlightFirstTag({ context, scope }) {
          raf(() => {
            const first2 = getFirstEl(scope);
            context.set("highlightedTagId", first2?.id ?? null);
          });
        },
        highlightLastTag({ context, scope }) {
          const last2 = getLastEl(scope);
          context.set("highlightedTagId", last2?.id ?? null);
        },
        highlightPrevTag({ context, scope }) {
          const highlightedTagId = context.get("highlightedTagId");
          if (highlightedTagId == null) return;
          const prev2 = getPrevEl(scope, highlightedTagId);
          context.set("highlightedTagId", prev2?.id ?? null);
        },
        highlightTag({ context, event }) {
          context.set("highlightedTagId", event.id);
        },
        highlightTagAtIndex({ context, scope }) {
          raf(() => {
            const idx = context.get("editedTagIndex");
            if (idx == null) return;
            const tagEl = getTagElAtIndex(scope, idx);
            if (tagEl == null) return;
            context.set("highlightedTagId", tagEl.id);
            context.set("editedTagIndex", null);
          });
        },
        deleteTag({ context, scope, event, refs }) {
          const index = getIndexOfId(scope, event.id);
          const value = context.get("value")[index];
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "delete", value }
          });
          context.set("value", (prev2) => removeAt(prev2, index));
        },
        deleteHighlightedTag({ context, scope, refs }) {
          const highlightedTagId = context.get("highlightedTagId");
          if (highlightedTagId == null) return;
          const index = getIndexOfId(scope, highlightedTagId);
          context.set("editedTagIndex", index);
          const value = context.get("value");
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "delete", value: value[index] }
          });
          context.set("value", (prev2) => removeAt(prev2, index));
        },
        setEditedId({ context, event, scope }) {
          const highlightedTagId = context.get("highlightedTagId");
          const editedTagId = event.id ?? highlightedTagId;
          context.set("editedTagId", editedTagId);
          const index = getIndexOfId(scope, editedTagId);
          const valueAtIndex = context.get("value")[index];
          context.set("editedTagIndex", index);
          context.set("editedTagValue", valueAtIndex);
        },
        clearEditedId({ context }) {
          context.set("editedTagId", null);
        },
        clearEditedTagValue({ context }) {
          context.set("editedTagValue", "");
        },
        setEditedTagValue({ context, event }) {
          context.set("editedTagValue", event.value);
        },
        submitEditedTagValue({ context, scope, refs }) {
          const editedTagId = context.get("editedTagId");
          if (!editedTagId) return;
          const index = getIndexOfId(scope, editedTagId);
          context.set("value", (prev2) => {
            const value = prev2.slice();
            value[index] = context.get("editedTagValue");
            return value;
          });
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "update", value: context.get("editedTagValue") }
          });
        },
        setValueAtIndex({ context, event, refs }) {
          if (event.value) {
            context.set("value", (prev2) => {
              const value = prev2.slice();
              value[event.index] = event.value;
              return value;
            });
            const prevLog = refs.get("log");
            refs.set("log", {
              prev: prevLog.current,
              current: { type: "update", value: event.value }
            });
          } else {
            warn("You need to provide a value for the tag");
          }
        },
        focusEditedTagInput({ context, scope }) {
          raf(() => {
            const editedTagId = context.get("editedTagId");
            if (!editedTagId) return;
            const editTagInputEl = getEditInputEl(scope, editedTagId);
            editTagInputEl?.select();
          });
        },
        setInputValue({ context, event }) {
          context.set("inputValue", event.value);
        },
        clearHighlightedId({ context }) {
          context.set("highlightedTagId", null);
        },
        focusInput({ scope }) {
          raf(() => {
            getInputEl(scope)?.focus();
          });
        },
        clearInputValue({ context }) {
          raf(() => {
            context.set("inputValue", "");
          });
        },
        syncInputValue({ context, scope }) {
          const inputEl = getInputEl(scope);
          if (!inputEl) return;
          setElementValue(inputEl, context.get("inputValue"));
        },
        syncEditedTagInputValue({ context, event, scope }) {
          const id2 = context.get("editedTagId") || context.get("highlightedTagId") || event.id;
          if (id2 == null) return;
          const editTagInputEl = getEditInputEl(scope, id2);
          if (!editTagInputEl) return;
          setElementValue(editTagInputEl, context.get("editedTagValue"));
        },
        addTag({ context, event, computed, prop, refs }) {
          const inputValue = event.value ?? computed("trimmedInputValue");
          const value = context.get("value");
          const guard = prop("validate")?.({ inputValue, value: Array.from(value) });
          if (guard) {
            const nextValue = uniq(value.concat(inputValue));
            context.set("value", nextValue);
            const prevLog = refs.get("log");
            refs.set("log", {
              prev: prevLog.current,
              current: { type: "add", value: inputValue }
            });
          } else {
            prop("onValueInvalid")?.({ reason: "invalidTag" });
          }
        },
        addTagFromPaste({ context, computed, prop, refs }) {
          raf(() => {
            const inputValue = computed("trimmedInputValue");
            const value = context.get("value");
            const guard = prop("validate")?.({
              inputValue,
              value: Array.from(value)
            });
            if (guard) {
              const delimiter2 = prop("delimiter");
              const trimmedValue = delimiter2 ? inputValue.split(delimiter2).map((v) => v.trim()) : [inputValue];
              const nextValue = uniq(value.concat(...trimmedValue));
              context.set("value", nextValue);
              const prevLog = refs.get("log");
              refs.set("log", {
                prev: prevLog.current,
                current: { type: "paste", values: trimmedValue }
              });
            } else {
              prop("onValueInvalid")?.({ reason: "invalidTag" });
            }
            context.set("inputValue", "");
          });
        },
        clearTags({ context, refs }) {
          context.set("value", []);
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "clear" }
          });
        },
        setValue({ context, event }) {
          context.set("value", event.value);
        },
        invokeOnInvalid({ prop, computed }) {
          if (computed("isOverflowing")) {
            prop("onValueInvalid")?.({ reason: "rangeOverflow" });
          }
        },
        clearLog({ refs }) {
          const log = refs.get("log");
          log.prev = log.current = null;
        },
        logHighlightedTag({ refs, context, scope }) {
          const highlightedTagId = context.get("highlightedTagId");
          const log = refs.get("log");
          if (highlightedTagId == null || !log.current) return;
          const index = getIndexOfId(scope, highlightedTagId);
          const value = context.get("value")[index];
          const prevLog = refs.get("log");
          refs.set("log", {
            prev: prevLog.current,
            current: { type: "select", value }
          });
        },
announceLog({ refs, prop }) {
          const liveRegion = refs.get("liveRegion");
          const translations = prop("translations");
          const log = refs.get("log");
          if (!log.current || liveRegion == null) return;
          const region = liveRegion;
          const { current, prev: prev2 } = log;
          let msg;
          switch (current.type) {
            case "add":
              msg = translations.tagAdded(current.value);
              break;
            case "delete":
              msg = translations.tagDeleted(current.value);
              break;
            case "update":
              msg = translations.tagUpdated(current.value);
              break;
            case "paste":
              msg = translations.tagsPasted(current.values);
              break;
            case "select":
              msg = translations.tagSelected(current.value);
              if (prev2?.type === "delete") {
                msg = `${translations.tagDeleted(prev2.value)}. ${msg}`;
              } else if (prev2?.type === "update") {
                msg = `${translations.tagUpdated(prev2.value)}. ${msg}`;
              }
              break;
          }
          if (msg) region.announce(msg);
        }
      }
    }
  });
  createProps$1()([
    "addOnPaste",
    "allowOverflow",
    "autoFocus",
    "blurBehavior",
    "delimiter",
    "dir",
    "disabled",
    "editable",
    "form",
    "getRootNode",
    "id",
    "ids",
    "inputValue",
    "invalid",
    "max",
    "maxLength",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueInvalid",
    "required",
    "readOnly",
    "translations",
    "validate",
    "value",
    "defaultValue",
    "defaultInputValue"
  ]);
  createProps$1()(["index", "disabled", "value"]);
  var anatomy = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
  anatomy.build();
  var getTriggerId = (scope) => scope.ids?.trigger ?? `tooltip:${scope.id}:trigger`;
  var getPositionerId = (scope) => scope.ids?.positioner ?? `tooltip:${scope.id}:popper`;
  var getTriggerEl = (scope) => scope.getById(getTriggerId(scope));
  var getPositionerEl = (scope) => scope.getById(getPositionerId(scope));
  var store = createStore({ id: null });
  var { and, not } = createGuards();
  createMachine$4({
    initialState: ({ prop }) => {
      const open = prop("open") || prop("defaultOpen");
      return open ? "open" : "closed";
    },
    props({ props: props2 }) {
      const closeOnClick = props2.closeOnClick ?? true;
      const closeOnPointerDown = props2.closeOnPointerDown ?? closeOnClick;
      return {
        id: "x",
        openDelay: 400,
        closeDelay: 150,
        closeOnEscape: true,
        interactive: false,
        closeOnScroll: true,
        disabled: false,
        ...props2,
        closeOnPointerDown,
        closeOnClick,
        positioning: {
          placement: "bottom",
          ...props2.positioning
        }
      };
    },
    effects: ["trackFocusVisible", "trackStore"],
    context: ({ bindable }) => ({
      currentPlacement: bindable(() => ({ defaultValue: void 0 })),
      hasPointerMoveOpened: bindable(() => ({ defaultValue: false }))
    }),
    watch({ track, action, prop }) {
      track([() => prop("disabled")], () => {
        action(["closeIfDisabled"]);
      });
      track([() => prop("open")], () => {
        action(["toggleVisibility"]);
      });
    },
    states: {
      closed: {
        entry: ["clearGlobalId"],
        on: {
          "controlled.open": {
            target: "open"
          },
          open: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ],
          "pointer.leave": {
            actions: ["clearPointerMoveOpened"]
          },
          "pointer.move": [
            {
              guard: and("noVisibleTooltip", not("hasPointerMoveOpened")),
              target: "opening"
            },
            {
              guard: not("hasPointerMoveOpened"),
              target: "open",
              actions: ["setPointerMoveOpened", "invokeOnOpen"]
            }
          ]
        }
      },
      opening: {
        effects: ["trackScroll", "trackPointerlockChange", "waitForOpenDelay"],
        on: {
          "after.openDelay": [
            {
              guard: "isOpenControlled",
              actions: ["setPointerMoveOpened", "invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["setPointerMoveOpened", "invokeOnOpen"]
            }
          ],
          "controlled.open": {
            target: "open"
          },
          "controlled.close": {
            target: "closed"
          },
          open: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnOpen"]
            },
            {
              target: "open",
              actions: ["invokeOnOpen"]
            }
          ],
          "pointer.leave": [
            {
              guard: "isOpenControlled",
actions: ["clearPointerMoveOpened", "invokeOnClose", "toggleVisibility"]
            },
            {
              target: "closed",
              actions: ["clearPointerMoveOpened", "invokeOnClose"]
            }
          ],
          close: [
            {
              guard: "isOpenControlled",
actions: ["invokeOnClose", "toggleVisibility"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ]
        }
      },
      open: {
        effects: ["trackEscapeKey", "trackScroll", "trackPointerlockChange", "trackPositioning"],
        entry: ["setGlobalId"],
        on: {
          "controlled.close": {
            target: "closed"
          },
          close: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "pointer.leave": [
            {
              guard: "isVisible",
              target: "closing",
              actions: ["clearPointerMoveOpened"]
            },
{
              guard: "isOpenControlled",
              actions: ["clearPointerMoveOpened", "invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["clearPointerMoveOpened", "invokeOnClose"]
            }
          ],
          "content.pointer.leave": {
            guard: "isInteractive",
            target: "closing"
          },
          "positioning.set": {
            actions: ["reposition"]
          }
        }
      },
      closing: {
        effects: ["trackPositioning", "waitForCloseDelay"],
        on: {
          "after.closeDelay": [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "controlled.close": {
            target: "closed"
          },
          "controlled.open": {
            target: "open"
          },
          close: [
            {
              guard: "isOpenControlled",
              actions: ["invokeOnClose"]
            },
            {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          ],
          "pointer.move": [
            {
              guard: "isOpenControlled",
actions: ["setPointerMoveOpened", "invokeOnOpen", "toggleVisibility"]
            },
            {
              target: "open",
              actions: ["setPointerMoveOpened", "invokeOnOpen"]
            }
          ],
          "content.pointer.move": {
            guard: "isInteractive",
            target: "open"
          },
          "positioning.set": {
            actions: ["reposition"]
          }
        }
      }
    },
    implementations: {
      guards: {
        noVisibleTooltip: () => store.get("id") === null,
        isVisible: ({ prop }) => prop("id") === store.get("id"),
        isInteractive: ({ prop }) => !!prop("interactive"),
        hasPointerMoveOpened: ({ context }) => context.get("hasPointerMoveOpened"),
        isOpenControlled: ({ prop }) => prop("open") !== void 0
      },
      actions: {
        setGlobalId: ({ prop }) => {
          store.set("id", prop("id"));
        },
        clearGlobalId: ({ prop }) => {
          if (prop("id") === store.get("id")) {
            store.set("id", null);
          }
        },
        invokeOnOpen: ({ prop }) => {
          prop("onOpenChange")?.({ open: true });
        },
        invokeOnClose: ({ prop }) => {
          prop("onOpenChange")?.({ open: false });
        },
        closeIfDisabled: ({ prop, send }) => {
          if (!prop("disabled")) return;
          send({ type: "close", src: "disabled.change" });
        },
        reposition: ({ context, event, prop, scope }) => {
          if (event.type !== "positioning.set") return;
          const getPositionerEl2 = () => getPositionerEl(scope);
          return getPlacement(getTriggerEl(scope), getPositionerEl2, {
            ...prop("positioning"),
            ...event.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        toggleVisibility: ({ prop, event, send }) => {
          queueMicrotask(() => {
            send({
              type: prop("open") ? "controlled.open" : "controlled.close",
              previousEvent: event
            });
          });
        },
        setPointerMoveOpened: ({ context }) => {
          context.set("hasPointerMoveOpened", true);
        },
        clearPointerMoveOpened: ({ context }) => {
          context.set("hasPointerMoveOpened", false);
        }
      },
      effects: {
        trackFocusVisible: ({ scope }) => {
          return trackFocusVisible({ root: scope.getRootNode?.() });
        },
        trackPositioning: ({ context, prop, scope }) => {
          if (!context.get("currentPlacement")) {
            context.set("currentPlacement", prop("positioning").placement);
          }
          const getPositionerEl2 = () => getPositionerEl(scope);
          return getPlacement(getTriggerEl(scope), getPositionerEl2, {
            ...prop("positioning"),
            defer: true,
            onComplete(data) {
              context.set("currentPlacement", data.placement);
            }
          });
        },
        trackPointerlockChange: ({ send, scope }) => {
          const doc = scope.getDoc();
          const onChange = () => send({ type: "close", src: "pointerlock:change" });
          return addDomEvent$1(doc, "pointerlockchange", onChange, false);
        },
        trackScroll: ({ send, prop, scope }) => {
          if (!prop("closeOnScroll")) return;
          const triggerEl = getTriggerEl(scope);
          if (!triggerEl) return;
          const overflowParents = getOverflowAncestors$1(triggerEl);
          const cleanups = overflowParents.map((overflowParent) => {
            const onScroll = () => {
              send({ type: "close", src: "scroll" });
            };
            return addDomEvent$1(overflowParent, "scroll", onScroll, {
              passive: true,
              capture: true
            });
          });
          return () => {
            cleanups.forEach((fn) => fn?.());
          };
        },
        trackStore: ({ prop, send }) => {
          let cleanup;
          queueMicrotask(() => {
            cleanup = store.subscribe(() => {
              if (store.get("id") !== prop("id")) {
                send({ type: "close", src: "id.change" });
              }
            });
          });
          return () => cleanup?.();
        },
        trackEscapeKey: ({ send, prop }) => {
          if (!prop("closeOnEscape")) return;
          const onKeyDown = (event) => {
            if (isComposingEvent(event)) return;
            if (event.key !== "Escape") return;
            event.stopPropagation();
            send({ type: "close", src: "keydown.escape" });
          };
          return addDomEvent$1(document, "keydown", onKeyDown, true);
        },
        waitForOpenDelay: ({ send, prop }) => {
          const id2 = setTimeout(() => {
            send({ type: "after.openDelay" });
          }, prop("openDelay"));
          return () => clearTimeout(id2);
        },
        waitForCloseDelay: ({ send, prop }) => {
          const id2 = setTimeout(() => {
            send({ type: "after.closeDelay" });
          }, prop("closeDelay"));
          return () => clearTimeout(id2);
        }
      }
    }
  });
  createProps$1()([
    "aria-label",
    "closeDelay",
    "closeOnEscape",
    "closeOnPointerDown",
    "closeOnScroll",
    "closeOnClick",
    "dir",
    "disabled",
    "getRootNode",
    "id",
    "ids",
    "interactive",
    "onOpenChange",
    "defaultOpen",
    "open",
    "openDelay",
    "positioning"
  ]);
  function omit(object, keysToOmit = []) {
    const clone2 = Object.assign({}, object);
    for (const key of keysToOmit) {
      if (key in clone2) {
        delete clone2[key];
      }
    }
    return clone2;
  }
  const colorMix = (value, token2) => {
    if (!value || typeof value !== "string") {
      return { invalid: true, value };
    }
    const [rawColor, rawOpacity] = value.split("/");
    if (!rawColor || !rawOpacity || rawColor === "currentBg") {
      return { invalid: true, value: rawColor };
    }
    const colorToken = token2(`colors.${rawColor}`);
    const opacityToken = token2.raw(`opacity.${rawOpacity}`)?.value;
    if (!opacityToken && isNaN(Number(rawOpacity))) {
      return { invalid: true, value: rawColor };
    }
    const percent2 = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
    const color2 = colorToken ?? rawColor;
    return {
      invalid: false,
      color: color2,
      value: `color-mix(in srgb, ${color2} ${percent2}, transparent)`
    };
  };
  const createColorMixTransform = (prop) => (value, args) => {
    const mix2 = args.utils.colorMix(value);
    if (mix2.invalid) return { [prop]: value };
    const cssVar2 = "--mix-" + prop;
    return {
      [cssVar2]: mix2.value,
      [prop]: `var(${cssVar2}, ${mix2.color})`
    };
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (Array.isArray(obj)) return obj.map((prop) => clone(prop));
    const _clone = Object.create(Object.getPrototypeOf(obj));
    for (const key of Object.keys(obj)) {
      _clone[key] = clone(obj[key]);
    }
    return _clone;
  }
  function merge(target, source) {
    if (source == null) return target;
    for (const key of Object.keys(source)) {
      if (source[key] === void 0 || key === "__proto__") continue;
      if (!isObject$3(target[key]) && isObject$3(source[key])) {
        Object.assign(target, { [key]: source[key] });
      } else if (target[key] && isObject$3(source[key])) {
        merge(target[key], source[key]);
      } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {
        let i = 0;
        for (; i < source[key].length; i++) {
          if (isObject$3(target[key][i]) && isObject$3(source[key][i])) {
            merge(target[key][i], source[key][i]);
          } else {
            target[key][i] = source[key][i];
          }
        }
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
    return target;
  }
  function mergeWith(target, ...sources) {
    for (const source of sources) {
      merge(target, source);
    }
    return target;
  }
  const isNotNullish = (element) => element != null;
  function walkObject(target, predicate, options = {}) {
    const { stop: stop2, getKey } = options;
    function inner(value, path = []) {
      if (isObject$3(value) || Array.isArray(value)) {
        const result = {};
        for (const [prop, child] of Object.entries(value)) {
          const key = getKey?.(prop, child) ?? prop;
          const childPath = [...path, key];
          if (stop2?.(value, childPath)) {
            return predicate(value, path);
          }
          const next2 = inner(child, childPath);
          if (isNotNullish(next2)) {
            result[key] = next2;
          }
        }
        return result;
      }
      return predicate(value, path);
    }
    return inner(target);
  }
  function mapObject(obj, fn) {
    if (Array.isArray(obj))
      return obj.map((value) => {
        return isNotNullish(value) ? fn(value) : value;
      });
    if (!isObject$3(obj)) {
      return isNotNullish(obj) ? fn(obj) : obj;
    }
    return walkObject(obj, (value) => fn(value));
  }
  const tokenKeys = ["value", "type", "description"];
  const isValidToken = (token2) => {
    return token2 && typeof token2 === "object" && !Array.isArray(token2);
  };
  const mergeConfigs = (...configs) => {
    const merged = mergeWith({}, ...configs.map(clone));
    if (merged.theme?.tokens) {
      walkObject(
        merged.theme.tokens,
        (value) => {
          const keys = Object.keys(value);
          const nestedKeys = keys.filter((k) => !tokenKeys.includes(k));
          const hasNested = nestedKeys.length > 0;
          const hasTokenProps = tokenKeys.some((k) => value[k] != null);
          if (hasNested && hasTokenProps) {
            value.DEFAULT || (value.DEFAULT = {});
            tokenKeys.forEach((key) => {
              var _a;
              if (value[key] == null) return;
              (_a = value.DEFAULT)[key] || (_a[key] = value[key]);
              delete value[key];
            });
          }
          return value;
        },
        {
          stop(value) {
            return isValidToken(value) && Object.keys(value).some(
              (k) => tokenKeys.includes(k) || k !== k.toLowerCase() && k !== k.toUpperCase()
            );
          }
        }
      );
    }
    return merged;
  };
  const defineConditions = (v) => v;
  const defineRecipe = (v) => v;
  const defineSlotRecipe = (v) => v;
  const defineKeyframes = (v) => v;
  const defineGlobalStyles = (v) => v;
  const defineStyle = (v) => v;
  const defineTextStyles = (v) => v;
  const defineAnimationStyles = (v) => v;
  const defineLayerStyles = (v) => v;
  function createProxy() {
    const identity2 = (v) => v;
    return new Proxy(identity2, {
      get() {
        return identity2;
      }
    });
  }
  const defineTokens = createProxy();
  const defineSemanticTokens = createProxy();
  const defineConfig = (v) => v;
  const escRegex = /[^a-zA-Z0-9_\u0081-\uffff-]/g;
  function esc$1(string) {
    return `${string}`.replace(escRegex, (s) => `\\${s}`);
  }
  const dashCaseRegex = /[A-Z]/g;
  function dashCase(string) {
    return string.replace(dashCaseRegex, (match2) => `-${match2.toLowerCase()}`);
  }
  function cssVar(name, options = {}) {
    const { fallback: fallback2 = "", prefix: prefix2 = "" } = options;
    const variable = dashCase(["-", prefix2, esc$1(name)].filter(Boolean).join("-"));
    return {
      var: variable,
      ref: `var(${variable}${fallback2 ? `, ${fallback2}` : ""})`
    };
  }
  const isCssVar = (v) => /^var\(--.+\)$/.test(v);
  const wrap = (str, v) => v != null ? `${str}(${v})` : v;
  const deg = (v) => {
    if (isCssVar(v) || v == null) return v;
    const unitless = typeof v === "string" && !v.endsWith("deg");
    return typeof v === "number" || unitless ? `${v}deg` : v;
  };
  const createFocusRing = (selector) => {
    return {
      values: ["outside", "inside", "mixed", "none"],
      transform(value, { token: token2 }) {
        const focusRingColor = token2("colors.colorPalette.focusRing");
        const styles = {
          inside: {
            "--focus-ring-color": focusRingColor,
            [selector]: {
              outlineOffset: "0px",
              outlineWidth: "var(--focus-ring-width, 1px)",
              outlineColor: "var(--focus-ring-color)",
              outlineStyle: "var(--focus-ring-style, solid)",
              borderColor: "var(--focus-ring-color)"
            }
          },
          outside: {
            "--focus-ring-color": focusRingColor,
            [selector]: {
              outlineWidth: "var(--focus-ring-width, 2px)",
              outlineOffset: "var(--focus-ring-offset, 2px)",
              outlineStyle: "var(--focus-ring-style, solid)",
              outlineColor: "var(--focus-ring-color)"
            }
          },
          mixed: {
            "--focus-ring-color": focusRingColor,
            [selector]: {
              outlineWidth: "var(--focus-ring-width, 3px)",
              outlineStyle: "var(--focus-ring-style, solid)",
              outlineColor: "color-mix(in srgb, var(--focus-ring-color), transparent 60%)",
              borderColor: "var(--focus-ring-color)"
            }
          },
          none: {
            "--focus-ring-color": focusRingColor,
            [selector]: {
              outline: "none"
            }
          }
        };
        return styles[value] ?? {};
      }
    };
  };
  const divideColor = createColorMixTransform("borderColor");
  const createTransition = (value) => {
    return {
      transition: value,
      transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
      transitionDuration: "150ms"
    };
  };
  const defaultConditions = defineConditions({
    hover: [
      "@media (hover: hover)",
      "&:is(:hover, [data-hover]):not(:disabled, [data-disabled])"
    ],
    active: "&:is(:active, [data-active]):not(:disabled, [data-disabled], [data-state=open])",
    focus: "&:is(:focus, [data-focus])",
    focusWithin: "&:is(:focus-within, [data-focus-within])",
    focusVisible: "&:is(:focus-visible, [data-focus-visible])",
    disabled: "&:is(:disabled, [disabled], [data-disabled], [aria-disabled=true])",
    visited: "&:visited",
    target: "&:target",
    readOnly: "&:is([data-readonly], [aria-readonly=true], [readonly])",
    readWrite: "&:read-write",
    empty: "&:is(:empty, [data-empty])",
    checked: "&:is(:checked, [data-checked], [aria-checked=true], [data-state=checked])",
    enabled: "&:enabled",
    expanded: "&:is([aria-expanded=true], [data-expanded], [data-state=expanded])",
    highlighted: "&[data-highlighted]",
    complete: "&[data-complete]",
    incomplete: "&[data-incomplete]",
    dragging: "&[data-dragging]",
    before: "&::before",
    after: "&::after",
    firstLetter: "&::first-letter",
    firstLine: "&::first-line",
    marker: "&::marker",
    selection: "&::selection",
    file: "&::file-selector-button",
    backdrop: "&::backdrop",
    first: "&:first-of-type",
    last: "&:last-of-type",
    notFirst: "&:not(:first-of-type)",
    notLast: "&:not(:last-of-type)",
    only: "&:only-child",
    even: "&:nth-of-type(even)",
    odd: "&:nth-of-type(odd)",
    peerFocus: ".peer:is(:focus, [data-focus]) ~ &",
    peerHover: ".peer:is(:hover, [data-hover]):not(:disabled, [data-disabled]) ~ &",
    peerActive: ".peer:is(:active, [data-active]):not(:disabled, [data-disabled]) ~ &",
    peerFocusWithin: ".peer:focus-within ~ &",
    peerFocusVisible: ".peer:is(:focus-visible, [data-focus-visible]) ~ &",
    peerDisabled: ".peer:is(:disabled, [disabled], [data-disabled]) ~ &",
    peerChecked: ".peer:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) ~ &",
    peerInvalid: ".peer:is(:invalid, [data-invalid], [aria-invalid=true]) ~ &",
    peerExpanded: ".peer:is([aria-expanded=true], [data-expanded], [data-state=expanded]) ~ &",
    peerPlaceholderShown: ".peer:placeholder-shown ~ &",
    groupFocus: ".group:is(:focus, [data-focus]) &",
    groupHover: ".group:is(:hover, [data-hover]):not(:disabled, [data-disabled]) &",
    groupActive: ".group:is(:active, [data-active]):not(:disabled, [data-disabled]) &",
    groupFocusWithin: ".group:focus-within &",
    groupFocusVisible: ".group:is(:focus-visible, [data-focus-visible]) &",
    groupDisabled: ".group:is(:disabled, [disabled], [data-disabled]) &",
    groupChecked: ".group:is(:checked, [data-checked], [aria-checked=true], [data-state=checked]) &",
    groupExpanded: ".group:is([aria-expanded=true], [data-expanded], [data-state=expanded]) &",
    groupInvalid: ".group:invalid &",
    indeterminate: "&:is(:indeterminate, [data-indeterminate], [aria-checked=mixed], [data-state=indeterminate])",
    required: "&:is([data-required], [aria-required=true])",
    valid: "&:is([data-valid], [data-state=valid])",
    invalid: "&:is([data-invalid], [aria-invalid=true], [data-state=invalid])",
    autofill: "&:autofill",
    inRange: "&:is(:in-range, [data-in-range])",
    outOfRange: "&:is(:out-of-range, [data-outside-range])",
    placeholder: "&::placeholder, &[data-placeholder]",
    placeholderShown: "&:is(:placeholder-shown, [data-placeholder-shown])",
    pressed: "&:is([aria-pressed=true], [data-pressed])",
    selected: "&:is([aria-selected=true], [data-selected])",
    grabbed: "&:is([aria-grabbed=true], [data-grabbed])",
    underValue: "&[data-state=under-value]",
    overValue: "&[data-state=over-value]",
    atValue: "&[data-state=at-value]",
    default: "&:default",
    optional: "&:optional",
    open: "&:is([open], [data-open], [data-state=open])",
    closed: "&:is([closed], [data-closed], [data-state=closed])",
    fullscreen: "&:is(:fullscreen, [data-fullscreen])",
    loading: "&:is([data-loading], [aria-busy=true])",
    hidden: "&:is([hidden], [data-hidden])",
    current: "&[data-current]",
    currentPage: "&[aria-current=page]",
    currentStep: "&[aria-current=step]",
    today: "&[data-today]",
    unavailable: "&[data-unavailable]",
    rangeStart: "&[data-range-start]",
    rangeEnd: "&[data-range-end]",
    now: "&[data-now]",
    topmost: "&[data-topmost]",
    motionReduce: "@media (prefers-reduced-motion: reduce)",
    motionSafe: "@media (prefers-reduced-motion: no-preference)",
    print: "@media print",
    landscape: "@media (orientation: landscape)",
    portrait: "@media (orientation: portrait)",
    dark: ".dark &, .dark .chakra-theme:not(.light) &",
    light: ":root &, .light &",
    osDark: "@media (prefers-color-scheme: dark)",
    osLight: "@media (prefers-color-scheme: light)",
    highContrast: "@media (forced-colors: active)",
    lessContrast: "@media (prefers-contrast: less)",
    moreContrast: "@media (prefers-contrast: more)",
    ltr: "[dir=ltr] &",
    rtl: "[dir=rtl] &",
    scrollbar: "&::-webkit-scrollbar",
    scrollbarThumb: "&::-webkit-scrollbar-thumb",
    scrollbarTrack: "&::-webkit-scrollbar-track",
    horizontal: "&[data-orientation=horizontal]",
    vertical: "&[data-orientation=vertical]",
    icon: "& :where(svg)",
    starting: "@starting-style"
  });
  const currentBgVar = cssVar("bg-currentcolor");
  const isCurrentBgVar = (value) => value === currentBgVar.ref || value === "currentBg";
  const colorValues = (theme) => ({
    ...theme("colors"),
    currentBg: currentBgVar
  });
  const defaultBaseConfig = defineConfig({
    conditions: defaultConditions,
    utilities: {
background: {
        values: colorValues,
        shorthand: ["bg"],
        transform(value, args) {
          if (isCurrentBgVar(args.raw)) return { background: currentBgVar.ref };
          const styleObj = createColorMixTransform("background")(value, args);
          return { ...styleObj, [currentBgVar.var]: styleObj?.background };
        }
      },
      backgroundColor: {
        values: colorValues,
        shorthand: ["bgColor"],
        transform(value, args) {
          if (isCurrentBgVar(args.raw))
            return { backgroundColor: currentBgVar.ref };
          const styleObj = createColorMixTransform("backgroundColor")(value, args);
          return {
            ...styleObj,
            [currentBgVar.var]: styleObj?.backgroundColor
          };
        }
      },
      backgroundSize: { shorthand: ["bgSize"] },
      backgroundPosition: { shorthand: ["bgPos"] },
      backgroundRepeat: { shorthand: ["bgRepeat"] },
      backgroundAttachment: { shorthand: ["bgAttachment"] },
      backgroundClip: {
        shorthand: ["bgClip"],
        values: ["text"],
        transform(value) {
          return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
        }
      },
      backgroundGradient: {
        shorthand: ["bgGradient"],
        values(theme) {
          return {
            ...theme("gradients"),
            "to-t": "linear-gradient(to top, var(--gradient))",
            "to-tr": "linear-gradient(to top right, var(--gradient))",
            "to-r": "linear-gradient(to right, var(--gradient))",
            "to-br": "linear-gradient(to bottom right, var(--gradient))",
            "to-b": "linear-gradient(to bottom, var(--gradient))",
            "to-bl": "linear-gradient(to bottom left, var(--gradient))",
            "to-l": "linear-gradient(to left, var(--gradient))",
            "to-tl": "linear-gradient(to top left, var(--gradient))"
          };
        },
        transform(value) {
          return {
            "--gradient-stops": "var(--gradient-from), var(--gradient-to)",
            "--gradient": "var(--gradient-via-stops, var(--gradient-stops))",
            backgroundImage: value
          };
        }
      },
      gradientFrom: {
        values: colorValues,
        transform: createColorMixTransform("--gradient-from")
      },
      gradientTo: {
        values: colorValues,
        transform: createColorMixTransform("--gradient-to")
      },
      gradientVia: {
        values: colorValues,
        transform(value, args) {
          const styles = createColorMixTransform("--gradient-via")(value, args);
          return {
            ...styles,
            "--gradient-via-stops": "var(--gradient-from), var(--gradient-via), var(--gradient-to)"
          };
        }
      },
      backgroundImage: {
        values(theme) {
          return { ...theme("gradients"), ...theme("assets") };
        },
        shorthand: ["bgImg", "bgImage"]
      },
border: { values: "borders" },
      borderTop: { values: "borders" },
      borderLeft: { values: "borders" },
      borderBlockStart: { values: "borders" },
      borderRight: { values: "borders" },
      borderBottom: { values: "borders" },
      borderBlockEnd: { values: "borders" },
      borderInlineStart: { values: "borders", shorthand: ["borderStart"] },
      borderInlineEnd: { values: "borders", shorthand: ["borderEnd"] },
      borderInline: { values: "borders", shorthand: ["borderX"] },
      borderBlock: { values: "borders", shorthand: ["borderY"] },
borderColor: {
        values: colorValues,
        transform: createColorMixTransform("borderColor")
      },
      borderTopColor: {
        values: colorValues,
        transform: createColorMixTransform("borderTopColor")
      },
      borderBlockStartColor: {
        values: colorValues,
        transform: createColorMixTransform("borderBlockStartColor")
      },
      borderBottomColor: {
        values: colorValues,
        transform: createColorMixTransform("borderBottomColor")
      },
      borderBlockEndColor: {
        values: colorValues,
        transform: createColorMixTransform("borderBlockEndColor")
      },
      borderLeftColor: {
        values: colorValues,
        transform: createColorMixTransform("borderLeftColor")
      },
      borderInlineStartColor: {
        values: colorValues,
        shorthand: ["borderStartColor"],
        transform: createColorMixTransform("borderInlineStartColor")
      },
      borderRightColor: {
        values: colorValues,
        transform: createColorMixTransform("borderRightColor")
      },
      borderInlineEndColor: {
        values: colorValues,
        shorthand: ["borderEndColor"],
        transform: createColorMixTransform("borderInlineEndColor")
      },
borderStyle: { values: "borderStyles" },
      borderTopStyle: { values: "borderStyles" },
      borderBlockStartStyle: { values: "borderStyles" },
      borderBottomStyle: { values: "borderStyles" },
      borderBlockEndStyle: {
        values: "borderStyles"
      },
      borderInlineStartStyle: {
        values: "borderStyles",
        shorthand: ["borderStartStyle"]
      },
      borderInlineEndStyle: {
        values: "borderStyles",
        shorthand: ["borderEndStyle"]
      },
      borderLeftStyle: { values: "borderStyles" },
      borderRightStyle: { values: "borderStyles" },
borderRadius: { values: "radii", shorthand: ["rounded"] },
      borderTopLeftRadius: { values: "radii", shorthand: ["roundedTopLeft"] },
      borderStartStartRadius: {
        values: "radii",
        shorthand: ["roundedStartStart", "borderTopStartRadius"]
      },
      borderEndStartRadius: {
        values: "radii",
        shorthand: ["roundedEndStart", "borderBottomStartRadius"]
      },
      borderTopRightRadius: {
        values: "radii",
        shorthand: ["roundedTopRight"]
      },
      borderStartEndRadius: {
        values: "radii",
        shorthand: ["roundedStartEnd", "borderTopEndRadius"]
      },
      borderEndEndRadius: {
        values: "radii",
        shorthand: ["roundedEndEnd", "borderBottomEndRadius"]
      },
      borderBottomLeftRadius: {
        values: "radii",
        shorthand: ["roundedBottomLeft"]
      },
      borderBottomRightRadius: {
        values: "radii",
        shorthand: ["roundedBottomRight"]
      },
      borderInlineStartRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedStart", "borderStartRadius"],
        transform: (value) => ({
          borderStartStartRadius: value,
          borderEndStartRadius: value
        })
      },
      borderInlineEndRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedEnd", "borderEndRadius"],
        transform: (value) => ({
          borderStartEndRadius: value,
          borderEndEndRadius: value
        })
      },
      borderTopRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedTop"],
        transform: (value) => ({
          borderTopLeftRadius: value,
          borderTopRightRadius: value
        })
      },
      borderBottomRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedBottom"],
        transform: (value) => ({
          borderBottomLeftRadius: value,
          borderBottomRightRadius: value
        })
      },
      borderLeftRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedLeft"],
        transform: (value) => ({
          borderTopLeftRadius: value,
          borderBottomLeftRadius: value
        })
      },
      borderRightRadius: {
        values: "radii",
        property: "borderRadius",
        shorthand: ["roundedRight"],
        transform: (value) => ({
          borderTopRightRadius: value,
          borderBottomRightRadius: value
        })
      },
      borderWidth: { values: "borderWidths" },
      borderBlockStartWidth: { values: "borderWidths" },
      borderTopWidth: { values: "borderWidths" },
      borderBottomWidth: { values: "borderWidths" },
      borderBlockEndWidth: { values: "borderWidths" },
      borderRightWidth: { values: "borderWidths" },
      borderInlineWidth: {
        values: "borderWidths",
        shorthand: ["borderXWidth"]
      },
      borderInlineStartWidth: {
        values: "borderWidths",
        shorthand: ["borderStartWidth"]
      },
      borderInlineEndWidth: {
        values: "borderWidths",
        shorthand: ["borderEndWidth"]
      },
      borderLeftWidth: { values: "borderWidths" },
      borderBlockWidth: {
        values: "borderWidths",
        shorthand: ["borderYWidth"]
      },
color: {
        values: colorValues,
        transform: createColorMixTransform("color")
      },
      fill: {
        values: colorValues,
        transform: createColorMixTransform("fill")
      },
      stroke: {
        values: colorValues,
        transform: createColorMixTransform("stroke")
      },
      accentColor: {
        values: colorValues,
        transform: createColorMixTransform("accentColor")
      },
divideX: {
        values: { type: "string" },
        transform(value) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
              borderInlineStartWidth: value,
              borderInlineEndWidth: "0px"
            }
          };
        }
      },
      divideY: {
        values: { type: "string" },
        transform(value) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
              borderTopWidth: value,
              borderBottomWidth: "0px"
            }
          };
        }
      },
      divideColor: {
        values: colorValues,
        transform(value, args) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": divideColor(
              value,
              args
            )
          };
        }
      },
      divideStyle: {
        property: "borderStyle",
        transform(value) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
              borderStyle: value
            }
          };
        }
      },
boxShadow: { values: "shadows", shorthand: ["shadow"] },
      boxShadowColor: {
        values: colorValues,
        transform: createColorMixTransform("--shadow-color"),
        shorthand: ["shadowColor"]
      },
      mixBlendMode: { shorthand: ["blendMode"] },
      backgroundBlendMode: { shorthand: ["bgBlendMode"] },
      opacity: { values: "opacity" },
filter: {
        transform(v) {
          if (v !== "auto") {
            return { filter: v };
          }
          return {
            filter: `var(--blur) var(--brightness) var(--contrast) var(--grayscale) var(--hue-rotate) var(--invert) var(--saturate) var(--sepia) var(--drop-shadow)`
          };
        }
      },
      blur: {
        values: "blurs",
        transform: (v) => ({ "--blur": wrap("blur", v) })
      },
      brightness: {
        transform: (v) => ({ "--brightness": wrap("brightness", v) })
      },
      contrast: {
        transform: (v) => ({ "--contrast": wrap("contrast", v) })
      },
      grayscale: {
        transform: (v) => ({ "--grayscale": wrap("grayscale", v) })
      },
      hueRotate: {
        transform: (v) => ({ "--hue-rotate": wrap("hue-rotate", deg(v)) })
      },
      invert: { transform: (v) => ({ "--invert": wrap("invert", v) }) },
      saturate: {
        transform: (v) => ({ "--saturate": wrap("saturate", v) })
      },
      sepia: { transform: (v) => ({ "--sepia": wrap("sepia", v) }) },
      dropShadow: {
        transform: (v) => ({ "--drop-shadow": wrap("drop-shadow", v) })
      },
backdropFilter: {
        transform(v) {
          if (v !== "auto") {
            return { backdropFilter: v };
          }
          return {
            backdropFilter: `var(--backdrop-blur) var(--backdrop-brightness) var(--backdrop-contrast) var(--backdrop-grayscale) var(--backdrop-hue-rotate) var(--backdrop-invert) var(--backdrop-opacity) var(--backdrop-saturate) var(--backdrop-sepia)`
          };
        }
      },
      backdropBlur: {
        values: "blurs",
        transform: (v) => ({ "--backdrop-blur": wrap("blur", v) })
      },
      backdropBrightness: {
        transform: (v) => ({
          "--backdrop-brightness": wrap("brightness", v)
        })
      },
      backdropContrast: {
        transform: (v) => ({ "--backdrop-contrast": wrap("contrast", v) })
      },
      backdropGrayscale: {
        transform: (v) => ({
          "--backdrop-grayscale": wrap("grayscale", v)
        })
      },
      backdropHueRotate: {
        transform: (v) => ({
          "--backdrop-hue-rotate": wrap("hue-rotate", deg(v))
        })
      },
      backdropInvert: {
        transform: (v) => ({ "--backdrop-invert": wrap("invert", v) })
      },
      backdropOpacity: {
        transform: (v) => ({ "--backdrop-opacity": wrap("opacity", v) })
      },
      backdropSaturate: {
        transform: (v) => ({ "--backdrop-saturate": wrap("saturate", v) })
      },
      backdropSepia: {
        transform: (v) => ({ "--backdrop-sepia": wrap("sepia", v) })
      },
flexBasis: { values: "sizes" },
      gap: { values: "spacing" },
      rowGap: { values: "spacing", shorthand: ["gapY"] },
      columnGap: { values: "spacing", shorthand: ["gapX"] },
      flexDirection: { shorthand: ["flexDir"] },
gridGap: { values: "spacing" },
      gridColumnGap: { values: "spacing" },
      gridRowGap: { values: "spacing" },
outlineColor: {
        values: colorValues,
        transform: createColorMixTransform("outlineColor")
      },
      focusRing: createFocusRing("&:is(:focus, [data-focus])"),
      focusVisibleRing: createFocusRing(
        "&:is(:focus-visible, [data-focus-visible])"
      ),
      focusRingColor: {
        values: colorValues,
        transform: createColorMixTransform("--focus-ring-color")
      },
      focusRingOffset: {
        values: "spacing",
        transform: (v) => ({ "--focus-ring-offset": v })
      },
      focusRingWidth: {
        values: "borderWidths",
        property: "outlineWidth",
        transform: (v) => ({ "--focus-ring-width": v })
      },
      focusRingStyle: {
        values: "borderStyles",
        property: "outlineStyle",
        transform: (v) => ({ "--focus-ring-style": v })
      },
aspectRatio: { values: "aspectRatios" },
      width: { values: "sizes", shorthand: ["w"] },
      inlineSize: { values: "sizes" },
      height: { values: "sizes", shorthand: ["h"] },
      blockSize: { values: "sizes" },
      boxSize: {
        values: "sizes",
        property: "width",
        transform: (v) => ({ width: v, height: v })
      },
      minWidth: { values: "sizes", shorthand: ["minW"] },
      minInlineSize: { values: "sizes" },
      minHeight: { values: "sizes", shorthand: ["minH"] },
      minBlockSize: { values: "sizes" },
      maxWidth: { values: "sizes", shorthand: ["maxW"] },
      maxInlineSize: { values: "sizes" },
      maxHeight: { values: "sizes", shorthand: ["maxH"] },
      maxBlockSize: { values: "sizes" },
      hideFrom: {
        values: "breakpoints",
transform: (value, { raw, token: token2 }) => {
          const bp = token2.raw(`breakpoints.${raw}`);
          const media = bp ? `@breakpoint ${raw}` : `@media screen and (min-width: ${value})`;
          return {
            [media]: { display: "none" }
          };
        }
      },
      hideBelow: {
        values: "breakpoints",
transform(value, { raw, token: token2 }) {
          const bp = token2.raw(`breakpoints.${raw}`);
          const media = bp ? `@breakpoint ${raw}Down` : `@media screen and (max-width: ${value})`;
          return {
            [media]: {
              display: "none"
            }
          };
        }
      },
overscrollBehavior: { shorthand: ["overscroll"] },
      overscrollBehaviorX: { shorthand: ["overscrollX"] },
      overscrollBehaviorY: { shorthand: ["overscrollY"] },
      scrollbar: {
        values: ["visible", "hidden"],
        transform(v) {
          switch (v) {
            case "visible":
              return {
                msOverflowStyle: "auto",
                scrollbarWidth: "auto",
                "&::-webkit-scrollbar": { display: "block" }
              };
            case "hidden":
              return {
                msOverflowStyle: "none",
                scrollbarWidth: "none",
                "&::-webkit-scrollbar": { display: "none" }
              };
            default:
              return {};
          }
        }
      },
      scrollbarColor: {
        values: colorValues,
        transform: createColorMixTransform("scrollbarColor")
      },
      scrollbarGutter: { values: "spacing" },
      scrollbarWidth: { values: "sizes" },
scrollMargin: { values: "spacing" },
      scrollMarginTop: { values: "spacing" },
      scrollMarginBottom: { values: "spacing" },
      scrollMarginLeft: { values: "spacing" },
      scrollMarginRight: { values: "spacing" },
      scrollMarginX: {
        values: "spacing",
        transform: (v) => ({ scrollMarginLeft: v, scrollMarginRight: v })
      },
      scrollMarginY: {
        values: "spacing",
        transform: (v) => ({ scrollMarginTop: v, scrollMarginBottom: v })
      },
scrollPadding: { values: "spacing" },
      scrollPaddingTop: { values: "spacing" },
      scrollPaddingBottom: { values: "spacing" },
      scrollPaddingLeft: { values: "spacing" },
      scrollPaddingRight: { values: "spacing" },
      scrollPaddingInline: { values: "spacing", shorthand: ["scrollPaddingX"] },
      scrollPaddingBlock: { values: "spacing", shorthand: ["scrollPaddingY"] },
scrollSnapType: {
        values: {
          none: "none",
          x: "x var(--scroll-snap-strictness)",
          y: "y var(--scroll-snap-strictness)",
          both: "both var(--scroll-snap-strictness)"
        }
      },
      scrollSnapStrictness: {
        values: ["mandatory", "proximity"],
        transform: (v) => ({ "--scroll-snap-strictness": v })
      },
      scrollSnapMargin: { values: "spacing" },
      scrollSnapMarginTop: { values: "spacing" },
      scrollSnapMarginBottom: { values: "spacing" },
      scrollSnapMarginLeft: { values: "spacing" },
      scrollSnapMarginRight: { values: "spacing" },
listStylePosition: { shorthand: ["listStylePos"] },
      listStyleImage: { values: "assets", shorthand: ["listStyleImg"] },
position: { shorthand: ["pos"] },
      zIndex: { values: "zIndex" },
      inset: { values: "spacing" },
      insetInline: { values: "spacing", shorthand: ["insetX"] },
      insetBlock: { values: "spacing", shorthand: ["insetY"] },
      top: { values: "spacing" },
      insetBlockStart: { values: "spacing" },
      bottom: { values: "spacing" },
      insetBlockEnd: { values: "spacing" },
      left: { values: "spacing" },
      right: { values: "spacing" },
      insetInlineStart: {
        values: "spacing",
        shorthand: ["insetStart"]
      },
      insetInlineEnd: {
        values: "spacing",
        shorthand: ["insetEnd"]
      },
ring: {
        transform(value) {
          return {
            "--ring-offset-shadow": `var(--ring-inset) 0 0 0 var(--ring-offset-width) var(--ring-offset-color)`,
            "--ring-shadow": `var(--ring-inset) 0 0 0 calc(var(--ring-width) + var(--ring-offset-width)) var(--ring-color)`,
            "--ring-width": value,
            boxShadow: "var(--ring-offset-shadow), var(--ring-shadow), var(--shadow, 0 0 #0000)"
          };
        }
      },
      ringColor: {
        values: colorValues,
        transform: createColorMixTransform("--ring-color")
      },
      ringOffset: {
        transform: (value) => ({ "--ring-offset-width": value })
      },
      ringOffsetColor: {
        values: colorValues,
        transform: createColorMixTransform("--ring-offset-color")
      },
      ringInset: {
        transform: (v) => ({ "--ring-inset": v })
      },
margin: { values: "spacing", shorthand: ["m"] },
      marginTop: { values: "spacing", shorthand: ["mt"] },
      marginBlockStart: { values: "spacing" },
      marginRight: { values: "spacing", shorthand: ["mr"] },
      marginBottom: { values: "spacing", shorthand: ["mb"] },
      marginBlockEnd: { values: "spacing" },
      marginLeft: { values: "spacing", shorthand: ["ml"] },
      marginInlineStart: { values: "spacing", shorthand: ["ms", "marginStart"] },
      marginInlineEnd: { values: "spacing", shorthand: ["me", "marginEnd"] },
      marginInline: { values: "spacing", shorthand: ["mx", "marginX"] },
      marginBlock: { values: "spacing", shorthand: ["my", "marginY"] },
padding: { values: "spacing", shorthand: ["p"] },
      paddingTop: { values: "spacing", shorthand: ["pt"] },
      paddingRight: { values: "spacing", shorthand: ["pr"] },
      paddingBottom: { values: "spacing", shorthand: ["pb"] },
      paddingBlockStart: { values: "spacing" },
      paddingBlockEnd: { values: "spacing" },
      paddingLeft: { values: "spacing", shorthand: ["pl"] },
      paddingInlineStart: {
        values: "spacing",
        shorthand: ["ps", "paddingStart"]
      },
      paddingInlineEnd: { values: "spacing", shorthand: ["pe", "paddingEnd"] },
      paddingInline: { values: "spacing", shorthand: ["px", "paddingX"] },
      paddingBlock: { values: "spacing", shorthand: ["py", "paddingY"] },
textDecoration: { shorthand: ["textDecor"] },
      textDecorationColor: {
        values: colorValues,
        transform: createColorMixTransform("textDecorationColor")
      },
      textShadow: { values: "shadows" },
transform: {
        transform: (value) => {
          let v = value;
          if (value === "auto") {
            v = `translateX(var(--translate-x, 0)) translateY(var(--translate-y, 0)) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
          }
          if (value === "auto-gpu") {
            v = `translate3d(var(--translate-x, 0), var(--translate-y, 0), 0) rotate(var(--rotate, 0)) scaleX(var(--scale-x, 1)) scaleY(var(--scale-y, 1)) skewX(var(--skew-x, 0)) skewY(var(--skew-y, 0))`;
          }
          return { transform: v };
        }
      },
      skewX: { transform: (v) => ({ "--skew-x": deg(v) }) },
      skewY: { transform: (v) => ({ "--skew-y": deg(v) }) },
      scaleX: { transform: (v) => ({ "--scale-x": v }) },
      scaleY: { transform: (v) => ({ "--scale-y": v }) },
      scale: {
        transform(value) {
          if (value !== "auto") return { scale: value };
          return {
            scale: `var(--scale-x, 1) var(--scale-y, 1)`
          };
        }
      },
      spaceXReverse: {
        values: { type: "boolean" },
        transform(value) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
              "--space-x-reverse": value ? "1" : void 0
            }
          };
        }
      },
      spaceX: {
        property: "marginInlineStart",
        values: "spacing",
        transform: (v) => ({
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-x-reverse": "0",
            marginInlineStart: `calc(${v} * calc(1 - var(--space-x-reverse)))`,
            marginInlineEnd: `calc(${v} * var(--space-x-reverse))`
          }
        })
      },
      spaceYReverse: {
        values: { type: "boolean" },
        transform(value) {
          return {
            "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
              "--space-y-reverse": value ? "1" : void 0
            }
          };
        }
      },
      spaceY: {
        property: "marginTop",
        values: "spacing",
        transform: (v) => ({
          "& > :not(style, [hidden]) ~ :not(style, [hidden])": {
            "--space-y-reverse": "0",
            marginTop: `calc(${v} * calc(1 - var(--space-y-reverse)))`,
            marginBottom: `calc(${v} * var(--space-y-reverse))`
          }
        })
      },
      rotate: {
        transform(value) {
          if (value !== "auto") return { rotate: deg(value) };
          return {
            rotate: `var(--rotate-x, 0) var(--rotate-y, 0) var(--rotate-z, 0)`
          };
        }
      },
      rotateX: {
        transform(value) {
          return { "--rotate-x": deg(value) };
        }
      },
      rotateY: {
        transform(value) {
          return { "--rotate-y": deg(value) };
        }
      },
translate: {
        transform(value) {
          if (value !== "auto") return { translate: value };
          return {
            translate: `var(--translate-x) var(--translate-y)`
          };
        }
      },
      translateX: {
        values: "spacing",
        transform: (v) => ({ "--translate-x": v })
      },
      translateY: {
        values: "spacing",
        transform: (v) => ({ "--translate-y": v })
      },
transition: {
        values: [
          "all",
          "common",
          "colors",
          "opacity",
          "position",
          "backgrounds",
          "size",
          "shadow",
          "transform"
        ],
        transform(value) {
          switch (value) {
            case "all":
              return createTransition("all");
            case "position":
              return createTransition(
                "left, right, top, bottom, inset-inline, inset-block"
              );
            case "colors":
              return createTransition(
                "color, background-color, border-color, text-decoration-color, fill, stroke"
              );
            case "opacity":
              return createTransition("opacity");
            case "shadow":
              return createTransition("box-shadow");
            case "transform":
              return createTransition("transform");
            case "size":
              return createTransition("width, height");
            case "backgrounds":
              return createTransition(
                "background, background-color, background-image, background-position"
              );
            case "common":
              return createTransition(
                "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter"
              );
            default:
              return { transition: value };
          }
        }
      },
      transitionDuration: { values: "durations" },
      transitionProperty: {
        values: {
          common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, translate, transform",
          colors: "background-color, border-color, color, fill, stroke",
          size: "width, height",
          position: "left, right, top, bottom, inset-inline, inset-block",
          background: "background, background-color, background-image, background-position"
        }
      },
      transitionTimingFunction: { values: "easings" },
animation: { values: "animations" },
      animationDuration: { values: "durations" },
      animationDelay: { values: "durations" },
      animationTimingFunction: { values: "easings" },
fontFamily: { values: "fonts" },
      fontSize: { values: "fontSizes" },
      fontWeight: { values: "fontWeights" },
      lineHeight: { values: "lineHeights" },
      letterSpacing: { values: "letterSpacings" },
      textIndent: { values: "spacing" },
      truncate: {
        values: { type: "boolean" },
        transform(value) {
          if (value === true) {
            return {
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap"
            };
          }
          return {};
        }
      },
      lineClamp: {
        transform(value) {
          if (value === "none") {
            return {
              WebkitLineClamp: "unset"
            };
          }
          return {
            overflow: "hidden",
            display: "-webkit-box",
            WebkitLineClamp: value,
            WebkitBoxOrient: "vertical",
            textWrap: "wrap"
          };
        }
      },
borderSpacing: {
        values: (token2) => ({
          ...token2("spacing"),
          auto: "var(--border-spacing-x, 0) var(--border-spacing-y, 0)"
        })
      },
      borderSpacingX: {
        values: "spacing",
        transform(value) {
          return {
            "--border-spacing-x": value
          };
        }
      },
      borderSpacingY: {
        values: "spacing",
        transform(value) {
          return {
            "--border-spacing-y": value
          };
        }
      },
srOnly: {
        values: { type: "boolean" },
        transform(value) {
          return srMapping[value] || {};
        }
      },
      debug: {
        values: { type: "boolean" },
        transform(value) {
          if (!value) return {};
          return {
            outline: "1px solid blue !important",
            "& > *": {
              outline: "1px solid red !important"
            }
          };
        }
      },
      caretColor: {
        values: colorValues,
        transform: createColorMixTransform("caretColor")
      },
      cursor: { values: "cursor" }
    }
  });
  const srMapping = {
    true: {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      borderWidth: "0"
    },
    false: {
      position: "static",
      width: "auto",
      height: "auto",
      padding: "0",
      margin: "0",
      overflow: "visible",
      clip: "auto",
      whiteSpace: "normal"
    }
  };
  var userGeneratedStr = "";
  var userGenerated = userGeneratedStr.split(",");
  var cssPropertiesStr = "WebkitAppearance,WebkitBorderBefore,WebkitBorderBeforeColor,WebkitBorderBeforeStyle,WebkitBorderBeforeWidth,WebkitBoxReflect,WebkitLineClamp,WebkitMask,WebkitMaskAttachment,WebkitMaskClip,WebkitMaskComposite,WebkitMaskImage,WebkitMaskOrigin,WebkitMaskPosition,WebkitMaskPositionX,WebkitMaskPositionY,WebkitMaskRepeat,WebkitMaskRepeatX,WebkitMaskRepeatY,WebkitMaskSize,WebkitOverflowScrolling,WebkitTapHighlightColor,WebkitTextFillColor,WebkitTextStroke,WebkitTextStrokeColor,WebkitTextStrokeWidth,WebkitTouchCallout,WebkitUserModify,WebkitUserSelect,accentColor,alignContent,alignItems,alignSelf,alignTracks,all,anchorName,anchorScope,animation,animationComposition,animationDelay,animationDirection,animationDuration,animationFillMode,animationIterationCount,animationName,animationPlayState,animationRange,animationRangeEnd,animationRangeStart,animationTimeline,animationTimingFunction,appearance,aspectRatio,backdropFilter,backfaceVisibility,background,backgroundAttachment,backgroundBlendMode,backgroundClip,backgroundColor,backgroundImage,backgroundOrigin,backgroundPosition,backgroundPositionX,backgroundPositionY,backgroundRepeat,backgroundSize,blockSize,border,borderBlock,borderBlockColor,borderBlockEnd,borderBlockEndColor,borderBlockEndStyle,borderBlockEndWidth,borderBlockStart,borderBlockStartColor,borderBlockStartStyle,borderBlockStartWidth,borderBlockStyle,borderBlockWidth,borderBottom,borderBottomColor,borderBottomLeftRadius,borderBottomRightRadius,borderBottomStyle,borderBottomWidth,borderCollapse,borderColor,borderEndEndRadius,borderEndStartRadius,borderImage,borderImageOutset,borderImageRepeat,borderImageSlice,borderImageSource,borderImageWidth,borderInline,borderInlineColor,borderInlineEnd,borderInlineEndColor,borderInlineEndStyle,borderInlineEndWidth,borderInlineStart,borderInlineStartColor,borderInlineStartStyle,borderInlineStartWidth,borderInlineStyle,borderInlineWidth,borderLeft,borderLeftColor,borderLeftStyle,borderLeftWidth,borderRadius,borderRight,borderRightColor,borderRightStyle,borderRightWidth,borderSpacing,borderStartEndRadius,borderStartStartRadius,borderStyle,borderTop,borderTopColor,borderTopLeftRadius,borderTopRightRadius,borderTopStyle,borderTopWidth,borderWidth,bottom,boxAlign,boxDecorationBreak,boxDirection,boxFlex,boxFlexGroup,boxLines,boxOrdinalGroup,boxOrient,boxPack,boxShadow,boxSizing,breakAfter,breakBefore,breakInside,captionSide,caret,caretColor,caretShape,clear,clip,clipPath,clipRule,color,colorInterpolationFilters,colorScheme,columnCount,columnFill,columnGap,columnRule,columnRuleColor,columnRuleStyle,columnRuleWidth,columnSpan,columnWidth,columns,contain,containIntrinsicBlockSize,containIntrinsicHeight,containIntrinsicInlineSize,containIntrinsicSize,containIntrinsicWidth,container,containerName,containerType,content,contentVisibility,counterIncrement,counterReset,counterSet,cursor,cx,cy,d,direction,display,dominantBaseline,emptyCells,fieldSizing,fill,fillOpacity,fillRule,filter,flex,flexBasis,flexDirection,flexFlow,flexGrow,flexShrink,flexWrap,float,floodColor,floodOpacity,font,fontFamily,fontFeatureSettings,fontKerning,fontLanguageOverride,fontOpticalSizing,fontPalette,fontSize,fontSizeAdjust,fontSmooth,fontStretch,fontStyle,fontSynthesis,fontSynthesisPosition,fontSynthesisSmallCaps,fontSynthesisStyle,fontSynthesisWeight,fontVariant,fontVariantAlternates,fontVariantCaps,fontVariantEastAsian,fontVariantEmoji,fontVariantLigatures,fontVariantNumeric,fontVariantPosition,fontVariationSettings,fontWeight,forcedColorAdjust,gap,grid,gridArea,gridAutoColumns,gridAutoFlow,gridAutoRows,gridColumn,gridColumnEnd,gridColumnGap,gridColumnStart,gridGap,gridRow,gridRowEnd,gridRowGap,gridRowStart,gridTemplate,gridTemplateAreas,gridTemplateColumns,gridTemplateRows,hangingPunctuation,height,hyphenateCharacter,hyphenateLimitChars,hyphens,imageOrientation,imageRendering,imageResolution,imeMode,initialLetter,initialLetterAlign,inlineSize,inset,insetBlock,insetBlockEnd,insetBlockStart,insetInline,insetInlineEnd,insetInlineStart,interpolateSize,isolation,justifyContent,justifyItems,justifySelf,justifyTracks,left,letterSpacing,lightingColor,lineBreak,lineClamp,lineHeight,lineHeightStep,listStyle,listStyleImage,listStylePosition,listStyleType,margin,marginBlock,marginBlockEnd,marginBlockStart,marginBottom,marginInline,marginInlineEnd,marginInlineStart,marginLeft,marginRight,marginTop,marginTrim,marker,markerEnd,markerMid,markerStart,mask,maskBorder,maskBorderMode,maskBorderOutset,maskBorderRepeat,maskBorderSlice,maskBorderSource,maskBorderWidth,maskClip,maskComposite,maskImage,maskMode,maskOrigin,maskPosition,maskRepeat,maskSize,maskType,masonryAutoFlow,mathDepth,mathShift,mathStyle,maxBlockSize,maxHeight,maxInlineSize,maxLines,maxWidth,minBlockSize,minHeight,minInlineSize,minWidth,mixBlendMode,objectFit,objectPosition,offset,offsetAnchor,offsetDistance,offsetPath,offsetPosition,offsetRotate,opacity,order,orphans,outline,outlineColor,outlineOffset,outlineStyle,outlineWidth,overflow,overflowAnchor,overflowBlock,overflowClipBox,overflowClipMargin,overflowInline,overflowWrap,overflowX,overflowY,overlay,overscrollBehavior,overscrollBehaviorBlock,overscrollBehaviorInline,overscrollBehaviorX,overscrollBehaviorY,padding,paddingBlock,paddingBlockEnd,paddingBlockStart,paddingBottom,paddingInline,paddingInlineEnd,paddingInlineStart,paddingLeft,paddingRight,paddingTop,page,pageBreakAfter,pageBreakBefore,pageBreakInside,paintOrder,perspective,perspectiveOrigin,placeContent,placeItems,placeSelf,pointerEvents,position,positionAnchor,positionArea,positionTry,positionTryFallbacks,positionTryOrder,positionVisibility,printColorAdjust,quotes,r,resize,right,rotate,rowGap,rubyAlign,rubyMerge,rubyPosition,rx,ry,scale,scrollBehavior,scrollMargin,scrollMarginBlock,scrollMarginBlockEnd,scrollMarginBlockStart,scrollMarginBottom,scrollMarginInline,scrollMarginInlineEnd,scrollMarginInlineStart,scrollMarginLeft,scrollMarginRight,scrollMarginTop,scrollPadding,scrollPaddingBlock,scrollPaddingBlockEnd,scrollPaddingBlockStart,scrollPaddingBottom,scrollPaddingInline,scrollPaddingInlineEnd,scrollPaddingInlineStart,scrollPaddingLeft,scrollPaddingRight,scrollPaddingTop,scrollSnapAlign,scrollSnapCoordinate,scrollSnapDestination,scrollSnapPointsX,scrollSnapPointsY,scrollSnapStop,scrollSnapType,scrollSnapTypeX,scrollSnapTypeY,scrollTimeline,scrollTimelineAxis,scrollTimelineName,scrollbarColor,scrollbarGutter,scrollbarWidth,shapeImageThreshold,shapeMargin,shapeOutside,shapeRendering,stopColor,stopOpacity,stroke,strokeDasharray,strokeDashoffset,strokeLinecap,strokeLinejoin,strokeMiterlimit,strokeOpacity,strokeWidth,tabSize,tableLayout,textAlign,textAlignLast,textAnchor,textBox,textBoxEdge,textBoxTrim,textCombineUpright,textDecoration,textDecorationColor,textDecorationLine,textDecorationSkip,textDecorationSkipInk,textDecorationStyle,textDecorationThickness,textEmphasis,textEmphasisColor,textEmphasisPosition,textEmphasisStyle,textIndent,textJustify,textOrientation,textOverflow,textRendering,textShadow,textSizeAdjust,textSpacingTrim,textTransform,textUnderlineOffset,textUnderlinePosition,textWrap,textWrapMode,textWrapStyle,timelineScope,top,touchAction,transform,transformBox,transformOrigin,transformStyle,transition,transitionBehavior,transitionDelay,transitionDuration,transitionProperty,transitionTimingFunction,translate,unicodeBidi,userSelect,vectorEffect,verticalAlign,viewTimeline,viewTimelineAxis,viewTimelineInset,viewTimelineName,viewTransitionName,visibility,whiteSpace,whiteSpaceCollapse,widows,width,willChange,wordBreak,wordSpacing,wordWrap,writingMode,x,y,zIndex,zoom,alignmentBaseline,baselineShift,colorInterpolation,colorRendering,glyphOrientationVertical";
  var allCssProperties = cssPropertiesStr.split(",").concat(userGenerated);
  var properties = new Map(allCssProperties.map((prop) => [prop, true]));
  function memo$2(fn) {
    const cache2 = Object.create(null);
    return (arg) => {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var cssPropertySelectorRegex = /&|@/;
  var isCssProperty = memo$2((prop) => {
    return properties.has(prop) || prop.startsWith("--") || cssPropertySelectorRegex.test(prop);
  });
  function mapEntries(obj, f) {
    const result = {};
    for (const key in obj) {
      const kv = f(key, obj[key]);
      result[kv[0]] = kv[1];
    }
    return result;
  }
  function flatten(values, stop2) {
    const result = {};
    walkObject(
      values,
      (token2, paths) => {
        if (token2) {
          result[paths.join(".")] = token2.value;
        }
      },
      { stop: stop2 }
    );
    return result;
  }
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  function simpleHash(value) {
    if (value === null) return "null";
    if (value === void 0) return "undefined";
    const type = typeof value;
    if (type === "string") return `s:${value}`;
    if (type === "number") return `n:${value}`;
    if (type === "boolean") return `b:${value}`;
    if (type === "function") return `f:${value.name || "anonymous"}`;
    if (Array.isArray(value)) {
      return `a:[${value.map(simpleHash).join(",")}]`;
    }
    if (type === "object") {
      const keys = Object.keys(value).sort();
      return `o:{${keys.map((k) => `${k}:${simpleHash(value[k])}`).join(",")}}`;
    }
    return String(value);
  }
  class LRUCache {
    constructor(maxSize = 500) {
      __publicField(this, "cache", new Map());
      __publicField(this, "maxSize");
      this.maxSize = maxSize;
    }
    get(key) {
      const value = this.cache.get(key);
      if (value !== void 0) {
        this.cache.delete(key);
        this.cache.set(key, value);
      }
      return value;
    }
    set(key, value) {
      if (this.cache.has(key)) {
        this.cache.delete(key);
      } else if (this.cache.size >= this.maxSize) {
        const firstKey = this.cache.keys().next().value;
        if (firstKey !== void 0) {
          this.cache.delete(firstKey);
        }
      }
      this.cache.set(key, value);
    }
    clear() {
      this.cache.clear();
    }
  }
  const memo$1 = (fn) => {
    const cache2 = new LRUCache();
    function get(...args) {
      const key = args.length === 1 ? simpleHash(args[0]) : args.map(simpleHash).join("|");
      let result = cache2.get(key);
      if (result === void 0) {
        result = fn.apply(this, args);
        cache2.set(key, result);
      }
      return result;
    }
    return get;
  };
  const BASE_FONT_SIZE = 16;
  const UNIT_PX = "px";
  const UNIT_EM = "em";
  const UNIT_REM = "rem";
  function getUnit(value = "") {
    const DIGIT_REGEX = new RegExp(String.raw`-?\d+(?:\.\d+|\d*)`);
    const UNIT_REGEX = new RegExp(`${UNIT_PX}|${UNIT_EM}|${UNIT_REM}`);
    const unit = value.match(
      new RegExp(`${DIGIT_REGEX.source}(${UNIT_REGEX.source})`)
    );
    return unit?.[1];
  }
  function toPx(value = "") {
    if (typeof value === "number") {
      return `${value}px`;
    }
    const unit = getUnit(value);
    if (!unit) return value;
    if (unit === UNIT_PX) {
      return value;
    }
    if (unit === UNIT_EM || unit === UNIT_REM) {
      return `${parseFloat(value) * BASE_FONT_SIZE}${UNIT_PX}`;
    }
  }
  function toRem(value = "") {
    const unit = getUnit(value);
    if (!unit) return value;
    if (unit === UNIT_REM) {
      return value;
    }
    if (unit === UNIT_EM) {
      return `${parseFloat(value)}${UNIT_REM}`;
    }
    if (unit === UNIT_PX) {
      return `${parseFloat(value) / BASE_FONT_SIZE}${UNIT_REM}`;
    }
  }
  const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  function createBreakpoints(breakpoints2) {
    const sorted = sort(breakpoints2);
    const values = Object.fromEntries(sorted);
    function get(name) {
      return values[name];
    }
    function only(name) {
      return build(get(name));
    }
    function getRanges() {
      const breakpoints22 = Object.keys(values);
      const permuations = getPermutations(breakpoints22);
      const results = breakpoints22.flatMap((name) => {
        const value = get(name);
        const down2 = [
          `${name}Down`,
          build({ max: adjust(value.min) })
        ];
        const up2 = [name, build({ min: value.min })];
        const _only = [`${name}Only`, only(name)];
        return [up2, _only, down2];
      }).filter(([, value]) => value !== "").concat(
        permuations.map(([min2, max2]) => {
          const minValue = get(min2);
          const maxValue2 = get(max2);
          return [
            `${min2}To${capitalize(max2)}`,
            build({ min: minValue.min, max: adjust(maxValue2.min) })
          ];
        })
      );
      return Object.fromEntries(results);
    }
    function toConditions() {
      const ranges = getRanges();
      return Object.fromEntries(Object.entries(ranges));
    }
    const conditions = toConditions();
    const getCondition = (key) => {
      return conditions[key];
    };
    function keys() {
      return uniq$1(["base", ...Object.keys(values)]);
    }
    function up(name) {
      return build({ min: get(name).min });
    }
    function down(name) {
      return build({ max: adjust(get(name).min) });
    }
    return {
      values: Object.values(values),
      only,
      keys,
      conditions,
      getCondition,
      up,
      down
    };
  }
  function adjust(value) {
    const computedMax = parseFloat(toPx(value) ?? "") - 0.04;
    return toRem(`${computedMax}px`);
  }
  function sort(breakpoints2) {
    const entries = Object.entries(breakpoints2).sort(([, minA], [, minB]) => {
      return parseInt(minA, 10) < parseInt(minB, 10) ? -1 : 1;
    });
    return entries.map(([name, min2], index, entries2) => {
      let max2 = null;
      if (index <= entries2.length - 1) {
        max2 = entries2[index + 1]?.[1];
      }
      if (max2 != null) {
        max2 = adjust(max2);
      }
      return [name, { name, min: toRem(min2), max: max2 }];
    });
  }
  function getPermutations(values) {
    const result = [];
    values.forEach((current, index) => {
      let idx = index;
      idx++;
      let next2 = values[idx];
      while (next2) {
        result.push([current, next2]);
        idx++;
        next2 = values[idx];
      }
    });
    return result;
  }
  function build({
    min: min2,
    max: max2
  }) {
    if (min2 == null && max2 == null) return "";
    return [
      "@media screen",
      min2 && `(min-width: ${min2})`,
      max2 && `(max-width: ${max2})`
    ].filter(Boolean).join(" and ");
  }
  const SPECIAL_KEY_REGEX = /^@|&|&$/;
  const createConditions = (options) => {
    const { breakpoints: breakpoints2, conditions: conds = {} } = options;
    const conditions = mapEntries(conds, (key, value) => [`_${key}`, value]);
    const values = Object.assign({}, conditions, breakpoints2.conditions);
    function keys() {
      return Object.keys(values);
    }
    function has2(key) {
      return keys().includes(key) || SPECIAL_KEY_REGEX.test(key) || key.startsWith("_");
    }
    const sort2 = memo$1((paths) => {
      return paths.filter((v) => v !== "base").sort((a, b2) => {
        const aa = has2(a);
        const bb = has2(b2);
        if (aa && !bb) return 1;
        if (!aa && bb) return -1;
        return 0;
      });
    });
    function expandAtRule(key) {
      if (!key.startsWith("@breakpoint")) return key;
      return breakpoints2.getCondition(key.replace("@breakpoint ", ""));
    }
    function resolve(key) {
      return Reflect.get(values, key) || key;
    }
    return {
      keys,
      sort: sort2,
      has: has2,
      resolve,
      breakpoints: breakpoints2.keys(),
      expandAtRule
    };
  };
  const EMPTY_OBJECT = Object.freeze( Object.create(null));
  const EMPTY_ARRAY = Object.freeze([]);
  function createEmptyObject() {
    return Object.create(null);
  }
  const createMediaQueryRegex = (dimension) => ({
    minMax: new RegExp(
      `(!?\\(\\s*min(-device-)?-${dimension})(.|
)+\\(\\s*max(-device)?-${dimension}`,
      "i"
    ),
    min: new RegExp(`\\(\\s*min(-device)?-${dimension}`, "i"),
    maxMin: new RegExp(
      `(!?\\(\\s*max(-device)?-${dimension})(.|
)+\\(\\s*min(-device)?-${dimension}`,
      "i"
    ),
    max: new RegExp(`\\(\\s*max(-device)?-${dimension}`, "i")
  });
  const widthRegex = createMediaQueryRegex("width");
  const heightRegex = createMediaQueryRegex("height");
  const createQueryTester = (regexSet) => ({
    isMin: _testQuery(regexSet.minMax, regexSet.maxMin, regexSet.min),
    isMax: _testQuery(regexSet.maxMin, regexSet.minMax, regexSet.max)
  });
  const { isMin: isMinWidth, isMax: isMaxWidth } = createQueryTester(widthRegex);
  const { isMin: isMinHeight, isMax: isMaxHeight } = createQueryTester(heightRegex);
  const isPrint = /print/i;
  const isPrintOnly = /^print$/i;
  const isLength = /(-?\d*\.?\d+)(ch|em|ex|px|rem)/;
  const lengthExec = /(\d)/;
  const maxValue = Number.MAX_VALUE;
  const multipliers = { ch: 8.8984375, em: 16, rem: 16, ex: 8.296875, px: 1 };
  function getQueryLength(query2) {
    const length2 = isLength.exec(query2) || (isMinWidth(query2) || isMinHeight(query2) ? lengthExec.exec(query2) : null);
    if (!length2) return maxValue;
    if (length2[0] === "0") return 0;
    const number2 = parseFloat(length2[1]);
    const unit = length2[2];
    return number2 * (multipliers[unit] || 1);
  }
  function _testQuery(doubleTestTrue, doubleTestFalse, singleTest) {
    return (query2) => doubleTestTrue.test(query2) || !doubleTestFalse.test(query2) && singleTest.test(query2);
  }
  function _testIsPrint(a, b2) {
    const isPrintA = isPrint.test(a), isPrintOnlyA = isPrintOnly.test(a);
    const isPrintB = isPrint.test(b2), isPrintOnlyB = isPrintOnly.test(b2);
    if (isPrintA && isPrintB) {
      if (!isPrintOnlyA && isPrintOnlyB) return 1;
      if (isPrintOnlyA && !isPrintOnlyB) return -1;
      return a.localeCompare(b2);
    }
    return isPrintA ? 1 : isPrintB ? -1 : null;
  }
  const sortAtParams = memo$1((a, b2) => {
    const testIsPrint = _testIsPrint(a, b2);
    if (testIsPrint !== null) return testIsPrint;
    const minA = isMinWidth(a) || isMinHeight(a), maxA = isMaxWidth(a) || isMaxHeight(a);
    const minB = isMinWidth(b2) || isMinHeight(b2), maxB = isMaxWidth(b2) || isMaxHeight(b2);
    if (minA && maxB) return -1;
    if (maxA && minB) return 1;
    const lengthA = getQueryLength(a), lengthB = getQueryLength(b2);
    if (lengthA === maxValue && lengthB === maxValue) return a.localeCompare(b2);
    if (lengthA === maxValue) return 1;
    if (lengthB === maxValue) return -1;
    if (lengthA !== lengthB) {
      return lengthA > lengthB ? maxA ? -1 : 1 : maxA ? 1 : -1;
    }
    return a.localeCompare(b2);
  });
  function sortQueries(queries) {
    return queries.sort(([a], [b2]) => sortAtParams(a, b2));
  }
  function sortAtRules(obj) {
    const mediaQueries = [];
    const containerQueries = [];
    const rest = {};
    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith("@media")) {
        mediaQueries.push([key, value]);
      } else if (key.startsWith("@container")) {
        containerQueries.push([key, value]);
      } else if (isObject$3(value)) {
        rest[key] = sortAtRules(value);
      } else {
        rest[key] = value;
      }
    }
    const sortedMediaQueries = sortQueries(mediaQueries);
    const sortedContainerQueries = sortQueries(containerQueries);
    return {
      ...rest,
      ...Object.fromEntries(sortedMediaQueries),
      ...Object.fromEntries(sortedContainerQueries)
    };
  }
  const importantRegex = /\s*!(important)?/i;
  const isImportant = memo$1(
    (v) => isString$1(v) ? importantRegex.test(v) : false
  );
  const withoutImportant = memo$1(
    (v) => isString$1(v) ? v.replace(importantRegex, "").trim() : v
  );
  function createCssFn(context) {
    const { transform, conditions, normalize: normalize2 } = context;
    const mergeFn = mergeCss(context);
    return memo$1(function cssFn(...styleArgs) {
      const styles = mergeFn(...styleArgs);
      const normalized = normalize2(styles);
      const result = createEmptyObject();
      walkObject(normalized, (value, paths) => {
        const important = isImportant(value);
        if (value == null) return;
        const [prop, ...selectors] = conditions.sort(paths).map(conditions.resolve);
        if (important) {
          value = withoutImportant(value);
        }
        let transformed = transform(prop, value) ?? EMPTY_OBJECT;
        transformed = walkObject(
          transformed,
          (v) => isString$1(v) && important ? `${v} !important` : v,
          { getKey: (prop2) => conditions.expandAtRule(prop2) }
        );
        mergeByPath(result, selectors.flat(), transformed);
      });
      return sortAtRules(result);
    });
  }
  function mergeByPath(target, paths, value) {
    let acc = target;
    for (const path of paths) {
      if (!path) continue;
      if (!acc[path]) acc[path] = createEmptyObject();
      acc = acc[path];
    }
    mergeWith(acc, value);
  }
  function compactFn(...styles) {
    return styles.filter((style) => {
      if (!isObject$3(style)) return false;
      const compacted = compact$1(style);
      const keys = Object.keys(compacted);
      return keys.length > 0;
    });
  }
  function mergeCss(ctx) {
    function resolve(styles) {
      const comp = compactFn(...styles);
      if (comp.length === 1) return comp;
      return comp.map((style) => ctx.normalize(style));
    }
    return memo$1(function mergeFn(...styles) {
      return mergeWith({}, ...resolve(styles));
    });
  }
  const defaults = (conf) => ({
    base: EMPTY_OBJECT,
    variants: EMPTY_OBJECT,
    defaultVariants: EMPTY_OBJECT,
    compoundVariants: [],
    ...conf
  });
  function createRecipeFn(options) {
    const { css: css2, conditions, normalize: normalize2, layers } = options;
    function cva(config = {}) {
      const defaultsConfig = defaults(config);
      const { base, defaultVariants: defaultVariants2, compoundVariants } = defaultsConfig;
      const variants2 = mapEntries(defaultsConfig.variants, (key, obj) => [
        key,
        mapEntries(obj, (optionKey, styles) => [optionKey, normalize2(styles)])
      ]);
      const getVariantCss = createCssFn({
        conditions,
        normalize: normalize2,
        transform(prop, value) {
          return variants2[prop]?.[value];
        }
      });
      const resolve = (props = {}) => {
        const variantSelections = normalize2({
          ...defaultVariants2,
          ...compact$1(props)
        });
        let variantCss = { ...base };
        mergeWith(variantCss, getVariantCss(variantSelections));
        const compoundVariantCss = getCompoundVariantCss(
          compoundVariants,
          variantSelections
        );
        return layers.wrap("recipes", css2(variantCss, compoundVariantCss));
      };
      const variantKeys = Object.keys(variants2);
      const splitVariantProps = (props) => {
        const restProps = omit(props, ["recipe"]);
        const [recipeProps, localProps] = splitProps(restProps, variantKeys);
        const hasColorPalette = variantKeys.includes("colorPalette");
        const hasOrientation = variantKeys.includes("orientation");
        if (!hasColorPalette) {
          recipeProps.colorPalette = props.colorPalette || defaultVariants2.colorPalette;
        }
        if (hasOrientation) {
          localProps.orientation = props.orientation;
        }
        return [recipeProps, localProps];
      };
      const variantMap = mapEntries(variants2, (key, value) => [
        key,
        Object.keys(value)
      ]);
      const cvaFn = (props) => css2(resolve(props));
      return Object.assign(cvaFn, {
        className: config.className,
        __cva__: true,
        variantMap,
        variantKeys,
        raw: resolve,
        config,
        splitVariantProps,
        merge(other) {
          return cva(mergeCva(options)(this, other));
        }
      });
    }
    function getCompoundVariantCss(cvs, vm) {
      let result = EMPTY_OBJECT;
      cvs.forEach((cv) => {
        const isMatching = Object.entries(cv).every(([key, value]) => {
          if (key === "css") return true;
          const values = Array.isArray(value) ? value : [value];
          return values.some((value2) => vm[key] === value2);
        });
        if (isMatching) {
          result = css2(result, cv.css);
        }
      });
      return result;
    }
    return cva;
  }
  function mergeCva(opts) {
    const { css: css2 } = opts;
    return function mergeCva2(cvaA, cvaB) {
      const override = defaults(cvaB.config);
      const variantKeys = uniq$1(cvaA.variantKeys, Object.keys(cvaB.variants));
      const base = css2(cvaA.base, override.base);
      const variants2 = Object.fromEntries(
        variantKeys.map((key) => [
          key,
          css2(cvaA.config.variants[key], override.variants[key])
        ])
      );
      const defaultVariants2 = mergeWith(
        cvaA.config.defaultVariants,
        override.defaultVariants
      );
      const compoundVariants = [
        ...cvaA.compoundVariants,
        ...override.compoundVariants
      ];
      const className = cx(cvaA.className, cvaB.className);
      return {
        className,
        base,
        variants: variants2,
        defaultVariants: defaultVariants2,
        compoundVariants
      };
    };
  }
  const defaultLayers = {
    reset: "reset",
    base: "base",
    tokens: "tokens",
    recipes: "recipes"
  };
  const layerOrder = {
    reset: 0,
    base: 1,
    tokens: 2,
    recipes: 3
  };
  function createLayers(config) {
    const layers = config.layers ?? defaultLayers;
    const values = Object.values(layers);
    const names = values.sort((a, b2) => layerOrder[a] - layerOrder[b2]);
    return {
      names,
      atRule: `@layer ${names.join(", ")};`,
      wrap(layer, styles) {
        if (config.disableLayers) return styles;
        const params = layers[layer];
        return { [`@layer ${params}`]: styles };
      }
    };
  }
  function createNormalizeFn(context) {
    const { utility, normalize: normalize2 } = context;
    const { hasShorthand, resolveShorthand } = utility;
    return function(styles) {
      return walkObject(styles, normalize2, {
        stop: (value) => Array.isArray(value),
        getKey: hasShorthand ? resolveShorthand : void 0
      });
    };
  }
  function createPreflight(options) {
    const { preflight } = options;
    if (!preflight) return {};
    const { scope = "", level = "parent" } = isObject$3(preflight) ? preflight : {};
    let selector = "";
    if (scope && level === "parent") {
      selector = `${scope} `;
    } else if (scope && level === "element") {
      selector = `&${scope}`;
    }
    const scoped = {
      "*": {
        margin: "0px",
        padding: "0px",
        font: "inherit",
        wordWrap: "break-word",
        WebkitTapHighlightColor: "transparent"
      },
      "*, *::before, *::after, *::backdrop": {
        boxSizing: "border-box",
        borderWidth: "0px",
        borderStyle: "solid",
        borderColor: "var(--global-color-border, currentColor)"
      },
      hr: {
        height: "0px",
        color: "inherit",
        borderTopWidth: "1px"
      },
      body: {
        minHeight: "100dvh",
        position: "relative"
      },
      img: {
        borderStyle: "none"
      },
      "img, svg, video, canvas, audio, iframe, embed, object": {
        display: "block",
        verticalAlign: "middle"
      },
      iframe: { border: "none" },
      "img, video": { maxWidth: "100%", height: "auto" },
      "p, h1, h2, h3, h4, h5, h6": { overflowWrap: "break-word" },
      "ol, ul": { listStyle: "none" },
      "code, kbd, pre, samp": { fontSize: "1em" },
      "button, [type='button'], [type='reset'], [type='submit']": {
        WebkitAppearance: "button",
        backgroundColor: "transparent",
        backgroundImage: "none"
      },
      "button, input, optgroup, select, textarea": { color: "inherit" },
      "button, select": { textTransform: "none" },
      table: {
        textIndent: "0px",
        borderColor: "inherit",
        borderCollapse: "collapse"
      },
      "*::placeholder": {
        opacity: "unset",
        color: "#9ca3af",
        userSelect: "none"
      },
      textarea: {
        resize: "vertical"
      },
      summary: {
        display: "list-item"
      },
      small: {
        fontSize: "80%"
      },
      "sub, sup": {
        fontSize: "75%",
        lineHeight: 0,
        position: "relative",
        verticalAlign: "baseline"
      },
      sub: {
        bottom: "-0.25em"
      },
      sup: {
        top: "-0.5em"
      },
      dialog: {
        padding: "0px"
      },
      a: {
        color: "inherit",
        textDecoration: "inherit"
      },
      "abbr:where([title])": {
        textDecoration: "underline dotted"
      },
      "b, strong": {
        fontWeight: "bolder"
      },
      "code, kbd, samp, pre": {
        fontSize: "1em",
        "--font-mono-fallback": "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New'",
        fontFamily: "var(--global-font-mono, var(--font-mono-fallback))"
      },
      'input[type="text"], input[type="email"], input[type="search"], input[type="password"]': {
        WebkitAppearance: "none",
        MozAppearance: "none"
      },
      "input[type='search']": {
        WebkitAppearance: "textfield",
        outlineOffset: "-2px"
      },
      "::-webkit-search-decoration, ::-webkit-search-cancel-button": {
        WebkitAppearance: "none"
      },
      "::-webkit-file-upload-button": {
        WebkitAppearance: "button",
        font: "inherit"
      },
      'input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button': {
        height: "auto"
      },
      "input[type='number']": {
        MozAppearance: "textfield"
      },
      ":-moz-ui-invalid": {
        boxShadow: "none"
      },
      ":-moz-focusring": {
        outline: "auto"
      },
      "[hidden]:where(:not([hidden='until-found']))": {
        display: "none !important"
      }
    };
    const preflightCss = {
      [scope || "html"]: {
        lineHeight: 1.5,
        "--font-fallback": "ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'",
        WebkitTextSizeAdjust: "100%",
        WebkitFontSmoothing: "antialiased",
        MozOsxFontSmoothing: "grayscale",
        textRendering: "optimizeLegibility",
        touchAction: "manipulation",
        MozTabSize: "4",
        tabSize: "4",
        fontFamily: "var(--global-font-body, var(--font-fallback))"
      }
    };
    if (level === "element") {
      const modified = Object.entries(scoped).reduce((acc, [k, v]) => {
        acc[k] = { [selector]: v };
        return acc;
      }, {});
      Object.assign(preflightCss, modified);
    } else if (selector) {
      preflightCss[selector] = scoped;
    } else {
      Object.assign(preflightCss, scoped);
    }
    return preflightCss;
  }
  function createSerializeFn(options) {
    const { conditions, isValidProperty } = options;
    return function serialize2(styles) {
      return walkObject(styles, (value) => value, {
        getKey: (prop, value) => {
          if (!isObject$3(value)) return prop;
          if (!conditions.has(prop) && !isValidProperty(prop)) {
            return parseSelectors(prop).map((s) => {
              const selector = s.startsWith("&") ? s.slice(1) : s;
              return isTopLevelSelector(selector) ? `${selector} &` : `&${selector}`;
            }).join(", ");
          }
          return prop;
        }
      });
    };
  }
  function isTopLevelSelector(s) {
    const lower = s.toLowerCase();
    return lower.startsWith(":host-context") || lower.startsWith(":host") || lower.startsWith("::slotted");
  }
  function parseSelectors(selector) {
    const result = [];
    let parenCount = 0;
    let currentSelector = "";
    let inEscape = false;
    for (let i = 0; i < selector.length; i++) {
      const char2 = selector[i];
      if (char2 === "\\" && !inEscape) {
        inEscape = true;
        currentSelector += char2;
        continue;
      }
      if (inEscape) {
        inEscape = false;
        currentSelector += char2;
        continue;
      }
      if (char2 === "(") {
        parenCount++;
      } else if (char2 === ")") {
        parenCount--;
      }
      if (char2 === "," && parenCount === 0) {
        result.push(currentSelector.trim());
        currentSelector = "";
      } else {
        currentSelector += char2;
      }
    }
    if (currentSelector) {
      result.push(currentSelector.trim());
    }
    return result;
  }
  const getSlotRecipes = (config = EMPTY_OBJECT) => {
    const init = (slot) => ({
      base: config.base?.[slot] ?? EMPTY_OBJECT,
      variants: createEmptyObject(),
      defaultVariants: config.defaultVariants ?? EMPTY_OBJECT,
      compoundVariants: config.compoundVariants ? getSlotCompoundVariant(config.compoundVariants, slot) : EMPTY_ARRAY
    });
    const slots = config.slots ?? [];
    const entries = slots.map((slot) => [slot, init(slot)]);
    for (const [variantsKey, variantsSpec] of Object.entries(
      config.variants ?? {}
    )) {
      for (const [variantKey, variantSpec] of Object.entries(
        variantsSpec
      )) {
        entries.forEach(([slot, slotRecipe]) => {
          var _a;
          (_a = slotRecipe.variants)[variantsKey] ?? (_a[variantsKey] = {});
          slotRecipe.variants[variantsKey][variantKey] = variantSpec[slot] ?? EMPTY_OBJECT;
        });
      }
    }
    return Object.fromEntries(entries);
  };
  const getSlotCompoundVariant = (compoundVariants, slotName) => compoundVariants.filter((compoundVariant) => compoundVariant.css[slotName]).map((compoundVariant) => ({
    ...compoundVariant,
    css: compoundVariant.css[slotName]
  }));
  function createSlotRecipeFn(options) {
    const { cva } = options;
    return function sva(config = EMPTY_OBJECT) {
      const slots = Object.entries(getSlotRecipes(config)).map(
        ([slot, slotCva]) => [slot, cva(slotCva)]
      );
      function svaFn(props) {
        const result = slots.map(([slot, cvaFn]) => [slot, cvaFn(props)]);
        return Object.fromEntries(result);
      }
      const variants2 = config.variants ?? EMPTY_OBJECT;
      const variantKeys = Object.keys(variants2);
      function splitVariantProps(props) {
        const restProps = omit(props, ["recipe"]);
        const [recipeProps, localProps] = splitProps(restProps, variantKeys);
        const hasColorPalette = variantKeys.includes("colorPalette");
        const hasOrientation = variantKeys.includes("orientation");
        if (!hasColorPalette) {
          recipeProps.colorPalette = props.colorPalette || config.defaultVariants?.colorPalette;
        }
        if (hasOrientation) {
          localProps.orientation = props.orientation;
        }
        return [recipeProps, localProps];
      }
      const variantMap = mapEntries(variants2, (key, value) => [
        key,
        Object.keys(value)
      ]);
      let classNameMap = {};
      if (config.className) {
        classNameMap = Object.fromEntries(
          config.slots.map((slot) => [
            slot,
            `${config.className}__${slot}`
          ])
        );
      }
      return Object.assign(svaFn, {
        variantMap,
        variantKeys,
        splitVariantProps,
        classNameMap
      });
    };
  }
  const createProps = () => (props) => Array.from(new Set(props));
  const rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|^-|[^\x80-\uFFFF\w-]/g;
  const fcssescape = function(ch, asCodePoint) {
    if (!asCodePoint) return "\\" + ch;
    if (ch === "\0") return "";
    if (ch === "-" && ch.length === 1) return "\\-";
    return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16);
  };
  const esc = (sel) => {
    return (sel + "").replace(rcssescape, fcssescape);
  };
  const expandTokenReferences = (str, resolve) => {
    let expanded = "";
    let index = 0;
    let state2 = "char";
    let tokenPath = "";
    let fallback2 = "";
    const currentStates = [];
    while (index < str.length) {
      const char2 = str[index];
      if (char2 === "{") {
        const endIndex = str.indexOf("}", index);
        if (endIndex === -1) {
          break;
        }
        const path = str.slice(index + 1, endIndex);
        const resolved = resolve(path);
        expanded += resolved ?? path;
        index = endIndex + 1;
        continue;
      }
      if (state2 === "token") {
        if (char2 === ",") {
          if (str[index] === "") {
            index++;
          }
          state2 = "fallback";
          currentStates.push(state2);
          const resolved = resolve(tokenPath);
          if (resolved?.endsWith(")")) {
            expanded += resolved.slice(0, -1);
          }
          tokenPath = "";
          fallback2 = "";
          continue;
        }
      }
      if (state2 === "fallback") {
        const nextFallback = fallback2 + char2;
        if (nextFallback === ", var(") {
          const innerEndIndex = cssVarParser(str.slice(index + 1));
          const endIndex = innerEndIndex + index + 1;
          const cssVar2 = str.slice(index + 1, endIndex);
          if (endIndex === -1) {
            break;
          }
          expanded += ", var(" + cssVar2 + ")";
          index = endIndex + 1;
          state2 = currentStates.pop() ?? state2;
          fallback2 = "";
          continue;
        }
      }
      if (state2 === "token" || state2 === "fallback") {
        index++;
        if (char2 === ")") {
          state2 = currentStates.pop() ?? state2 ?? "char";
          fallback2 += char2;
          const resolved = tokenPath ? resolve(tokenPath) ?? esc(tokenPath) : tokenPath;
          if (fallback2) {
            fallback2 = fallback2.slice(1).trim();
            if (!fallback2.startsWith("token(") && fallback2.endsWith(")")) {
              fallback2 = fallback2.slice(0, -1);
            }
            if (fallback2.includes("token(")) {
              const parsed = expandTokenReferences(fallback2, resolve);
              if (parsed) {
                fallback2 = parsed.slice(0, -1);
              }
            } else if (fallback2) {
              const resolvedFallback = resolve(fallback2);
              if (resolvedFallback) {
                fallback2 = resolvedFallback;
              }
            }
          }
          const lastChar = expanded.at(-1);
          if (fallback2) {
            if (lastChar?.trim()) {
              expanded += resolved.slice(0, -1) + (", " + fallback2 + ")");
            } else {
              expanded += fallback2;
            }
          } else {
            expanded += resolved || ")";
          }
          tokenPath = "";
          fallback2 = "";
          state2 = "char";
          continue;
        }
        if (state2 === "token") {
          tokenPath += char2;
        }
        if (state2 === "fallback") {
          fallback2 += char2;
        }
        continue;
      }
      const tokenIndex = str.indexOf("token(", index);
      if (tokenIndex !== -1) {
        const innerTokenIndex = tokenIndex + "token(".length;
        expanded += str.slice(index, tokenIndex);
        index = innerTokenIndex;
        state2 = "token";
        currentStates.push(state2);
        continue;
      }
      expanded += char2;
      index++;
    }
    return expanded;
  };
  const cssVarParser = (str) => {
    let index = 0;
    const openedParenthesises = ["("];
    while (index < str.length) {
      const char2 = str[index];
      if (char2 === "(") {
        openedParenthesises.push(char2);
      } else if (char2 === ")") {
        openedParenthesises.pop();
        if (openedParenthesises.length === 0) {
          return index;
        }
      }
      index++;
    }
    return index;
  };
  function mapToJson(map2) {
    const obj = {};
    map2.forEach((value, key) => {
      if (value instanceof Map) {
        obj[key] = Object.fromEntries(value);
      } else {
        obj[key] = value;
      }
    });
    return obj;
  }
  const REFERENCE_REGEX = /({([^}]*)})/g;
  const CURLY_REGEX = /[{}]/g;
  const TOKEN_PATH_REGEX = /\w+\.\w+/;
  const getReferences = (value) => {
    if (!isString$1(value)) return [];
    const matches = value.match(REFERENCE_REGEX);
    if (!matches) return [];
    return matches.map((match2) => match2.replace(CURLY_REGEX, "").trim());
  };
  const hasReference = (value) => REFERENCE_REGEX.test(value);
  function expandReferences(token2) {
    if (!token2.extensions?.references) {
      return token2.extensions?.cssVar?.ref ?? token2.value;
    }
    const references = token2.extensions.references ?? {};
    let valueStr = token2.value;
    const keys = Object.keys(references);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const referenceToken = references[key];
      if (referenceToken.extensions.conditions) {
        continue;
      }
      const value = expandReferences(referenceToken);
      valueStr = valueStr.replace(`{${key}}`, value);
    }
    token2.value = valueStr;
    delete token2.extensions.references;
    return token2.value;
  }
  const CALC_REGEX = /calc/g;
  function resolveReference(operand) {
    if (isObject$3(operand) && operand.reference) {
      return operand.reference;
    }
    return String(operand);
  }
  const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(CALC_REGEX, "");
  const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
  const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
  const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
  const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
  const negate = (x2) => {
    const value = resolveReference(x2);
    if (value != null && !Number.isNaN(parseFloat(value))) {
      return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
    }
    return multiply(value, -1);
  };
  const calc = Object.assign(
    (x2) => ({
      add: (...operands) => calc(add(x2, ...operands)),
      subtract: (...operands) => calc(subtract(x2, ...operands)),
      multiply: (...operands) => calc(multiply(x2, ...operands)),
      divide: (...operands) => calc(divide(x2, ...operands)),
      negate: () => calc(negate(x2)),
      toString: () => x2.toString()
    }),
    {
      add,
      subtract,
      multiply,
      divide,
      negate
    }
  );
  const addNegativeTokens = {
    enforce: "pre",
    transform(dictionary) {
      const { prefix: prefix2, allTokens, formatCssVar, formatTokenName, registerToken } = dictionary;
      const tokens2 = allTokens.filter(
        ({ extensions }) => extensions.category === "spacing"
      );
      tokens2.forEach((token2) => {
        const originalPath = token2.path.slice();
        const originalVar = formatCssVar(originalPath, prefix2);
        if (isString$1(token2.value) && token2.value === "0rem") {
          return;
        }
        const newPath = [...token2.path];
        const lastPath = newPath[newPath.length - 1];
        if (lastPath != null) {
          newPath[newPath.length - 1] = `-${lastPath}`;
        }
        const nextToken = {
          ...token2,
          value: calc.negate(originalVar.ref),
          name: formatTokenName(newPath),
          path: newPath,
          extensions: {
            ...token2.extensions,
            negative: true,
            prop: `-${token2.extensions.prop}`,
            originalPath
          }
        };
        registerToken(nextToken);
      });
    }
  };
  const units = new Set([
    "spacing",
    "sizes",
    "borderWidths",
    "fontSizes",
    "radii"
  ]);
  const addPixelUnit = {
    enforce: "post",
    transform(dictionary) {
      const tokens2 = dictionary.allTokens.filter((token2) => {
        return units.has(token2.extensions.category) && !token2.extensions.negative;
      });
      tokens2.forEach((token2) => {
        Object.assign(token2.extensions, {
          pixelValue: toPx(token2.value)
        });
      });
    }
  };
  const addVirtualPalette = {
    enforce: "post",
    transform(dictionary) {
      const { allTokens, registerToken, formatTokenName } = dictionary;
      const tokens2 = allTokens.filter(
        ({ extensions }) => extensions.category === "colors"
      );
      const keys = new Map();
      const colorPalettes = new Map();
      tokens2.forEach((token2) => {
        const { colorPalette } = token2.extensions;
        if (!colorPalette) return;
        colorPalette.keys.forEach((keyPath) => {
          keys.set(formatTokenName(keyPath), keyPath);
        });
        colorPalette.roots.forEach((colorPaletteRoot) => {
          const name = formatTokenName(colorPaletteRoot);
          const colorPaletteList = colorPalettes.get(name) || [];
          colorPaletteList.push(token2);
          colorPalettes.set(name, colorPaletteList);
          if (token2.extensions.default && colorPaletteRoot.length === 1) {
            const keyPath = colorPalette.keys[0]?.filter(Boolean);
            if (!keyPath.length) return;
            const path = colorPaletteRoot.concat(keyPath);
            keys.set(formatTokenName(path), []);
          }
        });
      });
      keys.forEach((segments) => {
        const path = ["colors", "colorPalette", ...segments].filter(Boolean);
        const name = formatTokenName(path);
        const prop = formatTokenName(path.slice(1));
        const token2 = {
          name,
          value: name,
          originalValue: name,
          path,
          extensions: {
            condition: "base",
            originalPath: path,
            category: "colors",
            prop,
            virtual: true
          }
        };
        registerToken(token2, "pre");
      });
    }
  };
  const removeEmptyTokens = {
    enforce: "post",
    transform(dictionary) {
      dictionary.allTokens = dictionary.allTokens.filter(
        (token2) => token2.value !== ""
      );
    }
  };
  const tokenMiddlewares = [
    addNegativeTokens,
    addVirtualPalette,
    addPixelUnit,
    removeEmptyTokens
  ];
  const addCssVariables = {
    type: "extensions",
    enforce: "pre",
    name: "tokens/css-var",
    transform(token2, dictionary) {
      const { prefix: prefix2, formatCssVar } = dictionary;
      const { negative, originalPath } = token2.extensions;
      const path = negative ? originalPath : token2.path;
      return {
        cssVar: formatCssVar(path.filter(Boolean), prefix2)
      };
    }
  };
  const addConditionalCssVariables = {
    enforce: "post",
    type: "value",
    name: "tokens/conditionals",
    transform(token2, dictionary) {
      const { prefix: prefix2, formatCssVar } = dictionary;
      const refs = getReferences(token2.value);
      if (!refs.length) return token2.value;
      refs.forEach((ref) => {
        const variable = formatCssVar(ref.split("."), prefix2);
        token2.value = token2.value.replace(`{${variable.ref}}`, variable);
      });
      return token2.value;
    }
  };
  const addColorPalette = {
    type: "extensions",
    enforce: "pre",
    name: "tokens/colors/colorPalette",
    match(token2) {
      return token2.extensions.category === "colors" && !token2.extensions.virtual;
    },
    transform(token2, dict) {
      let path = token2.path.slice();
      path.pop();
      path.shift();
      if (path.length === 0) {
        const newPath = [...token2.path];
        newPath.shift();
        path = newPath;
      }
      if (path.length === 0) {
        return {};
      }
      const roots = path.reduce((acc, _2, i, arr) => {
        const next2 = arr.slice(0, i + 1);
        acc.push(next2);
        return acc;
      }, []);
      const root2 = path[0];
      const value = dict.formatTokenName(path);
      const keys = token2.path.slice(token2.path.indexOf(root2) + 1).reduce((acc, _2, i, arr) => {
        acc.push(arr.slice(i));
        return acc;
      }, []);
      if (keys.length === 0) {
        keys.push([""]);
      }
      return {
        colorPalette: { value, roots, keys }
      };
    }
  };
  const tokenTransforms = [
    addCssVariables,
    addConditionalCssVariables,
    addColorPalette
  ];
  const isToken = (value) => {
    return isObject$3(value) && Object.prototype.hasOwnProperty.call(value, "value");
  };
  function expandBreakpoints(breakpoints2) {
    if (!breakpoints2) return { breakpoints: {}, sizes: {} };
    return {
      breakpoints: mapObject(breakpoints2, (value) => ({ value })),
      sizes: mapEntries(breakpoints2, (key, value) => [
        `breakpoint-${key}`,
        { value }
      ])
    };
  }
  function createTokenDictionary(options) {
    const {
      prefix: prefix2 = "",
      tokens: tokens2 = {},
      semanticTokens: semanticTokens2 = {},
      breakpoints: breakpoints2 = {}
    } = options;
    const formatTokenName = (path) => path.join(".");
    const formatCssVar = (path, prefix22) => cssVar(path.join("-"), { prefix: prefix22 });
    const allTokens = [];
    const tokenNameMap = new Map();
    const conditionMap = new Map();
    const cssVarMap = new Map();
    const colorPaletteMap = new Map();
    const flatMap2 = new Map();
    const byCategory = new Map();
    const categoryMap = new Map();
    const transforms = new Map();
    const middlewares = [];
    function registerToken(token2, phase) {
      allTokens.push(token2);
      tokenNameMap.set(token2.name, token2);
      if (phase) {
        transforms.forEach((fn) => {
          if (fn.enforce === phase) transformToken(fn, token2);
        });
      }
    }
    const breakpointTokens = expandBreakpoints(breakpoints2);
    const computedTokens = compact$1({
      ...tokens2,
      breakpoints: breakpointTokens.breakpoints,
      sizes: {
        ...tokens2.sizes,
        ...breakpointTokens.sizes
      }
    });
    function registerTokens() {
      walkObject(
        computedTokens,
        (entry, path) => {
          const isDefault = path.includes("DEFAULT");
          path = filterDefault(path);
          const category = path[0];
          const name = formatTokenName(path);
          const t = isString$1(entry) ? { value: entry } : entry;
          const token2 = {
            value: t.value,
            originalValue: t.value,
            name,
            path,
            extensions: {
              condition: "base",
              originalPath: path,
              category,
              prop: formatTokenName(path.slice(1))
            }
          };
          if (isDefault) {
            token2.extensions.default = true;
          }
          registerToken(token2);
        },
        { stop: isToken }
      );
      walkObject(
        semanticTokens2,
        (entry, path) => {
          const isDefault = path.includes("DEFAULT");
          path = filterBaseCondition(filterDefault(path));
          const category = path[0];
          const name = formatTokenName(path);
          const t = isString$1(entry.value) ? { value: { base: entry.value } } : entry;
          const token2 = {
            value: t.value.base || "",
            originalValue: t.value.base || "",
            name,
            path,
            extensions: {
              originalPath: path,
              category,
              conditions: t.value,
              condition: "base",
              prop: formatTokenName(path.slice(1))
            }
          };
          if (isDefault) {
            token2.extensions.default = true;
          }
          registerToken(token2);
        },
        { stop: isToken }
      );
    }
    function getByName(name) {
      return tokenNameMap.get(name);
    }
    function buildConditionMap(token2) {
      const { condition } = token2.extensions;
      if (!condition) return;
      if (!conditionMap.has(condition)) {
        conditionMap.set(condition, new Set());
      }
      conditionMap.get(condition).add(token2);
    }
    function buildCategoryMap(token2) {
      const { category, prop } = token2.extensions;
      if (!category) return;
      if (!categoryMap.has(category)) {
        categoryMap.set(category, new Map());
      }
      categoryMap.get(category).set(prop, token2);
    }
    function buildCssVars(token2) {
      const { condition, negative, virtual, cssVar: cssVar2 } = token2.extensions;
      if (negative || virtual || !condition || !cssVar2) return;
      if (!cssVarMap.has(condition)) {
        cssVarMap.set(condition, new Map());
      }
      cssVarMap.get(condition).set(cssVar2.var, token2.value);
    }
    function buildFlatMap(token2) {
      const { category, prop, cssVar: cssVar2, negative } = token2.extensions;
      if (!category) return;
      if (!byCategory.has(category)) {
        byCategory.set(category, new Map());
      }
      const value = negative ? token2.extensions.conditions ? token2.originalValue : token2.value : cssVar2.ref;
      byCategory.get(category).set(prop, value);
      flatMap2.set([category, prop].join("."), value);
    }
    function buildColorPalette(token2) {
      const { colorPalette, virtual, default: isDefault } = token2.extensions;
      if (!colorPalette || virtual) return;
      colorPalette.roots.forEach((root2) => {
        const name = formatTokenName(root2);
        if (!colorPaletteMap.has(name)) {
          colorPaletteMap.set(name, new Map());
        }
        const virtualPath = replaceRootWithColorPalette(
          [...token2.path],
          [...root2]
        );
        const virtualName = formatTokenName(virtualPath);
        const virtualToken = getByName(virtualName);
        if (!virtualToken || !virtualToken.extensions.cssVar) return;
        const { var: virtualVar } = virtualToken.extensions.cssVar;
        colorPaletteMap.get(name).set(virtualVar, token2.extensions.cssVar.ref);
        if (isDefault && root2.length === 1) {
          const colorPaletteName = formatTokenName(["colors", "colorPalette"]);
          const colorPaletteToken = getByName(colorPaletteName);
          if (!colorPaletteToken) return;
          const name2 = formatTokenName(token2.path);
          const virtualToken2 = getByName(name2);
          if (!virtualToken2) return;
          const keyPath = colorPalette.keys[0]?.filter(Boolean);
          if (!keyPath.length) return;
          const computedName = formatTokenName(root2.concat(keyPath));
          if (!colorPaletteMap.has(computedName)) {
            colorPaletteMap.set(computedName, new Map());
          }
          colorPaletteMap.get(computedName).set(
            colorPaletteToken.extensions.cssVar.var,
            virtualToken2.extensions.cssVar.ref
          );
        }
      });
    }
    let byCategoryJson = {};
    function setupViews() {
      allTokens.forEach((token2) => {
        buildConditionMap(token2);
        buildCategoryMap(token2);
        buildCssVars(token2);
        buildFlatMap(token2);
        buildColorPalette(token2);
      });
      byCategoryJson = mapToJson(byCategory);
    }
    const colorMix2 = (value, tokenFn) => {
      if (!value || typeof value !== "string") return { invalid: true, value };
      const [colorPath, rawOpacity] = value.split("/");
      if (!colorPath || !rawOpacity) {
        return { invalid: true, value: colorPath };
      }
      const colorToken = tokenFn(colorPath);
      const opacityToken = getByName(`opacity.${rawOpacity}`)?.value;
      if (!opacityToken && isNaN(Number(rawOpacity))) {
        return { invalid: true, value: colorPath };
      }
      const percent2 = opacityToken ? Number(opacityToken) * 100 + "%" : `${rawOpacity}%`;
      const color2 = colorToken ?? colorPath;
      return {
        invalid: false,
        color: color2,
        value: `color-mix(in srgb, ${color2} ${percent2}, transparent)`
      };
    };
    const getVar = memo$1((value, fallback2) => {
      return flatMap2.get(value) ?? fallback2;
    });
    const getCategoryValues = memo$1((category) => {
      return byCategoryJson[category] || null;
    });
    const expandReferenceInValue = memo$1((value) => {
      return expandTokenReferences(value, (path) => {
        if (!path) return;
        if (path.includes("/")) {
          const mix2 = colorMix2(path, (v) => getVar(v));
          if (mix2.invalid) {
            throw new Error("Invalid color mix at " + path + ": " + mix2.value);
          }
          return mix2.value;
        }
        const resolved = getVar(path);
        if (resolved) return resolved;
        return TOKEN_PATH_REGEX.test(path) ? esc(path) : path;
      });
    });
    const dictionary = {
      prefix: prefix2,
      allTokens,
      tokenMap: tokenNameMap,
      registerToken,
      getByName,
      formatTokenName,
      formatCssVar,
      flatMap: flatMap2,
      cssVarMap,
      categoryMap,
      colorPaletteMap,
      getVar,
      getCategoryValues,
      expandReferenceInValue
    };
    function registerTransform(...fns) {
      fns.forEach((fn) => {
        transforms.set(fn.name, fn);
      });
    }
    function registerMiddleware(...fns) {
      middlewares.push(...fns);
    }
    function transformToken(transform, token2) {
      if (token2.extensions.references) return;
      if (isFunction$1(transform.match) && !transform.match(token2)) return;
      const fn = (v) => transform.transform(v, dictionary);
      const transformed = fn(token2);
      switch (true) {
        case transform.type === "extensions":
          Object.assign(token2.extensions, transformed);
          break;
        case transform.type === "value":
          token2.value = transformed;
          break;
        default:
          token2[transform.type] = transformed;
          break;
      }
    }
    function applyMiddlewares(enforce) {
      middlewares.forEach((middleware2) => {
        if (middleware2.enforce === enforce) {
          middleware2.transform(dictionary);
        }
      });
    }
    function applyTransforms(enforce) {
      transforms.forEach((transform) => {
        if (transform.enforce === enforce) {
          allTokens.forEach((token2) => {
            transformToken(transform, token2);
          });
        }
      });
    }
    function addConditionalTokens() {
      allTokens.forEach((token2) => {
        const tokens22 = getConditionalTokens(token2);
        if (!tokens22 || tokens22.length === 0) return;
        tokens22.forEach((token22) => {
          registerToken(token22);
        });
      });
    }
    function getTokenReferences(value) {
      const refs = getReferences(value);
      const result = [];
      for (let i = 0; i < refs.length; i++) {
        const token2 = getByName(refs[i]);
        if (token2) {
          result.push(token2);
        }
      }
      return result;
    }
    function addReferences() {
      allTokens.forEach((token2) => {
        if (!hasReference(token2.value)) return;
        const references = getTokenReferences(token2.value);
        token2.extensions.references = references.reduce((acc, ref) => {
          acc[ref.name] = ref;
          return acc;
        }, {});
      });
    }
    function expandTokenReferences$1() {
      allTokens.forEach((token2) => {
        expandReferences(token2);
      });
    }
    function build2() {
      applyMiddlewares("pre");
      applyTransforms("pre");
      addConditionalTokens();
      addReferences();
      expandTokenReferences$1();
      applyMiddlewares("post");
      applyTransforms("post");
      setupViews();
    }
    registerTokens();
    registerTransform(...tokenTransforms);
    registerMiddleware(...tokenMiddlewares);
    build2();
    return dictionary;
  }
  function filterDefault(path) {
    if (path[0] === "DEFAULT") return path;
    return path.filter((item) => item !== "DEFAULT");
  }
  function filterBaseCondition(path) {
    return path.filter((item) => item !== "base");
  }
  function getConditionalTokens(token2) {
    if (!token2.extensions.conditions) return;
    const { conditions } = token2.extensions;
    const tokens2 = [];
    walkObject(conditions, (value, path) => {
      const nextPath = filterBaseCondition(path);
      if (!nextPath.length) return;
      const nextToken = {
        ...token2,
        value,
        extensions: {
          ...token2.extensions,
          condition: nextPath.join(":")
        }
      };
      tokens2.push(nextToken);
    });
    return tokens2;
  }
  function replaceRootWithColorPalette(path, roots) {
    const startIndex = path.findIndex(
      (_2, index) => roots.every(
        (rootElement, rootIndex) => path[index + rootIndex] === rootElement
      )
    );
    if (startIndex === -1) {
      return path;
    }
    path.splice(startIndex, roots.length);
    path.splice(startIndex, 0, "colorPalette");
    return path;
  }
  createProps()([
    "aspectRatios",
    "zIndex",
    "opacity",
    "colors",
    "fonts",
    "fontSizes",
    "fontWeights",
    "lineHeights",
    "letterSpacings",
    "sizes",
    "shadows",
    "spacing",
    "radii",
    "cursor",
    "borders",
    "borderWidths",
    "borderStyles",
    "durations",
    "easings",
    "animations",
    "blurs",
    "gradients",
    "breakpoints",
    "assets"
  ]);
  function normalize(config) {
    return config;
  }
  function normalizeConfig(config) {
    return mapEntries(config, (property, propertyConfig) => [
      property,
      normalize(propertyConfig)
    ]);
  }
  function createUtility(options) {
    const configs = normalizeConfig(options.config);
    const tokens2 = options.tokens;
    const shorthands = new Map();
    const propValues = new Map();
    function register(property, config) {
      configs[property] = normalize(config);
      assignProperty(property, config);
    }
    const assignProperty = (property, config) => {
      const values = getPropertyValues(config);
      if (!values) return;
      propValues.set(property, values);
      assignPropertyType(property, config);
    };
    const assignProperties = () => {
      for (const [prop, config] of Object.entries(configs)) {
        if (!config) continue;
        assignProperty(prop, config);
      }
    };
    const assignShorthands = () => {
      for (const [property, config] of Object.entries(configs)) {
        const { shorthand } = config ?? {};
        if (!shorthand) continue;
        const values = Array.isArray(shorthand) ? shorthand : [shorthand];
        values.forEach((name) => shorthands.set(name, property));
      }
    };
    const assignColorPaletteProperty = () => {
      const values = mapToJson(tokens2.colorPaletteMap);
      register("colorPalette", {
        values: Object.keys(values),
        transform: memo$1((value) => values[value])
      });
    };
    const propTypes = new Map();
    const assignPropertyType = (property, config) => {
      if (!config) return;
      const values = getPropertyValues(config, (key) => `type:Tokens["${key}"]`);
      if (typeof values === "object" && values.type) {
        propTypes.set(property, new Set([`type:${values.type}`]));
        return;
      }
      if (values) {
        const keys2 = new Set(Object.keys(values));
        propTypes.set(property, keys2);
      }
      const set = propTypes.get(property) ?? new Set();
      if (config.property) {
        propTypes.set(property, set.add(`CssProperties["${config.property}"]`));
      }
    };
    const assignPropertyTypes = () => {
      for (const [property, propertyConfig] of Object.entries(configs)) {
        if (!propertyConfig) continue;
        assignPropertyType(property, propertyConfig);
      }
    };
    const addPropertyType = (property, type) => {
      const set = propTypes.get(property) ?? new Set();
      propTypes.set(property, new Set([...set, ...type]));
    };
    const getTypes = () => {
      const map2 = new Map();
      for (const [prop, values] of propTypes.entries()) {
        if (values.size === 0) {
          map2.set(prop, ["string"]);
          continue;
        }
        const typeValues = Array.from(values).map((key) => {
          if (key.startsWith("CssProperties")) return key;
          if (key.startsWith("type:")) return key.replace("type:", "");
          return JSON.stringify(key);
        });
        map2.set(prop, typeValues);
      }
      return map2;
    };
    const getPropertyValues = (config, resolveFn) => {
      const { values } = config;
      const fn = (key) => {
        const value = resolveFn?.(key);
        return value ? { [value]: value } : void 0;
      };
      if (isString$1(values)) {
        return fn?.(values) ?? tokens2.getCategoryValues(values) ?? EMPTY_OBJECT;
      }
      if (Array.isArray(values)) {
        const result = {};
        for (let i = 0; i < values.length; i++) {
          result[values[i]] = values[i];
        }
        return result;
      }
      if (isFunction$1(values)) {
        return values(resolveFn ? fn : tokens2.getCategoryValues);
      }
      return values;
    };
    const defaultTransform = memo$1((prop, value) => {
      return {
        [prop]: prop.startsWith("--") ? tokens2.getVar(value, value) : value
      };
    });
    const tokenFn = Object.assign(tokens2.getVar, {
      raw: (path) => tokens2.getByName(path)
    });
    const transform = memo$1((prop, raw) => {
      const key = resolveShorthand(prop);
      if (isString$1(raw) && !raw.includes("_EMO_")) {
        raw = tokens2.expandReferenceInValue(raw);
      }
      const config = configs[key];
      if (!config) {
        return defaultTransform(key, raw);
      }
      const value = propValues.get(key)?.[raw];
      if (!config.transform) {
        return defaultTransform(prop, value ?? raw);
      }
      const _colorMix = (value2) => colorMix(value2, tokenFn);
      return config.transform(value ?? raw, {
        raw,
        token: tokenFn,
        utils: { colorMix: _colorMix }
      });
    });
    function build2() {
      assignShorthands();
      assignColorPaletteProperty();
      assignProperties();
      assignPropertyTypes();
    }
    build2();
    const hasShorthand = shorthands.size > 0;
    const resolveShorthand = memo$1((prop) => {
      return shorthands.get(prop) ?? prop;
    });
    const keys = () => {
      return [...Array.from(shorthands.keys()), ...Object.keys(configs)];
    };
    const instance = {
      keys,
      hasShorthand,
      transform,
      shorthands,
      resolveShorthand,
      register,
      getTypes,
      addPropertyType
    };
    return instance;
  }
  function createSystem(...configs) {
    const config = mergeConfigs(...configs);
    const {
      theme = {},
      utilities = {},
      globalCss: globalCss2 = {},
      cssVarsRoot: cssVarsRoot2 = ":where(:root, :host)",
      cssVarsPrefix: cssVarsPrefix2 = "chakra",
      preflight
    } = config;
    const layers = createLayers(config);
    const tokens2 = createTokenDictionary({
      breakpoints: theme.breakpoints,
      tokens: theme.tokens,
      semanticTokens: theme.semanticTokens,
      prefix: cssVarsPrefix2
    });
    const breakpoints2 = createBreakpoints(theme.breakpoints ?? EMPTY_OBJECT);
    const conditions = createConditions({
      conditions: config.conditions ?? EMPTY_OBJECT,
      breakpoints: breakpoints2
    });
    const utility = createUtility({
      config: utilities,
      tokens: tokens2
    });
    function assignComposition() {
      const { textStyles: textStyles2, layerStyles: layerStyles2, animationStyles: animationStyles2 } = theme;
      const compositions = compact$1({
        textStyle: textStyles2,
        layerStyle: layerStyles2,
        animationStyle: animationStyles2
      });
      for (const [key, values] of Object.entries(compositions)) {
        const flatValues = flatten(values ?? EMPTY_OBJECT, stop);
        utility.register(key, {
          values: Object.keys(flatValues),
          transform(value) {
            return css2(flatValues[value]);
          }
        });
      }
    }
    assignComposition();
    utility.addPropertyType(
      "animationName",
      Object.keys(theme.keyframes ?? EMPTY_OBJECT)
    );
    const properties2 = new Set(["css", ...utility.keys(), ...conditions.keys()]);
    const isValidProperty = memo$1(
      (prop) => properties2.has(prop) || isCssProperty(prop)
    );
    const normalizeValue = (value) => {
      if (Array.isArray(value)) {
        const result = createEmptyObject();
        for (let index = 0; index < value.length; index++) {
          const current = value[index];
          if (current != null) {
            const key = conditions.breakpoints[index];
            result[key] = current;
          }
        }
        return result;
      }
      return value;
    };
    const normalizeFn = createNormalizeFn({
      utility,
      normalize: normalizeValue
    });
    const serialize2 = createSerializeFn({
      conditions,
      isValidProperty
    });
    const css2 = createCssFn({
      transform: utility.transform,
      conditions,
      normalize: normalizeFn
    });
    const cva = createRecipeFn({
      css: css2,
      conditions,
      normalize: normalizeFn,
      layers
    });
    const sva = createSlotRecipeFn({ cva });
    function getTokenCss() {
      const result = {};
      for (const [key, values] of tokens2.cssVarMap.entries()) {
        const varsObj = Object.fromEntries(values);
        if (Object.keys(varsObj).length === 0) continue;
        const selector = key === "base" ? cssVarsRoot2 : conditions.resolve(key);
        const isAtRule = selector.startsWith("@");
        const cssObject = css2(
          serialize2({
            [selector]: isAtRule ? { [cssVarsRoot2]: varsObj } : varsObj
          })
        );
        mergeWith(result, cssObject);
      }
      return layers.wrap("tokens", result);
    }
    function getGlobalCss() {
      const keyframes2 = mapEntries(
        theme.keyframes ?? EMPTY_OBJECT,
        (key, value) => [`@keyframes ${key}`, value]
      );
      const result = Object.assign({}, keyframes2, css2(serialize2(globalCss2)));
      return layers.wrap("base", result);
    }
    function splitCssProps(props) {
      return splitProps(props, isValidProperty);
    }
    function getPreflightCss() {
      const result = createPreflight({ preflight });
      return layers.wrap("reset", result);
    }
    const tokenMap = getTokenMap(tokens2);
    const tokenFn = (path, fallback2) => {
      return tokenMap.get(path)?.value || fallback2;
    };
    tokenFn.var = (path, fallback2) => {
      return tokenMap.get(path)?.variable || fallback2;
    };
    function getRecipe(key, fallback2) {
      return theme.recipes?.[key] ?? fallback2;
    }
    function getSlotRecipe(key, fallback2) {
      return theme.slotRecipes?.[key] ?? fallback2;
    }
    function isRecipe(key) {
      return Object.hasOwnProperty.call(theme.recipes ?? EMPTY_OBJECT, key);
    }
    function isSlotRecipe(key) {
      return Object.hasOwnProperty.call(theme.slotRecipes ?? EMPTY_OBJECT, key);
    }
    function hasRecipe(key) {
      return isRecipe(key) || isSlotRecipe(key);
    }
    const _global = [getPreflightCss(), getGlobalCss(), getTokenCss()];
    const query2 = {
      layerStyles: compositionQuery(theme.layerStyles ?? EMPTY_OBJECT),
      textStyles: compositionQuery(theme.textStyles ?? EMPTY_OBJECT),
      animationStyles: compositionQuery(theme.animationStyles ?? EMPTY_OBJECT),
      tokens: semanticTokenQuery(
        tokens2,
        Object.keys(theme.tokens ?? EMPTY_OBJECT),
        (value, key) => !value.extensions.conditions && !key.includes("colorPalette")
      ),
      semanticTokens: semanticTokenQuery(
        tokens2,
        Object.keys(theme.semanticTokens ?? EMPTY_OBJECT),
        (value) => !!value.extensions.conditions
      ),
      keyframes: basicQuery(theme.keyframes ?? EMPTY_OBJECT),
      breakpoints: basicQuery(theme.breakpoints ?? EMPTY_OBJECT)
    };
    return {
      $$chakra: true,
      _config: config,
      _global,
      breakpoints: breakpoints2,
      tokens: tokens2,
      conditions,
      utility,
      token: tokenFn,
      properties: properties2,
      layers,
      isValidProperty,
      splitCssProps,
      normalizeValue,
      getTokenCss,
      getGlobalCss,
      getPreflightCss,
      css: css2,
      cva,
      sva,
      getRecipe,
      getSlotRecipe,
      hasRecipe,
      isRecipe,
      isSlotRecipe,
      query: query2
    };
  }
  function getTokenMap(tokens2) {
    const map2 = new Map();
    tokens2.allTokens.forEach((token2) => {
      const { cssVar: cssVar2, virtual, conditions } = token2.extensions;
      const value = !!conditions || virtual ? cssVar2.ref : token2.value;
      map2.set(token2.name, { value, variable: cssVar2.ref });
    });
    return map2;
  }
  const stop = (v) => isObject$3(v) && "value" in v;
  const compositionQuery = (dict) => ({
    list() {
      return Object.keys(flatten(dict, stop));
    },
    search(query2) {
      return this.list().filter((style) => style.includes(query2));
    }
  });
  const semanticTokenQuery = (tokens2, categoryKeys, predicate) => ({
    categoryKeys,
    list(category) {
      const map2 = tokens2.categoryMap.get(category);
      const entries = map2 ? [...map2.entries()] : [];
      const result = [];
      for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        if (predicate(value, key)) {
          result.push(key);
        }
      }
      return result;
    },
    search(category, query2) {
      return this.list(category).filter((style) => style.includes(query2));
    }
  });
  const basicQuery = (dict) => ({
    list() {
      return Object.keys(dict);
    },
    search(query2) {
      return this.list().filter((style) => style.includes(query2));
    }
  });
  const breakpoints = {
    sm: "480px",
    md: "768px",
    lg: "1024px",
    xl: "1280px",
    "2xl": "1536px"
  };
  const empty = "var(--chakra-empty,/*!*/ /*!*/)";
  const globalCss = defineGlobalStyles({
    "*": {
      fontFeatureSettings: '"cv11"',
      "--ring-inset": empty,
      "--ring-offset-width": "0px",
      "--ring-offset-color": "#fff",
      "--ring-color": "rgba(66, 153, 225, 0.6)",
      "--ring-offset-shadow": "0 0 #0000",
      "--ring-shadow": "0 0 #0000",
      ...Object.fromEntries(
        [
          "brightness",
          "contrast",
          "grayscale",
          "hue-rotate",
          "invert",
          "saturate",
          "sepia",
          "drop-shadow"
        ].map((prop) => [`--${prop}`, empty])
      ),
      ...Object.fromEntries(
        [
          "blur",
          "brightness",
          "contrast",
          "grayscale",
          "hue-rotate",
          "invert",
          "opacity",
          "saturate",
          "sepia"
        ].map((prop) => [`--backdrop-${prop}`, empty])
      ),
      "--global-font-mono": "fonts.mono",
      "--global-font-body": "fonts.body",
      "--global-color-border": "colors.border"
    },
    html: {
      color: "fg",
      bg: "bg",
      lineHeight: "1.5",
      colorPalette: "gray"
    },
    "*::placeholder, *[data-placeholder]": {
      color: "fg.muted/80"
    },
    "*::selection": {
      bg: "colorPalette.emphasized/80"
    }
  });
  const layerStyles = defineLayerStyles({
"fill.muted": {
      value: {
        background: "colorPalette.muted",
        color: "colorPalette.fg"
      }
    },
    "fill.subtle": {
      value: {
        background: "colorPalette.subtle",
        color: "colorPalette.fg"
      }
    },
    "fill.surface": {
      value: {
        background: "colorPalette.subtle",
        color: "colorPalette.fg",
        boxShadow: "0 0 0px 1px var(--shadow-color)",
        boxShadowColor: "colorPalette.muted"
      }
    },
    "fill.solid": {
      value: {
        background: "colorPalette.solid",
        color: "colorPalette.contrast"
      }
    },
"outline.subtle": {
      value: {
        color: "colorPalette.fg",
        boxShadow: "inset 0 0 0px 1px var(--shadow-color)",
        boxShadowColor: "colorPalette.subtle"
      }
    },
    "outline.solid": {
      value: {
        borderWidth: "1px",
        borderColor: "colorPalette.solid",
        color: "colorPalette.fg"
      }
    },
"indicator.bottom": {
      value: {
        position: "relative",
        "--indicator-color-fallback": "colors.colorPalette.solid",
        _before: {
          content: `""`,
          position: "absolute",
          bottom: "var(--indicator-offset-y, 0)",
          insetInline: "var(--indicator-offset-x, 0)",
          height: "var(--indicator-thickness, 2px)",
          background: "var(--indicator-color, var(--indicator-color-fallback))"
        }
      }
    },
    "indicator.top": {
      value: {
        position: "relative",
        "--indicator-color-fallback": "colors.colorPalette.solid",
        _before: {
          content: `""`,
          position: "absolute",
          top: "var(--indicator-offset-y, 0)",
          insetInline: "var(--indicator-offset-x, 0)",
          height: "var(--indicator-thickness, 2px)",
          background: "var(--indicator-color, var(--indicator-color-fallback))"
        }
      }
    },
    "indicator.start": {
      value: {
        position: "relative",
        "--indicator-color-fallback": "colors.colorPalette.solid",
        _before: {
          content: `""`,
          position: "absolute",
          insetInlineStart: "var(--indicator-offset-x, 0)",
          insetBlock: "var(--indicator-offset-y, 0)",
          width: "var(--indicator-thickness, 2px)",
          background: "var(--indicator-color, var(--indicator-color-fallback))"
        }
      }
    },
    "indicator.end": {
      value: {
        position: "relative",
        "--indicator-color-fallback": "colors.colorPalette.solid",
        _before: {
          content: `""`,
          position: "absolute",
          insetInlineEnd: "var(--indicator-offset-x, 0)",
          insetBlock: "var(--indicator-offset-y, 0)",
          width: "var(--indicator-thickness, 2px)",
          background: "var(--indicator-color, var(--indicator-color-fallback))"
        }
      }
    },
    disabled: {
      value: {
        opacity: "0.5",
        cursor: "not-allowed"
      }
    },
    none: {
      value: {}
    }
  });
  const animationStyles = defineAnimationStyles({
    "slide-fade-in": {
      value: {
        transformOrigin: "var(--transform-origin)",
        "&[data-placement^=top]": {
          animationName: "slide-from-bottom, fade-in"
        },
        "&[data-placement^=bottom]": {
          animationName: "slide-from-top, fade-in"
        },
        "&[data-placement^=left]": {
          animationName: "slide-from-right, fade-in"
        },
        "&[data-placement^=right]": {
          animationName: "slide-from-left, fade-in"
        }
      }
    },
    "slide-fade-out": {
      value: {
        transformOrigin: "var(--transform-origin)",
        "&[data-placement^=top]": {
          animationName: "slide-to-bottom, fade-out"
        },
        "&[data-placement^=bottom]": {
          animationName: "slide-to-top, fade-out"
        },
        "&[data-placement^=left]": {
          animationName: "slide-to-right, fade-out"
        },
        "&[data-placement^=right]": {
          animationName: "slide-to-left, fade-out"
        }
      }
    },
    "scale-fade-in": {
      value: {
        transformOrigin: "var(--transform-origin)",
        animationName: "scale-in, fade-in"
      }
    },
    "scale-fade-out": {
      value: {
        transformOrigin: "var(--transform-origin)",
        animationName: "scale-out, fade-out"
      }
    }
  });
  const badgeRecipe = defineRecipe({
    className: "chakra-badge",
    base: {
      display: "inline-flex",
      alignItems: "center",
      borderRadius: "l2",
      gap: "1",
      fontWeight: "medium",
      fontVariantNumeric: "tabular-nums",
      whiteSpace: "nowrap",
      userSelect: "none"
    },
    variants: {
      variant: {
        solid: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        subtle: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg"
        },
        outline: {
          color: "colorPalette.fg",
          "--outline-shadow-legacy": "colors.colorPalette.muted",
          "--outline-shadow": "colors.colorPalette.border",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "var(--outline-shadow, var(--outline-shadow-legacy))"
        },
        surface: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "inset 0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted"
        },
        plain: {
          color: "colorPalette.fg"
        }
      },
      size: {
        xs: {
          textStyle: "2xs",
          px: "1",
          minH: "4"
        },
        sm: {
          textStyle: "xs",
          px: "1.5",
          minH: "5"
        },
        md: {
          textStyle: "sm",
          px: "2",
          minH: "6"
        },
        lg: {
          textStyle: "sm",
          px: "2.5",
          minH: "7"
        }
      }
    },
    defaultVariants: {
      variant: "subtle",
      size: "sm"
    }
  });
  const buttonRecipe = defineRecipe({
    className: "chakra-button",
    base: {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      borderRadius: "l2",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      borderWidth: "1px",
      borderColor: "transparent",
      cursor: "button",
      flexShrink: "0",
      outline: "0",
      lineHeight: "1.2",
      isolation: "isolate",
      fontWeight: "medium",
      transitionProperty: "common",
      transitionDuration: "moderate",
      focusVisibleRing: "outside",
      _disabled: {
        layerStyle: "disabled"
      },
      _icon: {
        flexShrink: "0"
      }
    },
    variants: {
      size: {
        "2xs": {
          h: "6",
          minW: "6",
          textStyle: "xs",
          px: "2",
          gap: "1",
          _icon: {
            width: "3.5",
            height: "3.5"
          }
        },
        xs: {
          h: "8",
          minW: "8",
          textStyle: "xs",
          px: "2.5",
          gap: "1",
          _icon: {
            width: "4",
            height: "4"
          }
        },
        sm: {
          h: "9",
          minW: "9",
          px: "3.5",
          textStyle: "sm",
          gap: "2",
          _icon: {
            width: "4",
            height: "4"
          }
        },
        md: {
          h: "10",
          minW: "10",
          textStyle: "sm",
          px: "4",
          gap: "2",
          _icon: {
            width: "5",
            height: "5"
          }
        },
        lg: {
          h: "11",
          minW: "11",
          textStyle: "md",
          px: "5",
          gap: "3",
          _icon: {
            width: "5",
            height: "5"
          }
        },
        xl: {
          h: "12",
          minW: "12",
          textStyle: "md",
          px: "5",
          gap: "2.5",
          _icon: {
            width: "5",
            height: "5"
          }
        },
        "2xl": {
          h: "16",
          minW: "16",
          textStyle: "lg",
          px: "7",
          gap: "3",
          _icon: {
            width: "6",
            height: "6"
          }
        }
      },
      variant: {
        solid: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast",
          borderColor: "transparent",
          _hover: {
            bg: "colorPalette.solid/90"
          },
          _expanded: {
            bg: "colorPalette.solid/90"
          }
        },
        subtle: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          borderColor: "transparent",
          _hover: {
            bg: "colorPalette.muted"
          },
          _expanded: {
            bg: "colorPalette.muted"
          }
        },
        surface: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          shadow: "0 0 0px 1px var(--shadow-color)",
          shadowColor: "colorPalette.muted",
          _hover: {
            bg: "colorPalette.muted"
          },
          _expanded: {
            bg: "colorPalette.muted"
          }
        },
        outline: {
          borderWidth: "1px",
          "--outline-color-legacy": "colors.colorPalette.muted",
          "--outline-color": "colors.colorPalette.border",
          borderColor: "var(--outline-color, var(--outline-color-legacy))",
          color: "colorPalette.fg",
          _hover: {
            bg: "colorPalette.subtle"
          },
          _expanded: {
            bg: "colorPalette.subtle"
          }
        },
        ghost: {
          bg: "transparent",
          color: "colorPalette.fg",
          _hover: {
            bg: "colorPalette.subtle"
          },
          _expanded: {
            bg: "colorPalette.subtle"
          }
        },
        plain: {
          color: "colorPalette.fg"
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "solid"
    }
  });
  const checkmarkRecipe = defineRecipe({
    className: "chakra-checkmark",
    base: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0",
      color: "white",
      borderWidth: "1px",
      borderColor: "transparent",
      borderRadius: "l1",
      cursor: "checkbox",
      focusVisibleRing: "outside",
      _icon: {
        boxSize: "full"
      },
      _invalid: {
        colorPalette: "red",
        borderColor: "border.error"
      },
      _disabled: {
        opacity: "0.5",
        cursor: "disabled"
      }
    },
    variants: {
      size: {
        xs: {
          boxSize: "3"
        },
        sm: {
          boxSize: "4"
        },
        md: {
          boxSize: "5",
          p: "0.5"
        },
        lg: {
          boxSize: "6",
          p: "0.5"
        }
      },
      variant: {
        solid: {
          borderColor: "border.emphasized",
          "&:is([data-state=checked], [data-state=indeterminate])": {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        outline: {
          borderColor: "border",
          "&:is([data-state=checked], [data-state=indeterminate])": {
            color: "colorPalette.fg",
            borderColor: "colorPalette.solid"
          }
        },
        subtle: {
          bg: "colorPalette.muted",
          borderColor: "colorPalette.muted",
          "&:is([data-state=checked], [data-state=indeterminate])": {
            color: "colorPalette.fg"
          }
        },
        plain: {
          "&:is([data-state=checked], [data-state=indeterminate])": {
            color: "colorPalette.fg"
          }
        },
        inverted: {
          borderColor: "border",
          color: "colorPalette.fg",
          "&:is([data-state=checked], [data-state=indeterminate])": {
            borderColor: "colorPalette.solid"
          }
        }
      },
      filled: {
        true: {
          bg: "bg"
        }
      }
    },
    defaultVariants: {
      variant: "solid",
      size: "md"
    }
  });
  const { variants: variants$1, defaultVariants: defaultVariants$1 } = badgeRecipe;
  const codeRecipe = defineRecipe({
    className: "chakra-code",
    base: {
      fontFamily: "mono",
      alignItems: "center",
      display: "inline-flex",
      borderRadius: "l2"
    },
    variants: variants$1,
    defaultVariants: defaultVariants$1
  });
  const colorSwatchRecipe = defineRecipe({
    className: "color-swatch",
    base: {
      boxSize: "var(--swatch-size)",
      shadow: "inset 0 0 0 1px rgba(0, 0, 0, 0.1)",
      "--checker-size": "8px",
      "--checker-bg": "colors.bg",
      "--checker-fg": "colors.bg.emphasized",
      background: "linear-gradient(var(--color), var(--color)), repeating-conic-gradient(var(--checker-fg) 0%, var(--checker-fg) 25%, var(--checker-bg) 0%, var(--checker-bg) 50%) 0% 50% / var(--checker-size) var(--checker-size) !important",
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: "0"
    },
    variants: {
      size: {
        "2xs": { "--swatch-size": "sizes.3.5" },
        xs: { "--swatch-size": "sizes.4" },
        sm: { "--swatch-size": "sizes.4.5" },
        md: { "--swatch-size": "sizes.5" },
        lg: { "--swatch-size": "sizes.6" },
        xl: { "--swatch-size": "sizes.7" },
        "2xl": { "--swatch-size": "sizes.8" },
        inherit: { "--swatch-size": "inherit" },
        full: { "--swatch-size": "100%" }
      },
      shape: {
        square: { borderRadius: "none" },
        circle: { borderRadius: "full" },
        rounded: { borderRadius: "l1" }
      }
    },
    defaultVariants: {
      size: "md",
      shape: "rounded"
    }
  });
  const containerRecipe = defineRecipe({
    className: "chakra-container",
    base: {
      position: "relative",
      maxWidth: "8xl",
      w: "100%",
      mx: "auto",
      px: { base: "4", md: "6", lg: "8" }
    },
    variants: {
      centerContent: {
        true: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center"
        }
      },
      fluid: {
        true: {
          maxWidth: "full"
        }
      }
    }
  });
  const headingRecipe = defineRecipe({
    className: "chakra-heading",
    base: {
      fontFamily: "heading",
      fontWeight: "semibold"
    },
    variants: {
      size: {
        xs: { textStyle: "xs" },
        sm: { textStyle: "sm" },
        md: { textStyle: "md" },
        lg: { textStyle: "lg" },
        xl: { textStyle: "xl" },
        "2xl": { textStyle: "2xl" },
        "3xl": { textStyle: "3xl" },
        "4xl": { textStyle: "4xl" },
        "5xl": { textStyle: "5xl" },
        "6xl": { textStyle: "6xl" },
        "7xl": { textStyle: "7xl" }
      }
    },
    defaultVariants: {
      size: "xl"
    }
  });
  const iconRecipe = defineRecipe({
    className: "chakra-icon",
    base: {
      display: "inline-block",
      lineHeight: "1em",
      flexShrink: "0",
      color: "currentcolor",
      verticalAlign: "middle"
    },
    variants: {
      size: {
        inherit: {},
        xs: { boxSize: "3" },
        sm: { boxSize: "4" },
        md: { boxSize: "5" },
        lg: { boxSize: "6" },
        xl: { boxSize: "7" },
        "2xl": { boxSize: "8" }
      }
    },
    defaultVariants: {
      size: "inherit"
    }
  });
  const inputRecipe = defineRecipe({
    className: "chakra-input",
    base: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      position: "relative",
      appearance: "none",
      textAlign: "start",
      borderRadius: "l2",
      _disabled: {
        layerStyle: "disabled"
      },
      height: "var(--input-height)",
      minW: "var(--input-height)",
      "--focus-color": "colors.colorPalette.focusRing",
      "--error-color": "colors.border.error",
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      }
    },
    variants: {
      size: {
        "2xs": {
          textStyle: "xs",
          px: "2",
          "--input-height": "sizes.7"
        },
        xs: {
          textStyle: "xs",
          px: "2",
          "--input-height": "sizes.8"
        },
        sm: {
          textStyle: "sm",
          px: "2.5",
          "--input-height": "sizes.9"
        },
        md: {
          textStyle: "sm",
          px: "3",
          "--input-height": "sizes.10"
        },
        lg: {
          textStyle: "md",
          px: "4",
          "--input-height": "sizes.11"
        },
        xl: {
          textStyle: "md",
          px: "4.5",
          "--input-height": "sizes.12"
        },
        "2xl": {
          textStyle: "lg",
          px: "5",
          "--input-height": "sizes.16"
        }
      },
      variant: {
        outline: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          focusVisibleRing: "inside",
          focusRingColor: "var(--focus-color)"
        },
        subtle: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted",
          focusVisibleRing: "inside",
          focusRingColor: "var(--focus-color)"
        },
        flushed: {
          bg: "transparent",
          borderBottomWidth: "1px",
          borderBottomColor: "border",
          borderRadius: "0",
          px: "0",
          _focusVisible: {
            borderColor: "var(--focus-color)",
            boxShadow: "0px 1px 0px 0px var(--focus-color)",
            _invalid: {
              borderColor: "var(--error-color)",
              boxShadow: "0px 1px 0px 0px var(--error-color)"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const inputAddonRecipe = defineRecipe({
    className: "chakra-input-addon",
    base: {
      flex: "0 0 auto",
      width: "auto",
      display: "flex",
      alignItems: "center",
      whiteSpace: "nowrap",
      alignSelf: "stretch",
      borderRadius: "l2"
    },
    variants: {
      size: inputRecipe.variants.size,
      variant: {
        outline: {
          borderWidth: "1px",
          borderColor: "border",
          bg: "bg.muted"
        },
        subtle: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.emphasized"
        },
        flushed: {
          borderBottom: "1px solid",
          borderColor: "inherit",
          borderRadius: "0",
          px: "0",
          bg: "transparent"
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const kbdRecipe = defineRecipe({
    className: "chakra-kbd",
    base: {
      display: "inline-flex",
      alignItems: "center",
      fontWeight: "medium",
      fontFamily: "mono",
      flexShrink: "0",
      whiteSpace: "nowrap",
      wordSpacing: "-0.5em",
      userSelect: "none",
      px: "1",
      borderRadius: "l2"
    },
    variants: {
      variant: {
        raised: {
          bg: "colorPalette.subtle",
          color: "colorPalette.fg",
          borderWidth: "1px",
          borderBottomWidth: "2px",
          borderColor: "colorPalette.muted"
        },
        outline: {
          borderWidth: "1px",
          color: "colorPalette.fg"
        },
        subtle: {
          bg: "colorPalette.muted",
          color: "colorPalette.fg"
        },
        plain: {
          color: "colorPalette.fg"
        }
      },
      size: {
        sm: {
          textStyle: "xs",
          height: "4.5"
        },
        md: {
          textStyle: "sm",
          height: "5"
        },
        lg: {
          textStyle: "md",
          height: "6"
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "raised"
    }
  });
  const linkRecipe = defineRecipe({
    className: "chakra-link",
    base: {
      display: "inline-flex",
      alignItems: "center",
      outline: "none",
      gap: "1.5",
      cursor: "pointer",
      borderRadius: "l1",
      focusRing: "outside"
    },
    variants: {
      variant: {
        underline: {
          color: "colorPalette.fg",
          textDecoration: "underline",
          textUnderlineOffset: "3px",
          textDecorationColor: "currentColor/20"
        },
        plain: {
          color: "colorPalette.fg",
          _hover: {
            textDecoration: "underline",
            textUnderlineOffset: "3px",
            textDecorationColor: "currentColor/20"
          }
        }
      }
    },
    defaultVariants: {
      variant: "plain"
    }
  });
  const markRecipe = defineRecipe({
    className: "chakra-mark",
    base: {
      bg: "transparent",
      color: "inherit",
      whiteSpace: "nowrap"
    },
    variants: {
      variant: {
        subtle: {
          bg: "colorPalette.subtle",
          color: "inherit"
        },
        solid: {
          bg: "colorPalette.solid",
          color: "colorPalette.contrast"
        },
        text: {
          fontWeight: "medium"
        },
        plain: {}
      }
    }
  });
  const radiomarkRecipe = defineRecipe({
    className: "chakra-radiomark",
    base: {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0,
      verticalAlign: "top",
      color: "white",
      borderWidth: "1px",
      borderColor: "transparent",
      borderRadius: "full",
      cursor: "radio",
      _focusVisible: {
        outline: "2px solid",
        outlineColor: "colorPalette.focusRing",
        outlineOffset: "2px"
      },
      _invalid: {
        colorPalette: "red",
        borderColor: "red.500"
      },
      _disabled: {
        opacity: "0.5",
        cursor: "disabled"
      },
      "& .dot": {
        height: "100%",
        width: "100%",
        borderRadius: "full",
        bg: "currentColor",
        scale: "0.4"
      }
    },
    variants: {
      variant: {
        solid: {
          borderWidth: "1px",
          borderColor: "border.emphasized",
          _checked: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast",
            borderColor: "colorPalette.solid"
          }
        },
        subtle: {
          borderWidth: "1px",
          bg: "colorPalette.muted",
          borderColor: "colorPalette.muted",
          color: "transparent",
          _checked: {
            color: "colorPalette.fg"
          }
        },
        outline: {
          borderWidth: "1px",
          borderColor: "inherit",
          _checked: {
            color: "colorPalette.fg",
            borderColor: "colorPalette.solid"
          },
          "& .dot": {
            scale: "0.6"
          }
        },
        inverted: {
          bg: "bg",
          borderWidth: "1px",
          borderColor: "inherit",
          _checked: {
            color: "colorPalette.solid",
            borderColor: "currentcolor"
          }
        }
      },
      size: {
        xs: {
          boxSize: "3"
        },
        sm: {
          boxSize: "4"
        },
        md: {
          boxSize: "5"
        },
        lg: {
          boxSize: "6"
        }
      },
      filled: {
        true: {
          bg: "bg"
        }
      }
    },
    defaultVariants: {
      variant: "solid",
      size: "md"
    }
  });
  const separatorRecipe = defineRecipe({
    className: "chakra-separator",
    base: {
      display: "block",
      borderColor: "border"
    },
    variants: {
      variant: {
        solid: {
          borderStyle: "solid"
        },
        dashed: {
          borderStyle: "dashed"
        },
        dotted: {
          borderStyle: "dotted"
        }
      },
      orientation: {
        vertical: {
          borderInlineStartWidth: "var(--separator-thickness)"
        },
        horizontal: {
          borderTopWidth: "var(--separator-thickness)"
        }
      },
      size: {
        xs: {
          "--separator-thickness": "0.5px"
        },
        sm: {
          "--separator-thickness": "1px"
        },
        md: {
          "--separator-thickness": "2px"
        },
        lg: {
          "--separator-thickness": "3px"
        }
      }
    },
    defaultVariants: {
      size: "sm",
      variant: "solid",
      orientation: "horizontal"
    }
  });
  const skeletonRecipe = defineRecipe({
    className: "chakra-skeleton",
    base: {},
    variants: {
      loading: {
        true: {
          borderRadius: "l2",
          boxShadow: "none",
          backgroundClip: "padding-box",
          cursor: "default",
          color: "transparent",
          pointerEvents: "none",
          userSelect: "none",
          flexShrink: "0",
          "&::before, &::after, *": {
            visibility: "hidden"
          }
        },
        false: {
          background: "unset",
          animation: "fade-in var(--fade-duration, 0.1s) ease-out !important"
        }
      },
      variant: {
        pulse: {
          background: "bg.emphasized",
          animation: "pulse",
          animationDuration: "var(--duration, 1.2s)"
        },
        shine: {
          "--animate-from": "200%",
          "--animate-to": "-200%",
          "--start-color": "colors.bg.muted",
          "--end-color": "colors.bg.emphasized",
          backgroundImage: "linear-gradient(270deg,var(--start-color),var(--end-color),var(--end-color),var(--start-color))",
          backgroundSize: "400% 100%",
          animation: "bg-position var(--duration, 5s) ease-in-out infinite"
        },
        none: {
          animation: "none"
        }
      }
    },
    defaultVariants: {
      variant: "pulse",
      loading: true
    }
  });
  const skipNavLinkRecipe = defineRecipe({
    className: "chakra-skip-nav",
    base: {
      display: "inline-flex",
      bg: "bg.panel",
      padding: "2.5",
      borderRadius: "l2",
      fontWeight: "semibold",
      focusVisibleRing: "outside",
      textStyle: "sm",
userSelect: "none",
      border: "0",
      height: "1px",
      width: "1px",
      margin: "-1px",
      outline: "0",
      overflow: "hidden",
      position: "absolute",
      clip: "rect(0 0 0 0)",
      _focusVisible: {
        clip: "auto",
        width: "auto",
        height: "auto",
        position: "fixed",
        top: "6",
        insetStart: "6"
      }
    }
  });
  const spinnerRecipe = defineRecipe({
    className: "chakra-spinner",
    base: {
      display: "inline-block",
      borderColor: "currentColor",
      borderStyle: "solid",
      borderWidth: "2px",
      borderRadius: "full",
      width: "var(--spinner-size)",
      height: "var(--spinner-size)",
      animation: "spin",
      animationDuration: "slowest",
      "--spinner-track-color": "transparent",
      borderBottomColor: "var(--spinner-track-color)",
      borderInlineStartColor: "var(--spinner-track-color)"
    },
    variants: {
      size: {
        inherit: { "--spinner-size": "1em" },
        xs: { "--spinner-size": "sizes.3" },
        sm: { "--spinner-size": "sizes.4" },
        md: { "--spinner-size": "sizes.5" },
        lg: { "--spinner-size": "sizes.8" },
        xl: { "--spinner-size": "sizes.10" }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const textareaRecipe = defineRecipe({
    className: "chakra-textarea",
    base: {
      width: "100%",
      minWidth: "0",
      outline: "0",
      position: "relative",
      appearance: "none",
      textAlign: "start",
      borderRadius: "l2",
      _disabled: {
        layerStyle: "disabled"
      },
      "--focus-color": "colors.colorPalette.focusRing",
      "--error-color": "colors.border.error",
      _invalid: {
        focusRingColor: "var(--error-color)",
        borderColor: "var(--error-color)"
      }
    },
    variants: {
      size: {
        xs: {
          textStyle: "xs",
          px: "2",
          py: "1.5",
          scrollPaddingBottom: "1.5"
        },
        sm: {
          textStyle: "sm",
          px: "2.5",
          py: "2",
          scrollPaddingBottom: "2"
        },
        md: {
          textStyle: "sm",
          px: "3",
          py: "2",
          scrollPaddingBottom: "2"
        },
        lg: {
          textStyle: "md",
          px: "4",
          py: "3",
          scrollPaddingBottom: "3"
        },
        xl: {
          textStyle: "md",
          px: "4.5",
          py: "3.5",
          scrollPaddingBottom: "3.5"
        }
      },
      variant: {
        outline: {
          bg: "transparent",
          borderWidth: "1px",
          borderColor: "border",
          focusVisibleRing: "inside"
        },
        subtle: {
          borderWidth: "1px",
          borderColor: "transparent",
          bg: "bg.muted",
          focusVisibleRing: "inside"
        },
        flushed: {
          bg: "transparent",
          borderBottomWidth: "1px",
          borderBottomColor: "border",
          borderRadius: "0",
          px: "0",
          _focusVisible: {
            borderColor: "var(--focus-color)",
            boxShadow: "0px 1px 0px 0px var(--focus-color)"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const recipes = {
    badge: badgeRecipe,
    button: buttonRecipe,
    code: codeRecipe,
    container: containerRecipe,
    heading: headingRecipe,
    input: inputRecipe,
    inputAddon: inputAddonRecipe,
    kbd: kbdRecipe,
    link: linkRecipe,
    mark: markRecipe,
    separator: separatorRecipe,
    skeleton: skeletonRecipe,
    skipNavLink: skipNavLinkRecipe,
    spinner: spinnerRecipe,
    textarea: textareaRecipe,
    icon: iconRecipe,
    checkmark: checkmarkRecipe,
    radiomark: radiomarkRecipe,
    colorSwatch: colorSwatchRecipe
  };
  const semanticColors = defineSemanticTokens.colors({
    bg: {
      DEFAULT: {
        value: { _light: "{colors.white}", _dark: "{colors.black}" }
      },
      subtle: {
        value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
      },
      muted: {
        value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
      },
      emphasized: {
        value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
      },
      inverted: {
        value: { _light: "{colors.black}", _dark: "{colors.white}" }
      },
      panel: {
        value: { _light: "{colors.white}", _dark: "{colors.gray.950}" }
      },
      error: {
        value: { _light: "{colors.red.50}", _dark: "{colors.red.950}" }
      },
      warning: {
        value: { _light: "{colors.orange.50}", _dark: "{colors.orange.950}" }
      },
      success: {
        value: { _light: "{colors.green.50}", _dark: "{colors.green.950}" }
      },
      info: {
        value: { _light: "{colors.blue.50}", _dark: "{colors.blue.950}" }
      }
    },
    fg: {
      DEFAULT: {
        value: { _light: "{colors.black}", _dark: "{colors.gray.50}" }
      },
      muted: {
        value: { _light: "{colors.gray.600}", _dark: "{colors.gray.400}" }
      },
      subtle: {
        value: { _light: "{colors.gray.400}", _dark: "{colors.gray.500}" }
      },
      inverted: {
        value: { _light: "{colors.gray.50}", _dark: "{colors.black}" }
      },
      error: {
        value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
      },
      warning: {
        value: { _light: "{colors.orange.600}", _dark: "{colors.orange.300}" }
      },
      success: {
        value: { _light: "{colors.green.600}", _dark: "{colors.green.300}" }
      },
      info: {
        value: { _light: "{colors.blue.600}", _dark: "{colors.blue.300}" }
      }
    },
    border: {
      DEFAULT: {
        value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
      },
      muted: {
        value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
      },
      subtle: {
        value: { _light: "{colors.gray.50}", _dark: "{colors.gray.950}" }
      },
      emphasized: {
        value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
      },
      inverted: {
        value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
      },
      error: {
        value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
      },
      warning: {
        value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
      },
      success: {
        value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
      },
      info: {
        value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
      }
    },
    gray: {
      contrast: {
        value: { _light: "{colors.white}", _dark: "{colors.black}" }
      },
      fg: {
        value: { _light: "{colors.gray.800}", _dark: "{colors.gray.200}" }
      },
      subtle: {
        value: { _light: "{colors.gray.100}", _dark: "{colors.gray.900}" }
      },
      muted: {
        value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
      },
      emphasized: {
        value: { _light: "{colors.gray.300}", _dark: "{colors.gray.700}" }
      },
      solid: {
        value: { _light: "{colors.gray.900}", _dark: "{colors.white}" }
      },
      focusRing: {
        value: { _light: "{colors.gray.400}", _dark: "{colors.gray.400}" }
      },
      border: {
        value: { _light: "{colors.gray.200}", _dark: "{colors.gray.800}" }
      }
    },
    red: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.red.700}", _dark: "{colors.red.300}" }
      },
      subtle: {
        value: { _light: "{colors.red.100}", _dark: "{colors.red.900}" }
      },
      muted: {
        value: { _light: "{colors.red.200}", _dark: "{colors.red.800}" }
      },
      emphasized: {
        value: { _light: "{colors.red.300}", _dark: "{colors.red.700}" }
      },
      solid: {
        value: { _light: "{colors.red.600}", _dark: "{colors.red.600}" }
      },
      focusRing: {
        value: { _light: "{colors.red.500}", _dark: "{colors.red.500}" }
      },
      border: {
        value: { _light: "{colors.red.500}", _dark: "{colors.red.400}" }
      }
    },
    orange: {
      contrast: {
        value: { _light: "white", _dark: "black" }
      },
      fg: {
        value: { _light: "{colors.orange.700}", _dark: "{colors.orange.300}" }
      },
      subtle: {
        value: { _light: "{colors.orange.100}", _dark: "{colors.orange.900}" }
      },
      muted: {
        value: { _light: "{colors.orange.200}", _dark: "{colors.orange.800}" }
      },
      emphasized: {
        value: { _light: "{colors.orange.300}", _dark: "{colors.orange.700}" }
      },
      solid: {
        value: { _light: "{colors.orange.600}", _dark: "{colors.orange.500}" }
      },
      focusRing: {
        value: { _light: "{colors.orange.500}", _dark: "{colors.orange.500}" }
      },
      border: {
        value: { _light: "{colors.orange.500}", _dark: "{colors.orange.400}" }
      }
    },
    green: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.green.700}", _dark: "{colors.green.300}" }
      },
      subtle: {
        value: { _light: "{colors.green.100}", _dark: "{colors.green.900}" }
      },
      muted: {
        value: { _light: "{colors.green.200}", _dark: "{colors.green.800}" }
      },
      emphasized: {
        value: { _light: "{colors.green.300}", _dark: "{colors.green.700}" }
      },
      solid: {
        value: { _light: "{colors.green.600}", _dark: "{colors.green.600}" }
      },
      focusRing: {
        value: { _light: "{colors.green.500}", _dark: "{colors.green.500}" }
      },
      border: {
        value: { _light: "{colors.green.500}", _dark: "{colors.green.400}" }
      }
    },
    blue: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.blue.700}", _dark: "{colors.blue.300}" }
      },
      subtle: {
        value: { _light: "{colors.blue.100}", _dark: "{colors.blue.900}" }
      },
      muted: {
        value: { _light: "{colors.blue.200}", _dark: "{colors.blue.800}" }
      },
      emphasized: {
        value: { _light: "{colors.blue.300}", _dark: "{colors.blue.700}" }
      },
      solid: {
        value: { _light: "{colors.blue.600}", _dark: "{colors.blue.600}" }
      },
      focusRing: {
        value: { _light: "{colors.blue.500}", _dark: "{colors.blue.500}" }
      },
      border: {
        value: { _light: "{colors.blue.500}", _dark: "{colors.blue.400}" }
      }
    },
    yellow: {
      contrast: {
        value: { _light: "black", _dark: "black" }
      },
      fg: {
        value: { _light: "{colors.yellow.800}", _dark: "{colors.yellow.300}" }
      },
      subtle: {
        value: { _light: "{colors.yellow.100}", _dark: "{colors.yellow.900}" }
      },
      muted: {
        value: { _light: "{colors.yellow.200}", _dark: "{colors.yellow.800}" }
      },
      emphasized: {
        value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.700}" }
      },
      solid: {
        value: { _light: "{colors.yellow.300}", _dark: "{colors.yellow.300}" }
      },
      focusRing: {
        value: { _light: "{colors.yellow.500}", _dark: "{colors.yellow.500}" }
      },
      border: {
        value: { _light: "{colors.yellow.500}", _dark: "{colors.yellow.500}" }
      }
    },
    teal: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.teal.700}", _dark: "{colors.teal.300}" }
      },
      subtle: {
        value: { _light: "{colors.teal.100}", _dark: "{colors.teal.900}" }
      },
      muted: {
        value: { _light: "{colors.teal.200}", _dark: "{colors.teal.800}" }
      },
      emphasized: {
        value: { _light: "{colors.teal.300}", _dark: "{colors.teal.700}" }
      },
      solid: {
        value: { _light: "{colors.teal.600}", _dark: "{colors.teal.600}" }
      },
      focusRing: {
        value: { _light: "{colors.teal.500}", _dark: "{colors.teal.500}" }
      },
      border: {
        value: { _light: "{colors.teal.500}", _dark: "{colors.teal.400}" }
      }
    },
    purple: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.purple.700}", _dark: "{colors.purple.300}" }
      },
      subtle: {
        value: { _light: "{colors.purple.100}", _dark: "{colors.purple.900}" }
      },
      muted: {
        value: { _light: "{colors.purple.200}", _dark: "{colors.purple.800}" }
      },
      emphasized: {
        value: { _light: "{colors.purple.300}", _dark: "{colors.purple.700}" }
      },
      solid: {
        value: { _light: "{colors.purple.600}", _dark: "{colors.purple.600}" }
      },
      focusRing: {
        value: { _light: "{colors.purple.500}", _dark: "{colors.purple.500}" }
      },
      border: {
        value: { _light: "{colors.purple.500}", _dark: "{colors.purple.400}" }
      }
    },
    pink: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.pink.700}", _dark: "{colors.pink.300}" }
      },
      subtle: {
        value: { _light: "{colors.pink.100}", _dark: "{colors.pink.900}" }
      },
      muted: {
        value: { _light: "{colors.pink.200}", _dark: "{colors.pink.800}" }
      },
      emphasized: {
        value: { _light: "{colors.pink.300}", _dark: "{colors.pink.700}" }
      },
      solid: {
        value: { _light: "{colors.pink.600}", _dark: "{colors.pink.600}" }
      },
      focusRing: {
        value: { _light: "{colors.pink.500}", _dark: "{colors.pink.500}" }
      },
      border: {
        value: { _light: "{colors.pink.500}", _dark: "{colors.pink.400}" }
      }
    },
    cyan: {
      contrast: {
        value: { _light: "white", _dark: "white" }
      },
      fg: {
        value: { _light: "{colors.cyan.700}", _dark: "{colors.cyan.300}" }
      },
      subtle: {
        value: { _light: "{colors.cyan.100}", _dark: "{colors.cyan.900}" }
      },
      muted: {
        value: { _light: "{colors.cyan.200}", _dark: "{colors.cyan.800}" }
      },
      emphasized: {
        value: { _light: "{colors.cyan.300}", _dark: "{colors.cyan.700}" }
      },
      solid: {
        value: { _light: "{colors.cyan.600}", _dark: "{colors.cyan.600}" }
      },
      focusRing: {
        value: { _light: "{colors.cyan.500}", _dark: "{colors.cyan.500}" }
      },
      border: {
        value: { _light: "{colors.cyan.500}", _dark: "{colors.cyan.400}" }
      }
    }
  });
  const semanticRadii = defineSemanticTokens.radii({
    l1: { value: "{radii.xs}" },
    l2: { value: "{radii.sm}" },
    l3: { value: "{radii.md}" }
  });
  const semanticShadows = defineSemanticTokens.shadows({
    xs: {
      value: {
        _light: "0px 1px 2px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/20}",
        _dark: "0px 1px 1px {black/64}, 0px 0px 1px inset {colors.gray.300/20}"
      }
    },
    sm: {
      value: {
        _light: "0px 2px 4px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
        _dark: "0px 2px 4px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
      }
    },
    md: {
      value: {
        _light: "0px 4px 8px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
        _dark: "0px 4px 8px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
      }
    },
    lg: {
      value: {
        _light: "0px 8px 16px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
        _dark: "0px 8px 16px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
      }
    },
    xl: {
      value: {
        _light: "0px 16px 24px {colors.gray.900/10}, 0px 0px 1px {colors.gray.900/30}",
        _dark: "0px 16px 24px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
      }
    },
    "2xl": {
      value: {
        _light: "0px 24px 40px {colors.gray.900/16}, 0px 0px 1px {colors.gray.900/30}",
        _dark: "0px 24px 40px {black/64}, 0px 0px 1px inset {colors.gray.300/30}"
      }
    },
    inner: {
      value: {
        _light: "inset 0 2px 4px 0 {black/5}",
        _dark: "inset 0 2px 4px 0 black"
      }
    },
    inset: {
      value: {
        _light: "inset 0 0 0 1px {black/5}",
        _dark: "inset 0 0 0 1px {colors.gray.300/5}"
      }
    }
  });
  const accordionAnatomy = anatomy$q.extendWith("itemBody");
  const actionBarAnatomy = createAnatomy("action-bar").parts(
    "positioner",
    "content",
    "separator",
    "selectionTrigger",
    "closeTrigger"
  );
  const alertAnatomy = createAnatomy("alert").parts(
    "title",
    "description",
    "root",
    "indicator",
    "content"
  );
  const breadcrumbAnatomy = createAnatomy("breadcrumb").parts(
    "link",
    "currentLink",
    "item",
    "list",
    "root",
    "ellipsis",
    "separator"
  );
  const blockquoteAnatomy = createAnatomy("blockquote").parts(
    "root",
    "icon",
    "content",
    "caption"
  );
  const cardAnatomy = createAnatomy("card").parts(
    "root",
    "header",
    "body",
    "footer",
    "title",
    "description"
  );
  const checkboxCardAnatomy = createAnatomy("checkbox-card", [
    "root",
    "control",
    "label",
    "description",
    "addon",
    "indicator",
    "content"
  ]);
  const dataListAnatomy = createAnatomy("data-list").parts(
    "root",
    "item",
    "itemLabel",
    "itemValue"
  );
  const dialogAnatomy = anatomy$k.extendWith(
    "header",
    "body",
    "footer",
    "backdrop"
  );
  const drawerAnatomy = anatomy$k.extendWith(
    "header",
    "body",
    "footer",
    "backdrop"
  );
  const editableAnatomy = anatomy$j.extendWith("textarea");
  const emptyStateAnatomy = createAnatomy("empty-state", [
    "root",
    "content",
    "indicator",
    "title",
    "description"
  ]);
  const fieldAnatomy = fieldAnatomy$1.extendWith("requiredIndicator");
  const fieldsetAnatomy = fieldsetAnatomy$1.extendWith("content");
  const fileUploadAnatomy = anatomy$i.extendWith(
    "itemContent",
    "dropzoneContent",
    "fileText"
  );
  const listAnatomy = createAnatomy("list").parts(
    "root",
    "item",
    "indicator"
  );
  const menuAnatomy = anatomy$e.extendWith("itemCommand");
  const nativeSelectAnatomy = createAnatomy("select").parts(
    "root",
    "field",
    "indicator"
  );
  const popoverAnatomy = anatomy$b.extendWith(
    "header",
    "body",
    "footer"
  );
  const radioGroupAnatomy = anatomy$8.extendWith(
    "itemAddon",
    "itemIndicator"
  );
  const radioCardAnatomy = radioGroupAnatomy.extendWith(
    "itemContent",
    "itemDescription"
  );
  const ratingGroupAnatomy = anatomy$7.extendWith("itemIndicator");
  const selectAnatomy = anatomy$5.extendWith("indicatorGroup");
  const comboboxAnatomy = comboboxAnatomy$1.extendWith(
    "indicatorGroup",
    "empty"
  );
  const sliderAnatomy = anatomy$4.extendWith("markerIndicator");
  const statAnatomy = createAnatomy("stat").parts(
    "root",
    "label",
    "helpText",
    "valueText",
    "valueUnit",
    "indicator"
  );
  const statusAnatomy = createAnatomy("status").parts("root", "indicator");
  const stepsAnatomy = createAnatomy("steps", [
    "root",
    "list",
    "item",
    "trigger",
    "indicator",
    "separator",
    "content",
    "title",
    "description",
    "nextTrigger",
    "prevTrigger",
    "progress"
  ]);
  const switchAnatomy = anatomy$3.extendWith("indicator");
  const tableAnatomy = createAnatomy("table").parts(
    "root",
    "header",
    "body",
    "row",
    "columnHeader",
    "cell",
    "footer",
    "caption"
  );
  const toastAnatomy = createAnatomy("toast").parts(
    "root",
    "title",
    "description",
    "indicator",
    "closeTrigger",
    "actionTrigger"
  );
  const tabsAnatomy = createAnatomy("tabs").parts(
    "root",
    "trigger",
    "list",
    "content",
    "contentGroup",
    "indicator"
  );
  const tagAnatomy = createAnatomy("tag").parts(
    "root",
    "label",
    "closeTrigger",
    "startElement",
    "endElement"
  );
  const timelineAnatomy = createAnatomy("timeline").parts(
    "root",
    "item",
    "content",
    "separator",
    "indicator",
    "connector",
    "title",
    "description"
  );
  const colorPickerAnatomy = colorPickerAnatomy$1.extendWith("channelText");
  const codeBlockAnatomy = createAnatomy("code-block", [
    "root",
    "content",
    "title",
    "header",
    "footer",
    "control",
    "overlay",
    "code",
    "codeText",
    "copyTrigger",
    "copyIndicator",
    "collapseTrigger",
    "collapseIndicator",
    "collapseText"
  ]);
  const splitterAnatomy = anatomy$r.extendWith(
    "resizeTriggerSeparator",
    "resizeTriggerIndicator"
  );
  anatomy$m.extendWith("valueText");
  const listboxAnatomy = listboxAnatomy$1;
  const accordionSlotRecipe = defineSlotRecipe({
    className: "chakra-accordion",
    slots: accordionAnatomy.keys(),
    base: {
      root: {
        width: "full",
        "--accordion-radius": "radii.l2"
      },
      item: {
        overflowAnchor: "none"
      },
      itemTrigger: {
        display: "flex",
        alignItems: "center",
        textAlign: "start",
        width: "full",
        outline: "0",
        gap: "3",
        fontWeight: "medium",
        borderRadius: "var(--accordion-radius)",
        _focusVisible: {
          outline: "2px solid",
          outlineColor: "colorPalette.focusRing"
        },
        _disabled: {
          layerStyle: "disabled"
        }
      },
      itemBody: {
        pt: "var(--accordion-padding-y)",
        pb: "calc(var(--accordion-padding-y) * 2)"
      },
      itemContent: {
        overflow: "hidden",
        borderRadius: "var(--accordion-radius)",
        _open: {
          animationName: "expand-height, fade-in",
          animationDuration: "moderate"
        },
        _closed: {
          animationName: "collapse-height, fade-out",
          animationDuration: "moderate"
        }
      },
      itemIndicator: {
        transition: "rotate 0.2s",
        transformOrigin: "center",
        color: "fg.subtle",
        _open: {
          rotate: "180deg"
        },
        _icon: {
          width: "1.2em",
          height: "1.2em"
        }
      }
    },
    variants: {
      variant: {
        outline: {
          item: {
            borderBottomWidth: "1px"
          }
        },
        subtle: {
          itemTrigger: {
            px: "var(--accordion-padding-x)"
          },
          itemContent: {
            px: "var(--accordion-padding-x)"
          },
          item: {
            borderRadius: "var(--accordion-radius)",
            _open: {
              bg: "colorPalette.subtle"
            }
          }
        },
        enclosed: {
          root: {
            borderWidth: "1px",
            borderRadius: "var(--accordion-radius)",
            divideY: "1px",
            overflow: "hidden"
          },
          itemTrigger: {
            px: "var(--accordion-padding-x)"
          },
          itemContent: {
            px: "var(--accordion-padding-x)"
          },
          item: {
            _open: {
              bg: "bg.subtle"
            }
          }
        },
        plain: {}
      },
      size: {
        sm: {
          root: {
            "--accordion-padding-x": "spacing.3",
            "--accordion-padding-y": "spacing.2"
          },
          itemTrigger: {
            textStyle: "sm",
            py: "var(--accordion-padding-y)"
          }
        },
        md: {
          root: {
            "--accordion-padding-x": "spacing.4",
            "--accordion-padding-y": "spacing.2"
          },
          itemTrigger: {
            textStyle: "md",
            py: "var(--accordion-padding-y)"
          }
        },
        lg: {
          root: {
            "--accordion-padding-x": "spacing.4.5",
            "--accordion-padding-y": "spacing.2.5"
          },
          itemTrigger: {
            textStyle: "lg",
            py: "var(--accordion-padding-y)"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const actionBarSlotRecipe = defineSlotRecipe({
    className: "chakra-action-bar",
    slots: actionBarAnatomy.keys(),
    base: {
      positioner: {
        position: "fixed",
        display: "flex",
        justifyContent: "center",
        pointerEvents: "none",
        insetInline: "0",
        top: "unset",
        bottom: "calc(env(safe-area-inset-bottom) + 20px)"
      },
      content: {
        bg: "bg.panel",
        shadow: "md",
        display: "flex",
        alignItems: "center",
        gap: "3",
        borderRadius: "l3",
        py: "2.5",
        px: "3",
        pointerEvents: "auto",

translate: "calc(-1 * var(--scrollbar-width) / 2) 0px",
        _open: {
          animationName: "slide-from-bottom, fade-in",
          animationDuration: "moderate"
        },
        _closed: {
          animationName: "slide-to-bottom, fade-out",
          animationDuration: "faster"
        }
      },
      separator: {
        width: "1px",
        height: "5",
        bg: "border"
      },
      selectionTrigger: {
        display: "inline-flex",
        alignItems: "center",
        gap: "2",
        alignSelf: "stretch",
        textStyle: "sm",
        px: "4",
        py: "1",
        borderRadius: "l2",
        borderWidth: "1px",
        borderStyle: "dashed"
      }
    }
  });
  const alertSlotRecipe = defineSlotRecipe({
    slots: alertAnatomy.keys(),
    className: "chakra-alert",
    base: {
      root: {
        width: "full",
        display: "flex",
        alignItems: "flex-start",
        position: "relative",
        borderRadius: "l3"
      },
      title: {
        fontWeight: "medium"
      },
      description: {
        display: "inline"
      },
      indicator: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: "0",
        width: "1em",
        height: "1em",
        _icon: { boxSize: "full" }
      },
      content: {
        display: "flex",
        flex: "1",
        gap: "1"
      }
    },
    variants: {
      status: {
        info: {
          root: { colorPalette: "blue" }
        },
        warning: {
          root: { colorPalette: "orange" }
        },
        success: {
          root: { colorPalette: "green" }
        },
        error: {
          root: { colorPalette: "red" }
        },
        neutral: {
          root: { colorPalette: "gray" }
        }
      },
      inline: {
        true: {
          content: {
            display: "inline-flex",
            flexDirection: "row",
            alignItems: "center"
          }
        },
        false: {
          content: {
            display: "flex",
            flexDirection: "column"
          }
        }
      },
      variant: {
        subtle: {
          root: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg"
          }
        },
        surface: {
          root: {
            bg: "colorPalette.subtle",
            color: "colorPalette.fg",
            shadow: "inset 0 0 0px 1px var(--shadow-color)",
            shadowColor: "colorPalette.muted"
          },
          indicator: {
            color: "colorPalette.fg"
          }
        },
        outline: {
          root: {
            color: "colorPalette.fg",
            shadow: "inset 0 0 0px 1px var(--shadow-color)",
            "--outline-shadow-legacy": "colors.colorPalette.muted",
            "--outline-shadow": "colors.colorPalette.border",
            shadowColor: "var(--outline-shadow, var(--outline-shadow-legacy))"
          },
          indicator: {
            color: "colorPalette.fg"
          }
        },
        solid: {
          root: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          },
          indicator: {
            color: "colorPalette.contrast"
          }
        }
      },
      size: {
        sm: {
          root: {
            gap: "2",
            px: "3",
            py: "3",
            textStyle: "xs"
          },
          indicator: {
            textStyle: "lg"
          }
        },
        md: {
          root: {
            gap: "3",
            px: "4",
            py: "4",
            textStyle: "sm"
          },
          indicator: {
            textStyle: "xl"
          }
        },
        lg: {
          root: {
            gap: "3",
            px: "4",
            py: "4",
            textStyle: "md"
          },
          indicator: {
            textStyle: "2xl"
          }
        }
      }
    },
    defaultVariants: {
      status: "info",
      variant: "subtle",
      size: "md",
      inline: false
    }
  });
  const avatarSlotRecipe = defineSlotRecipe({
    slots: anatomy$p.keys(),
    className: "chakra-avatar",
    base: {
      root: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        fontWeight: "medium",
        position: "relative",
        verticalAlign: "top",
        flexShrink: "0",
        userSelect: "none",
        width: "var(--avatar-size)",
        height: "var(--avatar-size)",
        fontSize: "var(--avatar-font-size)",
        borderRadius: "var(--avatar-radius)",
        "&[data-group-item]": {
          borderWidth: "2px",
          borderColor: "bg"
        }
      },
      image: {
        width: "100%",
        height: "100%",
        objectFit: "cover",
        borderRadius: "var(--avatar-radius)"
      },
      fallback: {
        lineHeight: "1",
        textTransform: "uppercase",
        fontWeight: "medium",
        fontSize: "var(--avatar-font-size)",
        borderRadius: "var(--avatar-radius)"
      }
    },
    variants: {
      size: {
        full: {
          root: {
            "--avatar-size": "100%",
            "--avatar-font-size": "100%"
          }
        },
        "2xs": {
          root: {
            "--avatar-font-size": "fontSizes.2xs",
            "--avatar-size": "sizes.6"
          }
        },
        xs: {
          root: {
            "--avatar-font-size": "fontSizes.xs",
            "--avatar-size": "sizes.8"
          }
        },
        sm: {
          root: {
            "--avatar-font-size": "fontSizes.sm",
            "--avatar-size": "sizes.9"
          }
        },
        md: {
          root: {
            "--avatar-font-size": "fontSizes.md",
            "--avatar-size": "sizes.10"
          }
        },
        lg: {
          root: {
            "--avatar-font-size": "fontSizes.md",
            "--avatar-size": "sizes.11"
          }
        },
        xl: {
          root: {
            "--avatar-font-size": "fontSizes.lg",
            "--avatar-size": "sizes.12"
          }
        },
        "2xl": {
          root: {
            "--avatar-font-size": "fontSizes.xl",
            "--avatar-size": "sizes.16"
          }
        }
      },
      variant: {
        solid: {
          root: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        subtle: {
          root: {
            bg: "colorPalette.muted",
            color: "colorPalette.fg"
          }
        },
        outline: {
          root: {
            color: "colorPalette.fg",
            borderWidth: "1px",
            "--outline-shadow-legacy": "colors.colorPalette.muted",
            "--outline-shadow": "colors.colorPalette.border",
            borderColor: "var(--outline-shadow, var(--outline-shadow-legacy))"
          }
        }
      },
      shape: {
        square: {},
        rounded: {
          root: { "--avatar-radius": "radii.l3" }
        },
        full: {
          root: { "--avatar-radius": "radii.full" }
        }
      },
      borderless: {
        true: {
          root: {
            "&[data-group-item]": {
              borderWidth: "0px"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      shape: "full",
      variant: "subtle"
    }
  });
  const blockquoteSlotRecipe = defineSlotRecipe({
    className: "chakra-blockquote",
    slots: blockquoteAnatomy.keys(),
    base: {
      root: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        gap: "2"
      },
      caption: {
        textStyle: "sm",
        color: "fg.muted"
      },
      icon: {
        boxSize: "5"
      }
    },
    variants: {
      justify: {
        start: {
          root: {
            alignItems: "flex-start",
            textAlign: "start"
          }
        },
        center: {
          root: {
            alignItems: "center",
            textAlign: "center"
          }
        },
        end: {
          root: {
            alignItems: "flex-end",
            textAlign: "end"
          }
        }
      },
      variant: {
        subtle: {
          root: {
            paddingX: "5",
            borderStartWidth: "4px",
            borderStartColor: "colorPalette.muted"
          },
          icon: {
            color: "colorPalette.fg"
          }
        },
        solid: {
          root: {
            paddingX: "5",
            borderStartWidth: "4px",
            borderStartColor: "colorPalette.solid"
          },
          icon: {
            color: "colorPalette.solid"
          }
        },
        plain: {
          root: {
            paddingX: "5"
          },
          icon: {
            color: "colorPalette.solid"
          }
        }
      }
    },
    defaultVariants: {
      variant: "subtle",
      justify: "start"
    }
  });
  const breadcrumbSlotRecipe = defineSlotRecipe({
    className: "chakra-breadcrumb",
    slots: breadcrumbAnatomy.keys(),
    base: {
      list: {
        display: "flex",
        alignItems: "center",
        wordBreak: "break-word",
        color: "fg.muted",
        listStyle: "none"
      },
      link: {
        outline: "0",
        textDecoration: "none",
        borderRadius: "l1",
        focusRing: "outside",
        display: "inline-flex",
        alignItems: "center",
        gap: "2"
      },
      item: {
        display: "inline-flex",
        alignItems: "center"
      },
      separator: {
        color: "fg.muted",
        opacity: "0.8",
        _icon: {
          boxSize: "1em"
        },
        _rtl: {
          rotate: "180deg"
        }
      },
      ellipsis: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        _icon: {
          boxSize: "1em"
        }
      }
    },
    variants: {
      variant: {
        underline: {
          link: {
            color: "colorPalette.fg",
            textDecoration: "underline",
            textUnderlineOffset: "0.2em",
            textDecorationColor: "colorPalette.muted"
          },
          currentLink: {
            color: "colorPalette.fg"
          }
        },
        plain: {
          link: {
            color: "fg.muted",
            _hover: { color: "fg" }
          },
          currentLink: {
            color: "fg"
          }
        }
      },
      size: {
        sm: {
          list: {
            gap: "1",
            textStyle: "xs"
          }
        },
        md: {
          list: {
            gap: "1.5",
            textStyle: "sm"
          }
        },
        lg: {
          list: {
            gap: "2",
            textStyle: "md"
          }
        }
      }
    },
    defaultVariants: {
      variant: "plain",
      size: "md"
    }
  });
  const cardSlotRecipe = defineSlotRecipe({
    className: "chakra-card",
    slots: cardAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        position: "relative",
        minWidth: "0",
        wordWrap: "break-word",
        borderRadius: "l3",
        color: "fg",
        textAlign: "start"
      },
      title: {
        fontWeight: "semibold"
      },
      description: {
        color: "fg.muted",
        fontSize: "sm"
      },
      header: {
        paddingInline: "var(--card-padding)",
        paddingTop: "var(--card-padding)",
        display: "flex",
        flexDirection: "column",
        gap: "1.5"
      },
      body: {
        padding: "var(--card-padding)",
        flex: "1",
        display: "flex",
        flexDirection: "column"
      },
      footer: {
        display: "flex",
        alignItems: "center",
        gap: "2",
        paddingInline: "var(--card-padding)",
        paddingBottom: "var(--card-padding)"
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            "--card-padding": "spacing.4"
          },
          title: {
            textStyle: "md"
          }
        },
        md: {
          root: {
            "--card-padding": "spacing.6"
          },
          title: {
            textStyle: "lg"
          }
        },
        lg: {
          root: {
            "--card-padding": "spacing.7"
          },
          title: {
            textStyle: "xl"
          }
        }
      },
      variant: {
        elevated: {
          root: {
            bg: "bg.panel",
            boxShadow: "md"
          }
        },
        outline: {
          root: {
            bg: "bg.panel",
            borderWidth: "1px",
            borderColor: "border"
          }
        },
        subtle: {
          root: {
            bg: "bg.muted"
          }
        }
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md"
    }
  });
  const carouselSlotRecipe = defineSlotRecipe({
    className: "carousel",
    slots: carouselAnatomy.keys(),
    base: {
      root: {
        position: "relative",
        display: "flex",
        gap: "2",
        _horizontal: {
          flexDirection: "column"
        },
        _vertical: {
          flexDirection: "row"
        }
      },
      item: {
        _horizontal: {
          width: "100%"
        },
        _vertical: {
          height: "100%"
        }
      },
      control: {
        display: "flex",
        alignItems: "center",
        _horizontal: {
          flexDirection: "row",
          width: "100%"
        },
        _vertical: {
          flexDirection: "column",
          height: "100%"
        }
      },
      indicatorGroup: {
        display: "flex",
        justifyContent: "center",
        gap: "3",
        _horizontal: {
          flexDirection: "row"
        },
        _vertical: {
          flexDirection: "column"
        }
      },
      indicator: {
        width: "2.5",
        height: "2.5",
        borderRadius: "full",
        bg: "colorPalette.subtle",
        cursor: "button",
        _current: {
          bg: "colorPalette.solid"
        }
      }
    },
    defaultVariants: {}
  });
  const checkboxSlotRecipe = defineSlotRecipe({
    slots: checkboxAnatomy.keys(),
    className: "chakra-checkbox",
    base: {
      root: {
        display: "inline-flex",
        gap: "2",
        alignItems: "center",
        verticalAlign: "top",
        position: "relative"
      },
      control: checkmarkRecipe.base,
      label: {
        fontWeight: "medium",
        userSelect: "none",
        _disabled: {
          opacity: "0.5"
        }
      }
    },
    variants: {
      size: {
        xs: {
          root: { gap: "1.5" },
          label: { textStyle: "xs" },
          control: checkmarkRecipe.variants?.size?.xs
        },
        sm: {
          root: { gap: "2" },
          label: { textStyle: "sm" },
          control: checkmarkRecipe.variants?.size?.sm
        },
        md: {
          root: { gap: "2.5" },
          label: { textStyle: "sm" },
          control: checkmarkRecipe.variants?.size?.md
        },
        lg: {
          root: { gap: "3" },
          label: { textStyle: "md" },
          control: checkmarkRecipe.variants?.size?.lg
        }
      },
      variant: {
        outline: {
          control: checkmarkRecipe.variants?.variant?.outline
        },
        solid: {
          control: checkmarkRecipe.variants?.variant?.solid
        },
        subtle: {
          control: checkmarkRecipe.variants?.variant?.subtle
        }
      }
    },
    defaultVariants: {
      variant: "solid",
      size: "md"
    }
  });
  const checkboxCardSlotRecipe = defineSlotRecipe({
    slots: checkboxCardAnatomy.keys(),
    className: "chakra-checkbox-card",
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        userSelect: "none",
        position: "relative",
        borderRadius: "l2",
        flex: "1",
        focusVisibleRing: "outside",
        _disabled: {
          opacity: "0.8"
        },
        _invalid: {
          outline: "2px solid",
          outlineColor: "border.error"
        }
      },
      control: {
        display: "inline-flex",
        flex: "1",
        position: "relative",
        borderRadius: "inherit",
        justifyContent: "var(--checkbox-card-justify)",
        alignItems: "var(--checkbox-card-align)"
      },
      label: {
        fontWeight: "medium",
        display: "flex",
        alignItems: "center",
        gap: "2",
        flex: "1",
        _disabled: {
          opacity: "0.5"
        }
      },
      description: {
        opacity: "0.64",
        textStyle: "sm",
        _disabled: {
          opacity: "0.5"
        }
      },
      addon: {
        _disabled: {
          opacity: "0.5"
        }
      },
      indicator: checkmarkRecipe.base,
      content: {
        display: "flex",
        flexDirection: "column",
        flex: "1",
        gap: "1",
        justifyContent: "var(--checkbox-card-justify)",
        alignItems: "var(--checkbox-card-align)"
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            textStyle: "sm"
          },
          control: {
            padding: "3",
            gap: "1.5"
          },
          addon: {
            px: "3",
            py: "1.5",
            borderTopWidth: "1px"
          },
          indicator: checkmarkRecipe.variants?.size.sm
        },
        md: {
          root: {
            textStyle: "sm"
          },
          control: {
            padding: "4",
            gap: "2.5"
          },
          addon: {
            px: "4",
            py: "2",
            borderTopWidth: "1px"
          },
          indicator: checkmarkRecipe.variants?.size.md
        },
        lg: {
          root: {
            textStyle: "md"
          },
          control: {
            padding: "4",
            gap: "3.5"
          },
          addon: {
            px: "4",
            py: "2",
            borderTopWidth: "1px"
          },
          indicator: checkmarkRecipe.variants?.size.lg
        }
      },
      variant: {
        surface: {
          root: {
            borderWidth: "1px",
            borderColor: "border",
            _checked: {
              bg: "colorPalette.subtle",
              color: "colorPalette.fg",
              borderColor: "colorPalette.muted"
            },
            _disabled: {
              bg: "bg.muted"
            }
          },
          indicator: checkmarkRecipe.variants?.variant.solid
        },
        subtle: {
          root: {
            bg: "bg.muted"
          },
          control: {
            _checked: {
              bg: "colorPalette.muted",
              color: "colorPalette.fg"
            }
          },
          indicator: checkmarkRecipe.variants?.variant.plain
        },
        outline: {
          root: {
            borderWidth: "1px",
            borderColor: "border",
            _checked: {
              boxShadow: "0 0 0 1px var(--shadow-color)",
              boxShadowColor: "colorPalette.solid",
              borderColor: "colorPalette.solid"
            }
          },
          indicator: checkmarkRecipe.variants?.variant.solid
        },
        solid: {
          root: {
            borderWidth: "1px",
            _checked: {
              bg: "colorPalette.solid",
              color: "colorPalette.contrast",
              borderColor: "colorPalette.solid"
            }
          },
          indicator: checkmarkRecipe.variants?.variant.inverted
        }
      },
      justify: {
        start: {
          root: { "--checkbox-card-justify": "flex-start" }
        },
        end: {
          root: { "--checkbox-card-justify": "flex-end" }
        },
        center: {
          root: { "--checkbox-card-justify": "center" }
        }
      },
      align: {
        start: {
          root: { "--checkbox-card-align": "flex-start" },
          content: { textAlign: "start" }
        },
        end: {
          root: { "--checkbox-card-align": "flex-end" },
          content: { textAlign: "end" }
        },
        center: {
          root: { "--checkbox-card-align": "center" },
          content: { textAlign: "center" }
        }
      },
      orientation: {
        vertical: {
          control: { flexDirection: "column" }
        },
        horizontal: {
          control: { flexDirection: "row" }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline",
      align: "start",
      orientation: "horizontal"
    }
  });
  const codeBlockSlotRecipe = defineSlotRecipe({
    slots: codeBlockAnatomy.keys(),
    className: "code-block",
    base: {
      root: {
        colorPalette: "gray",
        rounded: "var(--code-block-radius)",
        overflow: "hidden",
        bg: "bg",
        color: "fg",
        borderWidth: "1px",
        "--code-block-max-height": "320px",
        "--code-block-bg": "colors.bg",
        "--code-block-fg": "colors.fg",
        "--code-block-obscured-opacity": "0.5",
        "--code-block-obscured-blur": "1px",
        "--code-block-line-number-width": "sizes.3",
        "--code-block-line-number-margin": "spacing.4",
        "--code-block-highlight-bg": "{colors.teal.focusRing/20}",
        "--code-block-highlight-border": "colors.teal.focusRing",
        "--code-block-highlight-added-bg": "{colors.green.focusRing/20}",
        "--code-block-highlight-added-border": "colors.green.focusRing",
        "--code-block-highlight-removed-bg": "{colors.red.focusRing/20}",
        "--code-block-highlight-removed-border": "colors.red.focusRing"
      },
      header: {
        display: "flex",
        alignItems: "center",
        gap: "2",
        position: "relative",
        px: "var(--code-block-padding)",
        minH: "var(--code-block-header-height)",
        mb: "calc(var(--code-block-padding) / 2 * -1)"
      },
      title: {
        display: "inline-flex",
        alignItems: "center",
        gap: "1.5",
        flex: "1",
        color: "fg.muted"
      },
      control: {
        gap: "1.5",
        display: "inline-flex",
        alignItems: "center"
      },
      footer: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "2",
        px: "var(--code-block-padding)",
        minH: "var(--code-block-header-height)"
      },
      content: {
        position: "relative",
        colorScheme: "dark",
        overflowX: "auto",
        overflowY: "hidden",
        borderBottomRadius: "var(--code-block-radius)",
        maxHeight: "var(--code-block-max-height)",
        "& ::selection": {
          bg: "blue.500/40"
        },
        _expanded: {
          maxHeight: "unset"
        }
      },
      overlay: {
        "--bg": "{colors.black/50}",
        display: "flex",
        alignItems: "flex-end",
        justifyContent: "center",
        padding: "4",
        bgImage: "linear-gradient(0deg,var(--bg) 25%,transparent 100%)",
        color: "white",
        minH: "5rem",
        pos: "absolute",
        bottom: "0",
        insetInline: "0",
        zIndex: "1",
        fontWeight: "medium",
        _expanded: {
          display: "none"
        }
      },
      code: {
        fontFamily: "mono",
        lineHeight: "tall",
        whiteSpace: "pre",
        counterReset: "line 0"
      },
      codeText: {
        px: "var(--code-block-padding)",
        py: "var(--code-block-padding)",
        position: "relative",
        display: "block",
        width: "100%",
        "&[data-has-focused]": {
          "& [data-line]:not([data-focused])": {
            transitionProperty: "opacity, filter",
            transitionDuration: "moderate",
            transitionTimingFunction: "ease-in-out",
            opacity: "var(--code-block-obscured-opacity)",
            filter: "blur(var(--code-block-obscured-blur))"
          },
          "&:hover": {
            "--code-block-obscured-opacity": "1",
            "--code-block-obscured-blur": "0px"
          }
        },
        "&[data-has-line-numbers][data-plaintext]": {
          paddingInlineStart: "calc(var(--code-block-line-number-width) + var(--code-block-line-number-margin) + var(--code-block-padding))"
        },
        "& [data-line]": {
          position: "relative",
          paddingInlineEnd: "var(--code-block-padding)",
          "--highlight-bg": "var(--code-block-highlight-bg)",
          "--highlight-border": "var(--code-block-highlight-border)",
          "&[data-highlight], &[data-diff]": {
            display: "inline-block",
            width: "full",
            "&:after": {
              content: `''`,
              display: "block",
              position: "absolute",
              top: "0",
              insetStart: "calc(var(--code-block-padding) * -1)",
              insetEnd: "0px",
              width: "calc(100% + var(--code-block-padding) * 2)",
              height: "100%",
              bg: "var(--highlight-bg)",
              borderStartWidth: "2px",
              borderStartColor: "var(--highlight-border)"
            }
          },
          "&[data-diff='added']": {
            "--highlight-bg": "var(--code-block-highlight-added-bg)",
            "--highlight-border": "var(--code-block-highlight-added-border)"
          },
          "&[data-diff='removed']": {
            "--highlight-bg": "var(--code-block-highlight-removed-bg)",
            "--highlight-border": "var(--code-block-highlight-removed-border)"
          }
        },
        "&[data-word-wrap]": {
          "&[data-plaintext], & [data-line]": {
            whiteSpace: "pre-wrap",
            wordBreak: "break-all"
          }
        },
        "&[data-has-line-numbers]": {
          "--content": "counter(line)",
          "& [data-line]:before": {
            content: "var(--content)",
            counterIncrement: "line",
            width: "var(--code-block-line-number-width)",
            marginRight: "var(--code-block-line-number-margin)",
            display: "inline-block",
            textAlign: "end",
            userSelect: "none",
            whiteSpace: "nowrap",
            opacity: 0.4
          },
          "& [data-diff='added']:before": {
            content: "'+'"
          },
          "& [data-diff='removed']:before": {
            content: "'-'"
          }
        }
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            "--code-block-padding": "spacing.4",
            "--code-block-radius": "radii.md",
            "--code-block-header-height": "sizes.8"
          },
          title: {
            textStyle: "xs"
          },
          code: {
            fontSize: "xs"
          }
        },
        md: {
          root: {
            "--code-block-padding": "spacing.4",
            "--code-block-radius": "radii.lg",
            "--code-block-header-height": "sizes.10"
          },
          title: {
            textStyle: "xs"
          },
          code: {
            fontSize: "sm"
          }
        },
        lg: {
          root: {
            "--code-block-padding": "spacing.5",
            "--code-block-radius": "radii.xl",
            "--code-block-header-height": "sizes.12"
          },
          title: {
            textStyle: "sm"
          },
          code: {
            fontSize: "sm"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const collapsibleSlotRecipe = defineSlotRecipe({
    slots: anatomy$t.keys(),
    className: "chakra-collapsible",
    base: {
      content: {
        overflow: "hidden",
        _open: {
          animationName: "expand-height, fade-in",
          animationDuration: "moderate",
          "&[data-has-collapsed-size]": {
            animationName: "expand-height"
          }
        },
        _closed: {
          animationName: "collapse-height, fade-out",
          animationDuration: "moderate",
          "&[data-has-collapsed-size]": {
            animationName: "collapse-height"
          }
        }
      }
    }
  });
  const colorPickerSlotRecipe = defineSlotRecipe({
    className: "colorPicker",
    slots: colorPickerAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5"
      },
      label: {
        color: "fg",
        fontWeight: "medium",
        textStyle: "sm",
        _disabled: {
          opacity: "0.5"
        }
      },
      valueText: {
        textAlign: "start"
      },
      control: {
        display: "flex",
        alignItems: "center",
        flexDirection: "row",
        gap: "2",
        position: "relative"
      },
      swatchTrigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      trigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexDirection: "row",
        flexShrink: "0",
        gap: "2",
        textStyle: "sm",
        minH: "var(--input-height)",
        minW: "var(--input-height)",
        px: "1",
        rounded: "l2",
        _disabled: { opacity: "0.5" },
        "--focus-color": "colors.colorPalette.focusRing",
        "&:focus-visible": {
          borderColor: "var(--focus-color)",
          outline: "1px solid var(--focus-color)"
        },
        "&[data-fit-content]": {
          "--input-height": "unset",
          px: "0",
          border: "0"
        }
      },
      content: {
        display: "flex",
        flexDirection: "column",
        bg: "bg.panel",
        borderRadius: "l3",
        boxShadow: "lg",
        width: "64",
        p: "4",
        gap: "3",
        zIndex: "dropdown",
        _open: {
          animationStyle: "slide-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "slide-fade-out",
          animationDuration: "faster"
        }
      },
      area: {
        height: "180px",
        borderRadius: "l2",
        overflow: "hidden"
      },
      areaThumb: {
        borderRadius: "full",
        height: "var(--thumb-size)",
        width: "var(--thumb-size)",
        borderWidth: "2px",
        borderColor: "white",
        shadow: "sm",
        focusVisibleRing: "mixed",
        focusRingColor: "white"
      },
      areaBackground: {
        height: "full"
      },
      channelSlider: {
        borderRadius: "l2",
        flex: "1"
      },
      channelSliderTrack: {
        height: "var(--slider-height)",
        borderRadius: "inherit",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
      },
      channelText: {
        textStyle: "xs",
        color: "fg.muted",
        fontWeight: "medium",
        textTransform: "capitalize"
      },
      swatchGroup: {
        display: "flex",
        flexDirection: "row",
        flexWrap: "wrap",
        gap: "2"
      },
      swatch: {
        ...colorSwatchRecipe.base,
        borderRadius: "l1"
      },
      swatchIndicator: {
        color: "white",
        rounded: "full"
      },
      channelSliderThumb: {
        borderRadius: "full",
        height: "var(--thumb-size)",
        width: "var(--thumb-size)",
        borderWidth: "2px",
        borderColor: "white",
        shadow: "sm",
        transform: "translate(-50%, -50%)",
        focusVisibleRing: "outside",
        focusRingOffset: "1px"
      },
      channelInput: {
        ...inputRecipe.base,
        "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button": {
          WebkitAppearance: "none",
          margin: 0
        }
      },
      formatSelect: {
        textStyle: "xs",
        textTransform: "uppercase",
        borderWidth: "1px",
        minH: "6",
        focusRing: "inside",
        rounded: "l2"
      },
      transparencyGrid: {
        borderRadius: "l2"
      },
      view: {
        display: "flex",
        flexDirection: "column",
        gap: "2"
      }
    },
    variants: {
      size: {
        "2xs": {
          channelInput: inputRecipe.variants?.size?.["2xs"],
          swatch: { "--swatch-size": "sizes.4.5" },
          trigger: { "--input-height": "sizes.7" },
          area: { "--thumb-size": "sizes.3" },
          channelSlider: {
            "--slider-height": "sizes.3",
            "--thumb-size": "sizes.3"
          }
        },
        xs: {
          channelInput: inputRecipe.variants?.size?.xs,
          swatch: { "--swatch-size": "sizes.5" },
          trigger: { "--input-height": "sizes.8" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        },
        sm: {
          channelInput: inputRecipe.variants?.size?.sm,
          swatch: { "--swatch-size": "sizes.6" },
          trigger: { "--input-height": "sizes.9" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        },
        md: {
          channelInput: inputRecipe.variants?.size?.md,
          swatch: { "--swatch-size": "sizes.7" },
          trigger: { "--input-height": "sizes.10" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        },
        lg: {
          channelInput: inputRecipe.variants?.size?.lg,
          swatch: { "--swatch-size": "sizes.7" },
          trigger: { "--input-height": "sizes.11" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        },
        xl: {
          channelInput: inputRecipe.variants?.size?.xl,
          swatch: { "--swatch-size": "sizes.8" },
          trigger: { "--input-height": "sizes.12" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        },
        "2xl": {
          channelInput: inputRecipe.variants?.size?.["2xl"],
          swatch: { "--swatch-size": "sizes.10" },
          trigger: { "--input-height": "sizes.16" },
          area: { "--thumb-size": "sizes.3.5" },
          channelSlider: {
            "--slider-height": "sizes.3.5",
            "--thumb-size": "sizes.3.5"
          }
        }
      },
      variant: {
        outline: {
          channelInput: inputRecipe.variants?.variant?.outline,
          trigger: {
            borderWidth: "1px"
          }
        },
        subtle: {
          channelInput: inputRecipe.variants?.variant?.subtle,
          trigger: {
            borderWidth: "1px",
            borderColor: "transparent",
            bg: "bg.muted"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const comboboxSlotRecipe = defineSlotRecipe({
    className: "chakra-combobox",
    slots: comboboxAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5",
        width: "full"
      },
      label: {
        fontWeight: "medium",
        userSelect: "none",
        textStyle: "sm",
        _disabled: {
          layerStyle: "disabled"
        }
      },
      control: {
        pos: "relative",
        "--padding-factor": "1",
        "--combobox-input-padding-end": "var(--combobox-input-padding-x)",
        "&:has([data-part=trigger]), &:has([data-part=clear-trigger])": {
          "--combobox-input-padding-end": "calc(var(--combobox-input-height) * var(--padding-factor))"
        },
        "&:has([data-part=trigger]):has([data-part=clear-trigger]:not([hidden]))": {
          "--padding-factor": "1.5"
        }
      },
      input: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        background: "bg.panel",
        width: "full",
        minH: "var(--combobox-input-height)",
        ps: "var(--combobox-input-padding-x)",
        pe: "var(--combobox-input-padding-end)",
        "--input-height": "var(--combobox-input-height)",
        borderRadius: "l2",
        outline: 0,
        userSelect: "none",
        textAlign: "start",
        _placeholderShown: {
          color: "fg.muted"
        },
        _disabled: {
          layerStyle: "disabled"
        },
        "--focus-color": "colors.colorPalette.focusRing",
        "--error-color": "colors.border.error",
        _invalid: {
          focusRingColor: "var(--error-color)",
          borderColor: "var(--error-color)"
        }
      },
      trigger: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        "--input-height": "var(--combobox-input-height)"
      },
      clearTrigger: {
        color: "fg.muted",
        pointerEvents: "auto",
        focusVisibleRing: "inside",
        focusRingWidth: "2px",
        rounded: "l1"
      },
      indicatorGroup: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: "1",
        pos: "absolute",
        insetEnd: "0",
        top: "0",
        bottom: "0",
        px: "var(--combobox-input-padding-x)",
        _icon: {
          boxSize: "var(--combobox-indicator-size)"
        },
        "[data-disabled] &": {
          opacity: 0.5
        }
      },
      content: {
        background: "bg.panel",
        display: "flex",
        flexDirection: "column",
        zIndex: "dropdown",
        borderRadius: "l2",
        outline: 0,
        maxH: "96",
        overflowY: "auto",
        boxShadow: "md",
        _open: {
          animationStyle: "slide-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "slide-fade-out",
          animationDuration: "0s"
        },
        "&[data-empty]:not(:has([data-scope=combobox][data-part=empty]))": {
          opacity: 0
        }
      },
      item: {
        position: "relative",
        userSelect: "none",
        display: "flex",
        alignItems: "center",
        gap: "2",
        py: "var(--combobox-item-padding-y)",
        px: "var(--combobox-item-padding-x)",
        cursor: "option",
        justifyContent: "space-between",
        flex: "1",
        textAlign: "start",
        borderRadius: "l1",
        _highlighted: {
          bg: "bg.emphasized/60"
        },
        _disabled: {
          pointerEvents: "none",
          opacity: "0.5"
        },
        _icon: {
          boxSize: "var(--combobox-indicator-size)"
        }
      },
      empty: {
        py: "var(--combobox-item-padding-y)",
        px: "var(--combobox-item-padding-x)"
      },
      itemText: {
        flex: "1"
      },
      itemGroup: {
        pb: "var(--combobox-item-padding-y)",
        _last: {
          pb: "0"
        }
      },
      itemGroupLabel: {
        fontWeight: "medium",
        py: "var(--combobox-item-padding-y)",
        px: "var(--combobox-item-padding-x)"
      }
    },
    variants: {
      variant: {
        outline: {
          input: {
            bg: "transparent",
            borderWidth: "1px",
            borderColor: "border",
            focusVisibleRing: "inside"
          }
        },
        subtle: {
          input: {
            borderWidth: "1px",
            borderColor: "transparent",
            bg: "bg.muted",
            focusVisibleRing: "inside"
          }
        },
        flushed: {
          input: {
            bg: "transparent",
            borderBottomWidth: "1px",
            borderBottomColor: "border",
            borderRadius: "0",
            px: "0",
            _focusVisible: {
              borderColor: "var(--focus-color)",
              boxShadow: "0px 1px 0px 0px var(--focus-color)"
            }
          },
          indicatorGroup: {
            px: "0"
          }
        }
      },
      size: {
        xs: {
          root: {
            "--combobox-input-height": "sizes.8",
            "--combobox-input-padding-x": "spacing.2",
            "--combobox-indicator-size": "sizes.3.5"
          },
          input: {
            textStyle: "xs"
          },
          content: {
            "--combobox-item-padding-x": "spacing.1.5",
            "--combobox-item-padding-y": "spacing.1",
            "--combobox-indicator-size": "sizes.3.5",
            p: "1",
            textStyle: "xs"
          },
          trigger: {
            textStyle: "xs",
            gap: "1"
          }
        },
        sm: {
          root: {
            "--combobox-input-height": "sizes.9",
            "--combobox-input-padding-x": "spacing.2.5",
            "--combobox-indicator-size": "sizes.4"
          },
          input: {
            textStyle: "sm"
          },
          content: {
            "--combobox-item-padding-x": "spacing.2",
            "--combobox-item-padding-y": "spacing.1.5",
            "--combobox-indicator-size": "sizes.4",
            p: "1",
            textStyle: "sm"
          },
          trigger: {
            textStyle: "sm",
            gap: "1"
          }
        },
        md: {
          root: {
            "--combobox-input-height": "sizes.10",
            "--combobox-input-padding-x": "spacing.3",
            "--combobox-indicator-size": "sizes.4"
          },
          input: {
            textStyle: "sm"
          },
          content: {
            "--combobox-item-padding-x": "spacing.2",
            "--combobox-item-padding-y": "spacing.1.5",
            "--combobox-indicator-size": "sizes.4",
            p: "1",
            textStyle: "sm"
          },
          itemIndicator: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          trigger: {
            textStyle: "sm",
            gap: "2"
          }
        },
        lg: {
          root: {
            "--combobox-input-height": "sizes.12",
            "--combobox-input-padding-x": "spacing.4",
            "--combobox-indicator-size": "sizes.5"
          },
          input: {
            textStyle: "md"
          },
          content: {
            "--combobox-item-padding-y": "spacing.2",
            "--combobox-item-padding-x": "spacing.3",
            "--combobox-indicator-size": "sizes.5",
            p: "1.5",
            textStyle: "md"
          },
          trigger: {
            textStyle: "md",
            py: "3",
            gap: "2"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const dataListSlotRecipe = defineSlotRecipe({
    slots: dataListAnatomy.keys(),
    className: "chakra-data-list",
    base: {
      itemLabel: {
        display: "flex",
        alignItems: "center",
        gap: "1"
      },
      itemValue: {
        display: "flex",
        minWidth: "0",
        flex: "1"
      }
    },
    variants: {
      orientation: {
        horizontal: {
          root: {
            display: "flex",
            flexDirection: "column"
          },
          item: {
            display: "inline-flex",
            alignItems: "center",
            gap: "4"
          },
          itemLabel: {
            minWidth: "120px"
          }
        },
        vertical: {
          root: {
            display: "flex",
            flexDirection: "column"
          },
          item: {
            display: "flex",
            flexDirection: "column",
            gap: "1"
          }
        }
      },
      size: {
        sm: {
          root: {
            gap: "3"
          },
          item: {
            textStyle: "xs"
          }
        },
        md: {
          root: {
            gap: "4"
          },
          item: {
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            gap: "5"
          },
          item: {
            textStyle: "md"
          }
        }
      },
      variant: {
        subtle: {
          itemLabel: {
            color: "fg.muted"
          }
        },
        bold: {
          itemLabel: {
            fontWeight: "medium"
          },
          itemValue: {
            color: "fg.muted"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      orientation: "vertical",
      variant: "subtle"
    }
  });
  const dialogSlotRecipe = defineSlotRecipe({
    slots: dialogAnatomy.keys(),
    className: "chakra-dialog",
    base: {
      backdrop: {
        bg: "blackAlpha.500",
        pos: "fixed",
        left: 0,
        top: 0,
        w: "100dvw",
        h: "100dvh",
        zIndex: "var(--z-index)",
        _open: {
          animationName: "fade-in",
          animationDuration: "slow"
        },
        _closed: {
          animationName: "fade-out",
          animationDuration: "moderate"
        }
      },
      positioner: {
        display: "flex",
        width: "100dvw",
        height: "100dvh",
        position: "fixed",
        left: 0,
        top: 0,
        "--dialog-z-index": "zIndex.modal",
        zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
        justifyContent: "center",
        overscrollBehaviorY: "none"
      },
      content: {
        display: "flex",
        flexDirection: "column",
        position: "relative",
        width: "100%",
        outline: 0,
        borderRadius: "l3",
        textStyle: "sm",
        my: "var(--dialog-margin, var(--dialog-base-margin))",
        "--dialog-z-index": "zIndex.modal",
        zIndex: "calc(var(--dialog-z-index) + var(--layer-index, 0))",
        bg: "bg.panel",
        boxShadow: "lg",
        _open: {
          animationDuration: "moderate"
        },
        _closed: {
          animationDuration: "faster"
        }
      },
      header: {
        display: "flex",
        gap: "2",
        flex: 0,
        px: "6",
        pt: "6",
        pb: "4"
      },
      body: {
        flex: "1",
        px: "6",
        pt: "2",
        pb: "6"
      },
      footer: {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "3",
        px: "6",
        pt: "2",
        pb: "4"
      },
      title: {
        textStyle: "lg",
        fontWeight: "semibold"
      },
      description: {
        color: "fg.muted"
      },
      closeTrigger: {
        pos: "absolute",
        top: "2",
        insetEnd: "2"
      }
    },
    variants: {
      placement: {
        center: {
          positioner: {
            alignItems: "center"
          },
          content: {
            "--dialog-base-margin": "auto",
            mx: "auto"
          }
        },
        top: {
          positioner: {
            alignItems: "flex-start"
          },
          content: {
            "--dialog-base-margin": "spacing.16",
            mx: "auto"
          }
        },
        bottom: {
          positioner: {
            alignItems: "flex-end"
          },
          content: {
            "--dialog-base-margin": "spacing.16",
            mx: "auto"
          }
        }
      },
      scrollBehavior: {
        inside: {
          positioner: {
            overflow: "hidden"
          },
          content: {
            maxH: "calc(100% - 7.5rem)"
          },
          body: {
            overflow: "auto"
          }
        },
        outside: {
          positioner: {
            overflow: "auto",
            pointerEvents: "auto"
          }
        }
      },
      size: {
        xs: {
          content: {
            maxW: "sm"
          }
        },
        sm: {
          content: {
            maxW: "md"
          }
        },
        md: {
          content: {
            maxW: "lg"
          }
        },
        lg: {
          content: {
            maxW: "2xl"
          }
        },
        xl: {
          content: {
            maxW: "4xl"
          }
        },
        cover: {
          positioner: {
            padding: "10"
          },
          content: {
            width: "100%",
            height: "100%",
            "--dialog-margin": "0"
          }
        },
        full: {
          content: {
            maxW: "100dvw",
            minH: "100dvh",
            "--dialog-margin": "0",
            borderRadius: "0"
          }
        }
      },
      motionPreset: {
        scale: {
          content: {
            _open: { animationName: "scale-in, fade-in" },
            _closed: { animationName: "scale-out, fade-out" }
          }
        },
        "slide-in-bottom": {
          content: {
            _open: { animationName: "slide-from-bottom, fade-in" },
            _closed: { animationName: "slide-to-bottom, fade-out" }
          }
        },
        "slide-in-top": {
          content: {
            _open: { animationName: "slide-from-top, fade-in" },
            _closed: { animationName: "slide-to-top, fade-out" }
          }
        },
        "slide-in-left": {
          content: {
            _open: { animationName: "slide-from-left, fade-in" },
            _closed: { animationName: "slide-to-left, fade-out" }
          }
        },
        "slide-in-right": {
          content: {
            _open: { animationName: "slide-from-right, fade-in" },
            _closed: { animationName: "slide-to-right, fade-out" }
          }
        },
        none: {}
      }
    },
    defaultVariants: {
      size: "md",
      scrollBehavior: "outside",
      placement: "top",
      motionPreset: "scale"
    }
  });
  const drawerSlotRecipe = defineSlotRecipe({
    slots: drawerAnatomy.keys(),
    className: "chakra-drawer",
    base: {
      backdrop: {
        bg: "blackAlpha.500",
        pos: "fixed",
        insetInlineStart: 0,
        top: 0,
        w: "100vw",
        h: "100dvh",
        zIndex: "overlay",
        _open: {
          animationName: "fade-in",
          animationDuration: "slow"
        },
        _closed: {
          animationName: "fade-out",
          animationDuration: "moderate"
        }
      },
      positioner: {
        display: "flex",
        width: "100vw",
        height: "100dvh",
        position: "fixed",
        insetInlineStart: 0,
        top: 0,
        zIndex: "modal",
        overscrollBehaviorY: "none"
      },
      content: {
        display: "flex",
        flexDirection: "column",
        position: "relative",
        width: "100%",
        outline: 0,
        zIndex: "modal",
        textStyle: "sm",
        maxH: "100dvh",
        color: "inherit",
        bg: "bg.panel",
        boxShadow: "lg",
        _open: {
          animationDuration: "slowest",
          animationTimingFunction: "ease-in-smooth"
        },
        _closed: {
          animationDuration: "slower",
          animationTimingFunction: "ease-in-smooth"
        }
      },
      header: {
        display: "flex",
        alignItems: "center",
        gap: "2",
        flex: 0,
        px: "6",
        pt: "6",
        pb: "4"
      },
      body: {
        px: "6",
        py: "2",
        flex: "1",
        overflow: "auto"
      },
      footer: {
        display: "flex",
        alignItems: "center",
        justifyContent: "flex-end",
        gap: "3",
        px: "6",
        pt: "2",
        pb: "4"
      },
      title: {
        flex: "1",
        textStyle: "lg",
        fontWeight: "semibold"
      },
      description: {
        color: "fg.muted"
      },
      closeTrigger: {
        pos: "absolute",
        top: "3",
        insetEnd: "2"
      }
    },
    variants: {
      size: {
        xs: {
          content: {
            maxW: "xs"
          }
        },
        sm: {
          content: {
            maxW: "md"
          }
        },
        md: {
          content: {
            maxW: "lg"
          }
        },
        lg: {
          content: {
            maxW: "2xl"
          }
        },
        xl: {
          content: {
            maxW: "4xl"
          }
        },
        full: {
          content: {
            maxW: "100vw",
            h: "100dvh"
          }
        }
      },
      placement: {
        start: {
          positioner: {
            justifyContent: "flex-start",
            alignItems: "stretch"
          },
          content: {
            _open: {
              animationName: {
                base: "slide-from-left-full, fade-in",
                _rtl: "slide-from-right-full, fade-in"
              }
            },
            _closed: {
              animationName: {
                base: "slide-to-left-full, fade-out",
                _rtl: "slide-to-right-full, fade-out"
              }
            }
          }
        },
        end: {
          positioner: {
            justifyContent: "flex-end",
            alignItems: "stretch"
          },
          content: {
            _open: {
              animationName: {
                base: "slide-from-right-full, fade-in",
                _rtl: "slide-from-left-full, fade-in"
              }
            },
            _closed: {
              animationName: {
                base: "slide-to-right-full, fade-out",
                _rtl: "slide-to-left-full, fade-out"
              }
            }
          }
        },
        top: {
          positioner: {
            justifyContent: "stretch",
            alignItems: "flex-start"
          },
          content: {
            maxW: "100%",
            _open: { animationName: "slide-from-top-full, fade-in" },
            _closed: { animationName: "slide-to-top-full, fade-out" }
          }
        },
        bottom: {
          positioner: {
            justifyContent: "stretch",
            alignItems: "flex-end"
          },
          content: {
            maxW: "100%",
            _open: { animationName: "slide-from-bottom-full, fade-in" },
            _closed: { animationName: "slide-to-bottom-full, fade-out" }
          }
        }
      },
      contained: {
        true: {
          positioner: {
            padding: "4"
          },
          content: {
            borderRadius: "l3"
          }
        }
      }
    },
    defaultVariants: {
      size: "xs",
      placement: "end"
    }
  });
  const sharedStyles = defineStyle({
    fontSize: "inherit",
    fontWeight: "inherit",
    textAlign: "inherit",
    bg: "transparent",
    borderRadius: "l2"
  });
  const editableSlotRecipe = defineSlotRecipe({
    slots: editableAnatomy.keys(),
    className: "chakra-editable",
    base: {
      root: {
        display: "inline-flex",
        alignItems: "center",
        position: "relative",
        gap: "1.5",
        width: "full"
      },
      preview: {
        ...sharedStyles,
        py: "1",
        px: "1",
        display: "inline-flex",
        alignItems: "center",
        transitionProperty: "common",
        transitionDuration: "moderate",
        cursor: "text",
        _hover: {
          bg: "bg.muted"
        },
        _disabled: {
          userSelect: "none"
        }
      },
      input: {
        ...sharedStyles,
        outline: "0",
        py: "1",
        px: "1",
        transitionProperty: "common",
        transitionDuration: "normal",
        width: "full",
        focusVisibleRing: "inside",
        focusRingWidth: "2px",
        _placeholder: { opacity: 0.6 }
      },
      control: {
        display: "inline-flex",
        alignItems: "center",
        gap: "1.5"
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            textStyle: "sm"
          },
          preview: { minH: "8" },
          input: { minH: "8" }
        },
        md: {
          root: {
            textStyle: "sm"
          },
          preview: { minH: "9" },
          input: { minH: "9" }
        },
        lg: {
          root: {
            textStyle: "md"
          },
          preview: { minH: "10" },
          input: { minH: "10" }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const emptyStateSlotRecipe = defineSlotRecipe({
    slots: emptyStateAnatomy.keys(),
    className: "chakra-empty-state",
    base: {
      root: {
        width: "full"
      },
      content: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center"
      },
      indicator: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: "fg.subtle",
        _icon: {
          boxSize: "1em"
        }
      },
      title: {
        fontWeight: "semibold"
      },
      description: {
        textStyle: "sm",
        color: "fg.muted"
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            px: "4",
            py: "6"
          },
          title: {
            textStyle: "md"
          },
          content: {
            gap: "4"
          },
          indicator: {
            textStyle: "2xl"
          }
        },
        md: {
          root: {
            px: "8",
            py: "12"
          },
          title: {
            textStyle: "lg"
          },
          content: {
            gap: "6"
          },
          indicator: {
            textStyle: "4xl"
          }
        },
        lg: {
          root: {
            px: "12",
            py: "16"
          },
          title: {
            textStyle: "xl"
          },
          content: {
            gap: "8"
          },
          indicator: {
            textStyle: "6xl"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const fieldSlotRecipe = defineSlotRecipe({
    className: "chakra-field",
    slots: fieldAnatomy.keys(),
    base: {
      requiredIndicator: {
        color: "fg.error",
        lineHeight: "1"
      },
      root: {
        display: "flex",
        width: "100%",
        position: "relative",
        gap: "1.5"
      },
      label: {
        display: "flex",
        alignItems: "center",
        textAlign: "start",
        textStyle: "sm",
        fontWeight: "medium",
        gap: "1",
        userSelect: "none",
        _disabled: {
          opacity: "0.5"
        }
      },
      errorText: {
        display: "inline-flex",
        alignItems: "center",
        fontWeight: "medium",
        gap: "1",
        color: "fg.error",
        textStyle: "xs"
      },
      helperText: {
        color: "fg.muted",
        textStyle: "xs"
      }
    },
    variants: {
      orientation: {
        vertical: {
          root: {
            flexDirection: "column",
            alignItems: "flex-start"
          }
        },
        horizontal: {
          root: {
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "space-between"
          },
          label: {
            flex: "0 0 var(--field-label-width, 80px)"
          }
        }
      }
    },
    defaultVariants: {
      orientation: "vertical"
    }
  });
  const fieldsetSlotRecipe = defineSlotRecipe({
    className: "fieldset",
    slots: fieldsetAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        width: "full"
      },
      content: {
        display: "flex",
        flexDirection: "column",
        width: "full"
      },
      legend: {
        color: "fg",
        fontWeight: "medium",
        _disabled: {
          opacity: "0.5"
        }
      },
      helperText: {
        color: "fg.muted",
        textStyle: "sm"
      },
      errorText: {
        display: "inline-flex",
        alignItems: "center",
        color: "fg.error",
        gap: "2",
        fontWeight: "medium",
        textStyle: "sm"
      }
    },
    variants: {
      size: {
        sm: {
          root: { spaceY: "2" },
          content: { gap: "1.5" },
          legend: { textStyle: "sm" }
        },
        md: {
          root: { spaceY: "4" },
          content: { gap: "4" },
          legend: { textStyle: "sm" }
        },
        lg: {
          root: { spaceY: "6" },
          content: { gap: "4" },
          legend: { textStyle: "md" }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const fileUploadSlotRecipe = defineSlotRecipe({
    className: "chakra-file-upload",
    slots: fileUploadAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "4",
        width: "100%",
        alignItems: "flex-start"
      },
      label: {
        fontWeight: "medium",
        textStyle: "sm"
      },
      dropzone: {
        background: "bg",
        borderRadius: "l3",
        borderWidth: "2px",
        borderStyle: "dashed",
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        gap: "4",
        justifyContent: "center",
        minHeight: "2xs",
        px: "3",
        py: "2",
        transition: "backgrounds",
        focusVisibleRing: "outside",
        _hover: {
          bg: "bg.subtle"
        },
        _dragging: {
          bg: "colorPalette.subtle",
          borderStyle: "solid",
          borderColor: "colorPalette.solid"
        }
      },
      dropzoneContent: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
        gap: "1",
        textStyle: "sm"
      },
      item: {
        pos: "relative",
        textStyle: "sm",
        animationName: "fade-in",
        animationDuration: "moderate",
        background: "bg",
        borderRadius: "l2",
        borderWidth: "1px",
        width: "100%",
        display: "flex",
        alignItems: "center",
        gap: "3",
        p: "4"
      },
      itemGroup: {
        width: "100%",
        display: "flex",
        flexDirection: "column",
        gap: "3",
        _empty: {
          display: "none"
        }
      },
      itemName: {
        color: "fg",
        fontWeight: "medium",
        lineClamp: "1"
      },
      itemContent: {
        display: "flex",
        flexDirection: "column",
        gap: "0.5",
        flex: "1"
      },
      itemSizeText: {
        color: "fg.muted",
        textStyle: "xs"
      },
      itemDeleteTrigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        alignSelf: "flex-start",
        boxSize: "5",
        p: "2px",
        color: "fg.muted",
        cursor: "button"
      },
      itemPreview: {
        color: "fg.muted",
        _icon: {
          boxSize: "4.5"
        }
      }
    },
    defaultVariants: {}
  });
  const hoverCardSlotRecipe = defineSlotRecipe({
    className: "chakra-hover-card",
    slots: anatomy$h.keys(),
    base: {
      content: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        textStyle: "sm",
        "--hovercard-bg": "colors.bg.panel",
        bg: "var(--hovercard-bg)",
        boxShadow: "lg",
        maxWidth: "80",
        borderRadius: "l3",
        zIndex: "popover",
        transformOrigin: "var(--transform-origin)",
        outline: "0",
        _open: {
          animationStyle: "slide-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "slide-fade-out",
          animationDuration: "faster"
        }
      },
      arrow: {
        "--arrow-size": "sizes.3",
        "--arrow-background": "var(--hovercard-bg)"
      },
      arrowTip: {
        borderTopWidth: "0.5px",
        borderLeftWidth: "0.5px"
      }
    },
    variants: {
      size: {
        xs: {
          content: {
            padding: "3"
          }
        },
        sm: {
          content: {
            padding: "4"
          }
        },
        md: {
          content: {
            padding: "5"
          }
        },
        lg: {
          content: {
            padding: "6"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const listSlotRecipe = defineSlotRecipe({
    className: "chakra-list",
    slots: listAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "var(--list-gap)",
        "& :where(ul, ol)": {
          marginTop: "var(--list-gap)"
        }
      },
      item: {
        whiteSpace: "normal",
        display: "list-item"
      },
      indicator: {
        marginEnd: "2",
        minHeight: "1lh",
        flexShrink: 0,
        display: "inline-block",
        verticalAlign: "middle"
      }
    },
    variants: {
      variant: {
        marker: {
          root: {
            listStyle: "revert"
          },
          item: {
            _marker: {
              color: "fg.subtle"
            }
          }
        },
        plain: {
          item: {
            alignItems: "flex-start",
            display: "inline-flex"
          }
        }
      },
      align: {
        center: {
          item: { alignItems: "center" }
        },
        start: {
          item: { alignItems: "flex-start" }
        },
        end: {
          item: { alignItems: "flex-end" }
        }
      }
    },
    defaultVariants: {
      variant: "marker"
    }
  });
  const listboxSlotRecipe = defineSlotRecipe({
    className: "chakra-listbox",
    slots: listboxAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5",
        width: "full"
      },
      content: {
        display: "flex",
        maxH: "96",
        p: "1",
        gap: "1",
        textStyle: "sm",
        outline: "none",
        scrollPadding: "1",
        _horizontal: {
          flexDirection: "row",
          overflowX: "auto"
        },
        _vertical: {
          flexDirection: "column",
          overflowY: "auto"
        },
        "--listbox-item-padding-x": "spacing.2",
        "--listbox-item-padding-y": "spacing.1.5"
      },
      item: {
        position: "relative",
        userSelect: "none",
        display: "flex",
        alignItems: "center",
        gap: "2",
        cursor: "pointer",
        justifyContent: "space-between",
        flex: "1",
        textAlign: "start",
        borderRadius: "l1",
        py: "var(--listbox-item-padding-y)",
        px: "var(--listbox-item-padding-x)",
        _highlighted: {
          outline: "2px solid",
          outlineColor: "border.emphasized"
        },
        _disabled: {
          pointerEvents: "none",
          opacity: "0.5"
        }
      },
      empty: {
        py: "var(--listbox-item-padding-y)",
        px: "var(--listbox-item-padding-x)"
      },
      itemText: {
        flex: "1"
      },
      itemGroup: {
        mt: "1.5",
        _first: { mt: "0" }
      },
      itemGroupLabel: {
        py: "1.5",
        px: "2",
        fontWeight: "medium"
      },
      label: {
        fontWeight: "medium",
        userSelect: "none",
        textStyle: "sm",
        _disabled: {
          layerStyle: "disabled"
        }
      },
      valueText: {
        lineClamp: "1",
        maxW: "80%"
      },
      itemIndicator: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        _icon: {
          boxSize: "4"
        }
      }
    },
    variants: {
      variant: {
        subtle: {
          content: {
            bg: "bg.panel",
            borderWidth: "1px",
            borderRadius: "l2"
          },
          item: {
            _hover: {
              bg: "bg.emphasized/60"
            },
            _selected: {
              bg: "bg.muted"
            }
          }
        },
        solid: {
          content: {
            bg: "bg.panel",
            borderWidth: "1px",
            borderRadius: "l2"
          },
          item: {
            _selected: {
              bg: "colorPalette.solid",
              color: "colorPalette.contrast"
            }
          }
        },
        plain: {}
      }
    },
    defaultVariants: {
      variant: "subtle"
    }
  });
  const menuSlotRecipe = defineSlotRecipe({
    className: "chakra-menu",
    slots: menuAnatomy.keys(),
    base: {
      content: {
        outline: 0,
        bg: "bg.panel",
        boxShadow: "lg",
        color: "fg",
        maxHeight: "var(--available-height)",
        "--menu-z-index": "zIndex.dropdown",
        zIndex: "calc(var(--menu-z-index) + var(--layer-index, 0))",
        borderRadius: "l2",
        overflow: "hidden",
        overflowY: "auto",
        _open: {
          animationStyle: "slide-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "slide-fade-out",
          animationDuration: "faster"
        }
      },
      item: {
        textDecoration: "none",
        color: "fg",
        userSelect: "none",
        borderRadius: "l1",
        width: "100%",
        display: "flex",
        cursor: "menuitem",
        alignItems: "center",
        textAlign: "start",
        position: "relative",
        flex: "0 0 auto",
        outline: 0,
        _disabled: {
          layerStyle: "disabled"
        },
        "&[data-type]": {
          ps: "8"
        }
      },
      itemText: {
        flex: "1"
      },
      itemIndicator: {
        position: "absolute",
        insetStart: "2",
        transform: "translateY(-50%)",
        top: "50%"
      },
      itemGroupLabel: {
        px: "2",
        py: "1.5",
        fontWeight: "semibold",
        textStyle: "sm"
      },
      indicator: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: "0"
      },
      itemCommand: {
        opacity: "0.6",
        textStyle: "xs",
        ms: "auto",
        ps: "4",
        letterSpacing: "widest",
        fontFamily: "inherit"
      },
      separator: {
        height: "1px",
        bg: "bg.muted",
        my: "1",
        mx: "-1"
      }
    },
    variants: {
      variant: {
        subtle: {
          item: {
            _highlighted: {
              bg: "bg.emphasized/60"
            }
          }
        },
        solid: {
          item: {
            _highlighted: {
              bg: "colorPalette.solid",
              color: "colorPalette.contrast"
            }
          }
        }
      },
      size: {
        sm: {
          content: {
            minW: "8rem",
            padding: "1",
            scrollPadding: "1"
          },
          item: {
            gap: "1",
            textStyle: "xs",
            py: "1",
            px: "1.5"
          }
        },
        md: {
          content: {
            minW: "8rem",
            padding: "1.5",
            scrollPadding: "1.5"
          },
          item: {
            gap: "2",
            textStyle: "sm",
            py: "1.5",
            px: "2"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "subtle"
    }
  });
  const selectSlotRecipe = defineSlotRecipe({
    className: "chakra-select",
    slots: selectAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5",
        width: "full"
      },
      trigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        width: "full",
        minH: "var(--select-trigger-height)",
        "--input-height": "var(--select-trigger-height)",
        px: "var(--select-trigger-padding-x)",
        borderRadius: "l2",
        userSelect: "none",
        textAlign: "start",
        focusVisibleRing: "inside",
        _placeholderShown: {
          color: "fg.muted/80"
        },
        _disabled: {
          layerStyle: "disabled"
        },
        _invalid: {
          borderColor: "border.error"
        }
      },
      indicatorGroup: {
        display: "flex",
        alignItems: "center",
        gap: "1",
        pos: "absolute",
        insetEnd: "0",
        top: "0",
        bottom: "0",
        px: "var(--select-trigger-padding-x)",
        pointerEvents: "none"
      },
      indicator: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        color: { base: "fg.muted", _disabled: "fg.subtle", _invalid: "fg.error" }
      },
      content: {
        background: "bg.panel",
        display: "flex",
        flexDirection: "column",
        zIndex: "dropdown",
        borderRadius: "l2",
        outline: 0,
        maxH: "96",
        overflowY: "auto",
        boxShadow: "md",
        _open: {
          animationStyle: "slide-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "slide-fade-out",
          animationDuration: "fastest"
        }
      },
      item: {
        position: "relative",
        userSelect: "none",
        display: "flex",
        alignItems: "center",
        gap: "2",
        cursor: "option",
        justifyContent: "space-between",
        flex: "1",
        textAlign: "start",
        borderRadius: "l1",
        _highlighted: {
          bg: "bg.emphasized/60"
        },
        _disabled: {
          pointerEvents: "none",
          opacity: "0.5"
        },
        _icon: {
          width: "4",
          height: "4"
        }
      },
      control: {
        pos: "relative"
      },
      itemText: {
        flex: "1"
      },
      itemGroup: {
        _first: { mt: "0" }
      },
      itemGroupLabel: {
        py: "1",
        fontWeight: "medium"
      },
      label: {
        fontWeight: "medium",
        userSelect: "none",
        textStyle: "sm",
        _disabled: {
          layerStyle: "disabled"
        }
      },
      valueText: {
        lineClamp: "1",
        maxW: "80%"
      },
      clearTrigger: {
        color: "fg.muted",
        pointerEvents: "auto",
        focusVisibleRing: "inside",
        focusRingWidth: "2px",
        rounded: "l1"
      }
    },
    variants: {
      variant: {
        outline: {
          trigger: {
            bg: "transparent",
            borderWidth: "1px",
            borderColor: "border",
            _expanded: {
              borderColor: "border.emphasized"
            }
          }
        },
        subtle: {
          trigger: {
            borderWidth: "1px",
            borderColor: "transparent",
            bg: "bg.muted"
          }
        }
      },
      size: {
        xs: {
          root: {
            "--select-trigger-height": "sizes.8",
            "--select-trigger-padding-x": "spacing.2"
          },
          content: {
            p: "1",
            gap: "1",
            textStyle: "xs"
          },
          trigger: {
            textStyle: "xs",
            gap: "1"
          },
          item: {
            py: "1",
            px: "2"
          },
          itemGroupLabel: {
            py: "1",
            px: "2"
          },
          indicator: {
            _icon: {
              width: "3.5",
              height: "3.5"
            }
          }
        },
        sm: {
          root: {
            "--select-trigger-height": "sizes.9",
            "--select-trigger-padding-x": "spacing.2.5"
          },
          content: {
            p: "1",
            textStyle: "sm"
          },
          trigger: {
            textStyle: "sm",
            gap: "1"
          },
          indicator: {
            _icon: {
              width: "4",
              height: "4"
            }
          },
          item: {
            py: "1",
            px: "1.5"
          },
          itemGroup: {
            mt: "1"
          },
          itemGroupLabel: {
            py: "1",
            px: "1.5"
          }
        },
        md: {
          root: {
            "--select-trigger-height": "sizes.10",
            "--select-trigger-padding-x": "spacing.3"
          },
          content: {
            p: "1",
            textStyle: "sm"
          },
          itemGroup: {
            mt: "1.5"
          },
          item: {
            py: "1.5",
            px: "2"
          },
          itemIndicator: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          itemGroupLabel: {
            py: "1.5",
            px: "2"
          },
          trigger: {
            textStyle: "sm",
            gap: "2"
          },
          indicator: {
            _icon: {
              width: "4",
              height: "4"
            }
          }
        },
        lg: {
          root: {
            "--select-trigger-height": "sizes.12",
            "--select-trigger-padding-x": "spacing.4"
          },
          content: {
            p: "1.5",
            textStyle: "md"
          },
          itemGroup: {
            mt: "2"
          },
          item: {
            py: "2",
            px: "3"
          },
          itemGroupLabel: {
            py: "2",
            px: "3"
          },
          trigger: {
            textStyle: "md",
            py: "3",
            gap: "2"
          },
          indicator: {
            _icon: {
              width: "5",
              height: "5"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const nativeSelectSlotRecipe = defineSlotRecipe({
    className: "chakra-native-select",
    slots: nativeSelectAnatomy.keys(),
    base: {
      root: {
        height: "fit-content",
        display: "flex",
        width: "100%",
        position: "relative"
      },
      field: {
        width: "100%",
        minWidth: "0",
        outline: "0",
        appearance: "none",
        borderRadius: "l2",
        "--error-color": "colors.border.error",
        "--input-height": "var(--select-field-height)",
        height: "var(--select-field-height)",
        _disabled: {
          layerStyle: "disabled"
        },
        _invalid: {
          focusRingColor: "var(--error-color)",
          borderColor: "var(--error-color)"
        },
        focusVisibleRing: "inside",
        lineHeight: "normal",
        "& > option, & > optgroup": {
          bg: "bg"
        }
      },
      indicator: {
        position: "absolute",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        pointerEvents: "none",
        top: "50%",
        transform: "translateY(-50%)",
        height: "100%",
        color: "fg.muted",
        _disabled: {
          opacity: "0.5"
        },
        _invalid: {
          color: "fg.error"
        },
        _icon: {
          width: "1em",
          height: "1em"
        }
      }
    },
    variants: {
      variant: {
        outline: {
          field: selectSlotRecipe.variants?.variant.outline.trigger
        },
        subtle: {
          field: selectSlotRecipe.variants?.variant.subtle.trigger
        },
        plain: {
          field: {
            bg: "transparent",
            color: "fg",
            focusRingWidth: "2px"
          }
        }
      },
      size: {
        xs: {
          root: {
            "--select-field-height": "sizes.8"
          },
          field: {
            textStyle: "xs",
            ps: "2",
            pe: "6"
          },
          indicator: {
            textStyle: "sm",
            insetEnd: "1.5"
          }
        },
        sm: {
          root: {
            "--select-field-height": "sizes.9"
          },
          field: {
            textStyle: "sm",
            ps: "2.5",
            pe: "8"
          },
          indicator: {
            textStyle: "md",
            insetEnd: "2"
          }
        },
        md: {
          root: {
            "--select-field-height": "sizes.10"
          },
          field: {
            textStyle: "sm",
            ps: "3",
            pe: "8"
          },
          indicator: {
            textStyle: "lg",
            insetEnd: "2"
          }
        },
        lg: {
          root: {
            "--select-field-height": "sizes.11"
          },
          field: {
            textStyle: "md",
            ps: "4",
            pe: "8"
          },
          indicator: {
            textStyle: "xl",
            insetEnd: "3"
          }
        },
        xl: {
          root: {
            "--select-field-height": "sizes.12"
          },
          field: {
            textStyle: "md",
            ps: "4.5",
            pe: "10"
          },
          indicator: {
            textStyle: "xl",
            insetEnd: "3"
          }
        }
      }
    },
    defaultVariants: selectSlotRecipe.defaultVariants
  });
  const triggerStyle = defineStyle({
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flex: "1",
    userSelect: "none",
    cursor: "button",
    lineHeight: "1",
    color: "fg.muted",
    "--stepper-base-radius": "radii.l1",
    "--stepper-radius": "calc(var(--stepper-base-radius) + 1px)",
    _icon: {
      boxSize: "1em"
    },
    _disabled: {
      opacity: "0.5"
    },
    _hover: {
      bg: "bg.muted"
    },
    _active: {
      bg: "bg.emphasized"
    }
  });
  const numberInputSlotRecipe = defineSlotRecipe({
    className: "chakra-number-input",
    slots: anatomy$d.keys(),
    base: {
      root: {
        position: "relative",
        zIndex: "0",
        isolation: "isolate"
      },
      input: {
        ...inputRecipe.base,
        verticalAlign: "top",
        pe: "calc(var(--stepper-width) + 0.5rem)"
      },
      control: {
        display: "flex",
        flexDirection: "column",
        position: "absolute",
        top: "0",
        insetEnd: "0px",
        margin: "1px",
        width: "var(--stepper-width)",
        height: "calc(100% - 2px)",
        zIndex: "1",
        borderStartWidth: "1px",
        divideY: "1px"
      },
      incrementTrigger: {
        ...triggerStyle,
        borderTopEndRadius: "var(--stepper-radius)"
      },
      decrementTrigger: {
        ...triggerStyle,
        borderBottomEndRadius: "var(--stepper-radius)"
      },
      valueText: {
        fontWeight: "medium",
        fontFeatureSettings: "pnum",
        fontVariantNumeric: "proportional-nums"
      }
    },
    variants: {
      size: {
        xs: {
          input: inputRecipe.variants.size.xs,
          control: {
            fontSize: "2xs",
            "--stepper-width": "sizes.4"
          }
        },
        sm: {
          input: inputRecipe.variants.size.sm,
          control: {
            fontSize: "xs",
            "--stepper-width": "sizes.5"
          }
        },
        md: {
          input: inputRecipe.variants.size.md,
          control: {
            fontSize: "sm",
            "--stepper-width": "sizes.6"
          }
        },
        lg: {
          input: inputRecipe.variants.size.lg,
          control: {
            fontSize: "sm",
            "--stepper-width": "sizes.6"
          }
        }
      },
      variant: mapEntries(inputRecipe.variants.variant, (key, variantStyles) => [
        key,
        { input: variantStyles }
      ])
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const { variants, defaultVariants } = inputRecipe;
  const pinInputSlotRecipe = defineSlotRecipe({
    className: "chakra-pin-input",
    slots: anatomy$c.keys(),
    base: {
      input: {
        ...inputRecipe.base,
        textAlign: "center",
        width: "var(--input-height)"
      },
      control: {
        display: "inline-flex",
        gap: "2",
        isolation: "isolate"
      }
    },
    variants: {
      size: mapEntries(variants.size, (key, value) => [
        key,
        { input: { ...value, px: "1" } }
      ]),
      variant: mapEntries(variants.variant, (key, value) => [
        key,
        { input: value }
      ]),
      attached: {
        true: {
          control: {
            gap: "0",
            spaceX: "-1px"
          },
          input: {
            _notFirst: { borderStartRadius: "0" },
            _notLast: { borderEndRadius: "0" },
            _focusVisible: { zIndex: "1" }
          }
        }
      }
    },
    defaultVariants
  });
  const popoverSlotRecipe = defineSlotRecipe({
    className: "chakra-popover",
    slots: popoverAnatomy.keys(),
    base: {
      content: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        textStyle: "sm",
        "--popover-bg": "colors.bg.panel",
        bg: "var(--popover-bg)",
        boxShadow: "lg",
        "--popover-size": "sizes.xs",
        "--popover-mobile-size": "calc(100dvw - 1rem)",
        width: {
          base: "min(var(--popover-mobile-size), var(--popover-size))",
          sm: "var(--popover-size)"
        },
        borderRadius: "l3",
        "--popover-z-index": "zIndex.popover",
        zIndex: "calc(var(--popover-z-index) + var(--layer-index, 0))",
        outline: "0",
        transformOrigin: "var(--transform-origin)",
        maxHeight: "var(--available-height)",
        _open: {
          animationStyle: "scale-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "scale-fade-out",
          animationDuration: "faster"
        }
      },
      header: {
        paddingInline: "var(--popover-padding)",
        paddingTop: "var(--popover-padding)"
      },
      body: {
        padding: "var(--popover-padding)",
        flex: "1"
      },
      footer: {
        display: "flex",
        alignItems: "center",
        paddingInline: "var(--popover-padding)",
        paddingBottom: "var(--popover-padding)"
      },
      arrow: {
        "--arrow-size": "sizes.3",
        "--arrow-background": "var(--popover-bg)"
      },
      arrowTip: {
        borderTopWidth: "1px",
        borderLeftWidth: "1px"
      }
    },
    variants: {
      size: {
        xs: {
          content: {
            "--popover-padding": "spacing.3"
          }
        },
        sm: {
          content: {
            "--popover-padding": "spacing.4"
          }
        },
        md: {
          content: {
            "--popover-padding": "spacing.5"
          }
        },
        lg: {
          content: {
            "--popover-padding": "spacing.6"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const progressSlotRecipe = defineSlotRecipe({
    slots: anatomy$a.keys(),
    className: "chakra-progress",
    base: {
      root: {
        textStyle: "sm",
        position: "relative"
      },
      track: {
        overflow: "hidden",
        position: "relative"
      },
      range: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        transitionProperty: "width, height",
        transitionDuration: "slow",
        height: "100%",
        bgColor: "var(--track-color)",
        _indeterminate: {
          "--animate-from-x": "-40%",
          "--animate-to-x": "100%",
          position: "absolute",
          willChange: "left",
          minWidth: "50%",
          animation: "position 1s ease infinite normal none running",
          backgroundImage: `linear-gradient(to right, transparent 0%, var(--track-color) 50%, transparent 100%)`
        }
      },
      label: {
        display: "inline-flex",
        fontWeight: "medium",
        alignItems: "center",
        gap: "1"
      },
      valueText: {
        textStyle: "xs",
        lineHeight: "1",
        fontWeight: "medium"
      }
    },
    variants: {
      variant: {
        outline: {
          track: {
            shadow: "inset",
            bgColor: "bg.muted"
          },
          range: {
            bgColor: "colorPalette.solid"
          }
        },
        subtle: {
          track: {
            bgColor: "colorPalette.muted"
          },
          range: {
            bgColor: "colorPalette.solid/72"
          }
        }
      },
      shape: {
        square: {},
        rounded: {
          track: {
            borderRadius: "l1"
          }
        },
        full: {
          track: {
            borderRadius: "full"
          }
        }
      },
      striped: {
        true: {
          range: {
            backgroundImage: `linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent)`,
            backgroundSize: `var(--stripe-size) var(--stripe-size)`,
            "--stripe-size": "1rem",
            "--stripe-color": {
              _light: "rgba(255, 255, 255, 0.3)",
              _dark: "rgba(0, 0, 0, 0.3)"
            }
          }
        }
      },
      animated: {
        true: {
          range: {
            "--animate-from": "var(--stripe-size)",
            animation: "bg-position 1s linear infinite"
          }
        }
      },
      size: {
        xs: {
          track: { h: "1.5" }
        },
        sm: {
          track: { h: "2" }
        },
        md: {
          track: { h: "2.5" }
        },
        lg: {
          track: { h: "3" }
        },
        xl: {
          track: { h: "4" }
        }
      }
    },
    defaultVariants: {
      variant: "outline",
      size: "md",
      shape: "rounded"
    }
  });
  const progressCircleSlotRecipe = defineSlotRecipe({
    className: "chakra-progress-circle",
    slots: anatomy$a.keys(),
    base: {
      root: {
        display: "inline-flex",
        textStyle: "sm",
        position: "relative"
      },
      circle: {
        _indeterminate: {
          animation: "spin 2s linear infinite"
        }
      },
      circleTrack: {
        "--track-color": "colors.colorPalette.muted",
        stroke: "var(--track-color)"
      },
      circleRange: {
        stroke: "colorPalette.solid",
        transitionProperty: "stroke-dashoffset, stroke-dasharray",
        transitionDuration: "0.6s",
        _indeterminate: {
          animation: "circular-progress 1.5s linear infinite"
        }
      },
      label: {
        display: "inline-flex"
      },
      valueText: {
        lineHeight: "1",
        fontWeight: "medium",
        letterSpacing: "tight",
        fontVariantNumeric: "tabular-nums"
      }
    },
    variants: {
      size: {
        xs: {
          circle: {
            "--size": "24px",
            "--thickness": "4px"
          },
          valueText: {
            textStyle: "2xs"
          }
        },
        sm: {
          circle: {
            "--size": "32px",
            "--thickness": "5px"
          },
          valueText: {
            textStyle: "2xs"
          }
        },
        md: {
          circle: {
            "--size": "40px",
            "--thickness": "6px"
          },
          valueText: {
            textStyle: "xs"
          }
        },
        lg: {
          circle: {
            "--size": "48px",
            "--thickness": "7px"
          },
          valueText: {
            textStyle: "sm"
          }
        },
        xl: {
          circle: {
            "--size": "64px",
            "--thickness": "8px"
          },
          valueText: {
            textStyle: "sm"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const qrCodeSlotRecipe = defineSlotRecipe({
    slots: anatomy$9.keys(),
    className: "chakra-qr-code",
    base: {
      root: {
        position: "relative",
        width: "fit-content",
        "--qr-code-overlay-size": "calc(var(--qr-code-size) / 3)"
      },
      frame: {
        width: "var(--qr-code-size)",
        height: "var(--qr-code-size)",
        fill: "currentColor"
      },
      overlay: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        width: "var(--qr-code-overlay-size)",
        height: "var(--qr-code-overlay-size)",
        padding: "1",
        bg: "bg",
        rounded: "l1"
      }
    },
    variants: {
      size: {
        "2xs": {
          root: { "--qr-code-size": "40px" }
        },
        xs: {
          root: { "--qr-code-size": "64px" }
        },
        sm: {
          root: { "--qr-code-size": "80px" }
        },
        md: {
          root: { "--qr-code-size": "120px" }
        },
        lg: {
          root: { "--qr-code-size": "160px" }
        },
        xl: {
          root: { "--qr-code-size": "200px" }
        },
        "2xl": {
          root: { "--qr-code-size": "240px" }
        },
        full: {
          root: { "--qr-code-size": "100%" }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const radioCardSlotRecipe = defineSlotRecipe({
    className: "chakra-radio-card",
    slots: radioCardAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5",
        isolation: "isolate"
      },
      item: {
        flex: "1",
        display: "flex",
        flexDirection: "column",
        userSelect: "none",
        position: "relative",
        borderRadius: "l2",
        _focus: {
          bg: "colorPalette.muted/20"
        },
        _disabled: {
          opacity: "0.8",
          borderColor: "border.disabled"
        },
        _checked: {
          zIndex: "1"
        }
      },
      label: {
        display: "inline-flex",
        fontWeight: "medium",
        textStyle: "sm",
        _disabled: {
          opacity: "0.5"
        }
      },
      itemText: {
        fontWeight: "medium",
        flex: "1"
      },
      itemDescription: {
        opacity: "0.64",
        textStyle: "sm"
      },
      itemControl: {
        display: "inline-flex",
        flex: "1",
        pos: "relative",
        rounded: "inherit",
        justifyContent: "var(--radio-card-justify)",
        alignItems: "var(--radio-card-align)",
        _disabled: {
          bg: "bg.muted"
        }
      },
      itemIndicator: radiomarkRecipe.base,
      itemAddon: {
        roundedBottom: "inherit",
        _disabled: {
          color: "fg.muted"
        }
      },
      itemContent: {
        display: "flex",
        flexDirection: "column",
        flex: "1",
        gap: "1",
        justifyContent: "var(--radio-card-justify)",
        alignItems: "var(--radio-card-align)"
      }
    },
    variants: {
      size: {
        sm: {
          item: {
            textStyle: "sm"
          },
          itemControl: {
            padding: "3",
            gap: "1.5"
          },
          itemAddon: {
            px: "3",
            py: "1.5",
            borderTopWidth: "1px"
          },
          itemIndicator: radiomarkRecipe.variants?.size.sm
        },
        md: {
          item: {
            textStyle: "sm"
          },
          itemControl: {
            padding: "4",
            gap: "2.5"
          },
          itemAddon: {
            px: "4",
            py: "2",
            borderTopWidth: "1px"
          },
          itemIndicator: radiomarkRecipe.variants?.size.md
        },
        lg: {
          item: {
            textStyle: "md"
          },
          itemControl: {
            padding: "4",
            gap: "3.5"
          },
          itemAddon: {
            px: "4",
            py: "2",
            borderTopWidth: "1px"
          },
          itemIndicator: radiomarkRecipe.variants?.size.lg
        }
      },
      variant: {
        surface: {
          item: {
            borderWidth: "1px",
            _checked: {
              bg: "colorPalette.subtle",
              color: "colorPalette.fg",
              borderColor: "colorPalette.muted"
            }
          },
          itemIndicator: radiomarkRecipe.variants?.variant.solid
        },
        subtle: {
          item: {
            bg: "bg.muted"
          },
          itemControl: {
            _checked: {
              bg: "colorPalette.muted",
              color: "colorPalette.fg"
            }
          },
          itemIndicator: radiomarkRecipe.variants?.variant.outline
        },
        outline: {
          item: {
            borderWidth: "1px",
            _checked: {
              boxShadow: "0 0 0 1px var(--shadow-color)",
              boxShadowColor: "colorPalette.solid",
              borderColor: "colorPalette.solid"
            }
          },
          itemIndicator: radiomarkRecipe.variants?.variant.solid
        },
        solid: {
          item: {
            borderWidth: "1px",
            _checked: {
              bg: "colorPalette.solid",
              color: "colorPalette.contrast",
              borderColor: "colorPalette.solid"
            }
          },
          itemIndicator: radiomarkRecipe.variants?.variant.inverted
        }
      },
      justify: {
        start: {
          item: { "--radio-card-justify": "flex-start" }
        },
        end: {
          item: { "--radio-card-justify": "flex-end" }
        },
        center: {
          item: { "--radio-card-justify": "center" }
        }
      },
      align: {
        start: {
          item: { "--radio-card-align": "flex-start" },
          itemControl: { textAlign: "start" }
        },
        end: {
          item: { "--radio-card-align": "flex-end" },
          itemControl: { textAlign: "end" }
        },
        center: {
          item: { "--radio-card-align": "center" },
          itemControl: { textAlign: "center" }
        }
      },
      orientation: {
        vertical: {
          itemControl: { flexDirection: "column" }
        },
        horizontal: {
          itemControl: { flexDirection: "row" }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline",
      align: "start",
      orientation: "horizontal"
    }
  });
  const radioGroupSlotRecipe = defineSlotRecipe({
    className: "chakra-radio-group",
    slots: radioGroupAnatomy.keys(),
    base: {
      item: {
        display: "inline-flex",
        alignItems: "center",
        position: "relative",
        fontWeight: "medium",
        _disabled: {
          cursor: "disabled"
        }
      },
      itemControl: radiomarkRecipe.base,
      label: {
        userSelect: "none",
        textStyle: "sm",
        _disabled: {
          opacity: "0.5"
        }
      }
    },
    variants: {
      variant: {
        outline: {
          itemControl: radiomarkRecipe.variants?.variant?.outline
        },
        subtle: {
          itemControl: radiomarkRecipe.variants?.variant?.subtle
        },
        solid: {
          itemControl: radiomarkRecipe.variants?.variant?.solid
        }
      },
      size: {
        xs: {
          item: { textStyle: "xs", gap: "1.5" },
          itemControl: radiomarkRecipe.variants?.size?.xs
        },
        sm: {
          item: { textStyle: "sm", gap: "2" },
          itemControl: radiomarkRecipe.variants?.size?.sm
        },
        md: {
          item: { textStyle: "sm", gap: "2.5" },
          itemControl: radiomarkRecipe.variants?.size?.md
        },
        lg: {
          item: { textStyle: "md", gap: "3" },
          itemControl: radiomarkRecipe.variants?.size?.lg
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "solid"
    }
  });
  const ratingGroupSlotRecipe = defineSlotRecipe({
    className: "chakra-rating-group",
    slots: ratingGroupAnatomy.keys(),
    base: {
      root: {
        display: "inline-flex"
      },
      control: {
        display: "inline-flex",
        alignItems: "center"
      },
      item: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        userSelect: "none"
      },
      itemIndicator: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        width: "1em",
        height: "1em",
        position: "relative",
        "--clip-path": { base: "inset(0 50% 0 0)", _rtl: "inset(0 0 0 50%)" },
        _icon: {
          stroke: "currentColor",
          width: "100%",
          height: "100%",
          display: "inline-block",
          flexShrink: 0,
          position: "absolute",
          left: 0,
          top: 0
        },
        "& [data-bg]": {
          color: "bg.emphasized"
        },
        "& [data-fg]": {
          color: "transparent"
        },
        "&[data-highlighted]:not([data-half])": {
          "& [data-fg]": {
            color: "colorPalette.solid"
          }
        },
        "&[data-half]": {
          "& [data-fg]": {
            color: "colorPalette.solid",
            clipPath: "var(--clip-path)"
          }
        }
      }
    },
    variants: {
      size: {
        xs: {
          item: {
            textStyle: "sm"
          }
        },
        sm: {
          item: {
            textStyle: "md"
          }
        },
        md: {
          item: {
            textStyle: "xl"
          }
        },
        lg: {
          item: {
            textStyle: "2xl"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const scrollAreaSlotRecipe = defineSlotRecipe({
    className: "chakra-scroll-area",
    slots: anatomy$6.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%",
        position: "relative",
        overflow: "hidden",
        "--scrollbar-margin": "2px",
        "--scrollbar-click-area": "calc(var(--scrollbar-size) + calc(var(--scrollbar-margin) * 2))"
      },
      viewport: {
        display: "flex",
        flexDirection: "column",
        height: "100%",
        width: "100%",
        borderRadius: "inherit",
        WebkitOverflowScrolling: "touch",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
        }
      },
      content: {
        minWidth: "100%"
      },
      scrollbar: {
        display: "flex",
        userSelect: "none",
        touchAction: "none",
        borderRadius: "full",
        colorPalette: "gray",
        transition: "opacity 150ms 300ms",
        position: "relative",
        margin: "var(--scrollbar-margin)",
        "&:not([data-overflow-x], [data-overflow-y])": {
          display: "none"
        },
        bg: "{colors.colorPalette.solid/10}",
        "--thumb-bg": "{colors.colorPalette.solid/25}",
        "&:is(:hover, :active)": {
          "--thumb-bg": "{colors.colorPalette.solid/50}"
        },
        _before: {
          content: '""',
          position: "absolute"
        },
        _vertical: {
          width: "var(--scrollbar-size)",
          flexDirection: "column",
          "&::before": {
            width: "var(--scrollbar-click-area)",
            height: "100%",
            insetInlineStart: "calc(var(--scrollbar-margin) * -1)"
          }
        },
        _horizontal: {
          height: "var(--scrollbar-size)",
          flexDirection: "row",
          "&::before": {
            height: "var(--scrollbar-click-area)",
            width: "100%",
            top: "calc(var(--scrollbar-margin) * -1)"
          }
        }
      },
      thumb: {
        borderRadius: "inherit",
        bg: "var(--thumb-bg)",
        transition: "backgrounds",
        _vertical: { width: "full" },
        _horizontal: { height: "full" }
      },
      corner: {
        bg: "bg.muted",
        margin: "var(--scrollbar-margin)",
        opacity: 0,
        transition: "opacity 150ms 300ms",
        "&[data-hover]": {
          transitionDelay: "0ms",
          opacity: 1
        }
      }
    },
    variants: {
      variant: {
        hover: {
          scrollbar: {
            opacity: "0",
            "&[data-hover], &[data-scrolling]": {
              opacity: "1",
              transitionDuration: "faster",
              transitionDelay: "0ms"
            }
          }
        },
        always: {
          scrollbar: {
            opacity: "1"
          }
        }
      },
      size: {
        xs: {
          root: {
            "--scrollbar-size": "sizes.1"
          }
        },
        sm: {
          root: {
            "--scrollbar-size": "sizes.1.5"
          }
        },
        md: {
          root: {
            "--scrollbar-size": "sizes.2"
          }
        },
        lg: {
          root: {
            "--scrollbar-size": "sizes.3"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "hover"
    }
  });
  const segmentGroupSlotRecipe = defineSlotRecipe({
    className: "chakra-segment-group",
    slots: segmentGroupAnatomy.keys(),
    base: {
      root: {
        "--segment-radius": "radii.l2",
        "--segment-indicator-bg": {
          _light: "colors.bg",
          _dark: "colors.bg.emphasized"
        },
        "--segment-indicator-shadow": "shadows.sm",
        borderRadius: "var(--segment-radius)",
        display: "inline-flex",
        boxShadow: "inset",
        minW: "max-content",
        textAlign: "center",
        position: "relative",
        isolation: "isolate",
        bg: "bg.muted",
        _vertical: {
          flexDirection: "column"
        }
      },
      item: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        userSelect: "none",
        fontSize: "sm",
        position: "relative",
        color: "fg",
        borderRadius: "var(--segment-radius)",
        _disabled: {
          opacity: "0.5"
        },
        "&:has(input:focus-visible)": {
          focusRing: "outside"
        },
        _before: {
          content: '""',
          position: "absolute",
          bg: "border",
          transition: "opacity 0.2s"
        },
        _horizontal: {
          _before: {
            insetInlineStart: 0,
            insetBlock: "1.5",
            width: "1px"
          }
        },
        _vertical: {
          _before: {
            insetBlockStart: 0,
            insetInline: "1.5",
            height: "1px"
          }
        },
        "& + &[data-state=checked], &[data-state=checked] + &, &:first-of-type": {
          _before: {
            opacity: "0"
          }
        },
        "&[data-state=checked][data-ssr]": {
          shadow: "sm",
          bg: "bg",
          borderRadius: "var(--segment-radius)"
        }
      },
      indicator: {
        shadow: "var(--segment-indicator-shadow)",
        pos: "absolute",
        bg: "var(--segment-indicator-bg)",
        width: "var(--width)",
        height: "var(--height)",
        top: "var(--top)",
        left: "var(--left)",
        zIndex: -1,
        borderRadius: "var(--segment-radius)"
      }
    },
    variants: {
      size: {
        xs: {
          item: {
            textStyle: "xs",
            px: "3",
            gap: "1",
            height: "6"
          }
        },
        sm: {
          item: {
            textStyle: "sm",
            px: "4",
            gap: "2",
            height: "8"
          }
        },
        md: {
          item: {
            textStyle: "sm",
            px: "4",
            gap: "2",
            height: "10"
          }
        },
        lg: {
          item: {
            textStyle: "md",
            px: "4.5",
            gap: "3",
            height: "11"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const sliderSlotRecipe = defineSlotRecipe({
    className: "chakra-slider",
    slots: sliderAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1",
        textStyle: "sm",
        position: "relative",
        isolation: "isolate",
        touchAction: "none"
      },
      label: {
        fontWeight: "medium",
        textStyle: "sm"
      },
      control: {
        display: "inline-flex",
        alignItems: "center",
        position: "relative"
      },
      track: {
        overflow: "hidden",
        borderRadius: "full",
        flex: "1"
      },
      range: {
        width: "inherit",
        height: "inherit",
        _disabled: { bg: "border.emphasized!" }
      },
      markerGroup: {
        position: "absolute!",
        zIndex: "1"
      },
      marker: {
        "--marker-bg": { base: "white", _underValue: "colors.bg" },
        display: "flex",
        alignItems: "center",
        gap: "calc(var(--slider-thumb-size) / 2)",
        color: "fg.muted",
        textStyle: "xs"
      },
      markerIndicator: {
        width: "var(--slider-marker-size)",
        height: "var(--slider-marker-size)",
        borderRadius: "full",
        bg: "var(--marker-bg)"
      },
      thumb: {
        width: "var(--slider-thumb-size)",
        height: "var(--slider-thumb-size)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        outline: 0,
        zIndex: "2",
        borderRadius: "full",
        _focusVisible: {
          ring: "2px",
          ringColor: "colorPalette.focusRing",
          ringOffset: "2px",
          ringOffsetColor: "bg"
        }
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            "--slider-thumb-size": "sizes.4",
            "--slider-track-size": "sizes.1.5",
            "--slider-marker-center": "6px",
            "--slider-marker-size": "sizes.1",
            "--slider-marker-inset": "3px"
          }
        },
        md: {
          root: {
            "--slider-thumb-size": "sizes.5",
            "--slider-track-size": "sizes.2",
            "--slider-marker-center": "8px",
            "--slider-marker-size": "sizes.1",
            "--slider-marker-inset": "4px"
          }
        },
        lg: {
          root: {
            "--slider-thumb-size": "sizes.6",
            "--slider-track-size": "sizes.2.5",
            "--slider-marker-center": "9px",
            "--slider-marker-size": "sizes.1.5",
            "--slider-marker-inset": "5px"
          }
        }
      },
      variant: {
        outline: {
          track: {
            shadow: "inset",
            bg: "bg.emphasized/72"
          },
          range: {
            bg: "colorPalette.solid"
          },
          thumb: {
            borderWidth: "2px",
            borderColor: "colorPalette.solid",
            bg: "bg",
            _disabled: {
              bg: "border.emphasized",
              borderColor: "border.emphasized"
            }
          }
        },
        solid: {
          track: {
            bg: "colorPalette.subtle",
            _disabled: {
              bg: "bg.muted"
            }
          },
          range: {
            bg: "colorPalette.solid"
          },
          thumb: {
            bg: "colorPalette.solid",
            _disabled: {
              bg: "border.emphasized"
            }
          }
        }
      },
      orientation: {
        vertical: {
          root: {
            display: "inline-flex"
          },
          control: {
            flexDirection: "column",
            height: "100%",
            minWidth: "var(--slider-thumb-size)",
            "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
              marginEnd: "4"
            }
          },
          track: {
            width: "var(--slider-track-size)"
          },
          thumb: {
            left: "50%",
            translate: "-50% 0"
          },
          markerGroup: {
            insetStart: "var(--slider-marker-center)",
            insetBlock: "var(--slider-marker-inset)"
          },
          marker: {
            flexDirection: "row"
          }
        },
        horizontal: {
          control: {
            flexDirection: "row",
            width: "100%",
            minHeight: "var(--slider-thumb-size)",
            "&[data-has-mark-label], &:has(.chakra-slider__marker-label)": {
              marginBottom: "4"
            }
          },
          track: {
            height: "var(--slider-track-size)"
          },
          thumb: {
            top: "50%",
            translate: "0 -50%"
          },
          markerGroup: {
            top: "var(--slider-marker-center)",
            insetInline: "var(--slider-marker-inset)"
          },
          marker: {
            flexDirection: "column"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline",
      orientation: "horizontal"
    }
  });
  const splitterSlotRecipe = defineSlotRecipe({
    slots: splitterAnatomy.keys(),
    className: "splitter",
    base: {
      resizeTrigger: {
        "--splitter-border-color": "colors.border",
        "--splitter-thumb-color": "colors.bg",
        "--splitter-thumb-size": "sizes.2",
        "--splitter-thumb-inset": "calc(var(--splitter-thumb-size) * -0.5)",
        "--splitter-border-size": "1px",
        "--splitter-handle-size": "sizes.6",
        outline: "0",
        display: "grid",
        placeItems: "center",
        position: "relative",
        _focus: {
          "--splitter-border-color": "colors.border.emphasized",
          "--splitter-thumb-color": "colors.colorPalette.subtle"
        },
        _dragging: {
          "--splitter-thumb-color": "colors.colorPalette.focusRing"
        },
        _horizontal: {
          minWidth: "var(--splitter-thumb-size)",
          marginInline: "var(--splitter-thumb-inset)"
        },
        _vertical: {
          minHeight: "var(--splitter-thumb-size)",
          marginBlock: "var(--splitter-thumb-inset)"
        }
      },
      resizeTriggerSeparator: {
        position: "absolute",
        bg: "var(--splitter-border-color)",
        "[data-part='resize-trigger'][data-orientation=horizontal] &": {
          insetInlineEnd: "calc(var(--splitter-thumb-size) * 0.5)",
          insetBlock: "0",
          insetInlineStart: "auto",
          w: "var(--splitter-border-size)"
        },
        "[data-part='resize-trigger'][data-orientation=vertical] &": {
          insetBlockEnd: "calc(var(--splitter-thumb-size) * 0.5)",
          insetInline: "0",
          insetBlockStart: "auto",
          h: "var(--splitter-border-size)"
        }
      },
      resizeTriggerIndicator: {
        position: "relative",
        rounded: "full",
        bg: "var(--splitter-thumb-color)",
        shadow: "xs",
        borderWidth: "1px",
        zIndex: "1",
        "[data-part='resize-trigger'][data-orientation=horizontal] &": {
          w: "full",
          h: "var(--splitter-handle-size)"
        },
        "[data-part='resize-trigger'][data-orientation=vertical] &": {
          w: "var(--splitter-handle-size)",
          h: "full"
        },
        "[data-part='resize-trigger'][data-focus]:focus-visible &": {
          outlineWidth: "2px",
          outlineColor: "colorPalette.focusRing",
          outlineStyle: "solid"
        },
        "[data-part='resize-trigger'][data-disabled] &": {
          visibility: "hidden"
        }
      }
    }
  });
  const statSlotRecipe = defineSlotRecipe({
    className: "chakra-stat",
    slots: statAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1",
        position: "relative",
        flex: "1"
      },
      label: {
        display: "inline-flex",
        gap: "1.5",
        alignItems: "center",
        color: "fg.muted",
        textStyle: "sm"
      },
      helpText: {
        color: "fg.muted",
        textStyle: "xs"
      },
      valueUnit: {
        color: "fg.muted",
        textStyle: "xs",
        fontWeight: "initial",
        letterSpacing: "initial"
      },
      valueText: {
        verticalAlign: "baseline",
        fontWeight: "semibold",
        letterSpacing: "tight",
        fontFeatureSettings: "pnum",
        fontVariantNumeric: "proportional-nums",
        display: "inline-flex",
        gap: "1"
      },
      indicator: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        marginEnd: 1,
        "& :where(svg)": {
          w: "1em",
          h: "1em"
        },
        "&[data-type=up]": {
          color: "fg.success"
        },
        "&[data-type=down]": {
          color: "fg.error"
        }
      }
    },
    variants: {
      size: {
        sm: {
          valueText: {
            textStyle: "xl"
          }
        },
        md: {
          valueText: {
            textStyle: "2xl"
          }
        },
        lg: {
          valueText: {
            textStyle: "3xl"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const statusSlotRecipe = defineSlotRecipe({
    className: "chakra-status",
    slots: statusAnatomy.keys(),
    base: {
      root: {
        display: "inline-flex",
        alignItems: "center",
        gap: "2"
      },
      indicator: {
        width: "0.64em",
        height: "0.64em",
        flexShrink: 0,
        borderRadius: "full",
        forcedColorAdjust: "none",
        bg: "colorPalette.solid"
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            textStyle: "xs"
          }
        },
        md: {
          root: {
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            textStyle: "md"
          }
        }
      }
    },
    defaultVariants: {
      size: "md"
    }
  });
  const stepsSlotRecipe = defineSlotRecipe({
    className: "chakra-steps",
    slots: stepsAnatomy.keys(),
    base: {
      root: {
        display: "flex",
        width: "full"
      },
      list: {
        display: "flex",
        justifyContent: "space-between",
        "--steps-gutter": "spacing.3",
        "--steps-thickness": "2px"
      },
      title: {
        fontWeight: "medium",
        color: "fg"
      },
      description: {
        color: "fg.muted"
      },
      separator: {
        bg: "border",
        flex: "1"
      },
      indicator: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flexShrink: "0",
        borderRadius: "full",
        fontWeight: "medium",
        width: "var(--steps-size)",
        height: "var(--steps-size)",
        _icon: {
          flexShrink: "0",
          width: "var(--steps-icon-size)",
          height: "var(--steps-icon-size)"
        }
      },
      item: {
        position: "relative",
        display: "flex",
        gap: "3",
        flex: "1 0 0",
        "&:last-of-type": {
          flex: "initial",
          "& [data-part=separator]": {
            display: "none"
          }
        }
      },
      trigger: {
        display: "flex",
        alignItems: "center",
        gap: "3",
        textAlign: "start",
        focusVisibleRing: "outside",
        borderRadius: "l2"
      },
      content: {
        focusVisibleRing: "outside"
      }
    },
    variants: {
      orientation: {
        vertical: {
          root: {
            flexDirection: "row",
            height: "100%"
          },
          list: {
            flexDirection: "column",
            alignItems: "flex-start"
          },
          separator: {
            position: "absolute",
            width: "var(--steps-thickness)",
            height: "100%",
            maxHeight: "calc(100% - var(--steps-size) - var(--steps-gutter) * 2)",
            top: "calc(var(--steps-size) + var(--steps-gutter))",
            insetStart: "calc(var(--steps-size) / 2 - 1px)"
          },
          item: {
            alignItems: "flex-start"
          }
        },
        horizontal: {
          root: {
            flexDirection: "column",
            width: "100%"
          },
          list: {
            flexDirection: "row",
            alignItems: "center"
          },
          separator: {
            width: "100%",
            height: "var(--steps-thickness)",
            marginX: "var(--steps-gutter)"
          },
          item: {
            alignItems: "center"
          }
        }
      },
      variant: {
        solid: {
          indicator: {
            _incomplete: {
              borderWidth: "var(--steps-thickness)"
            },
            _current: {
              bg: "colorPalette.muted",
              borderWidth: "var(--steps-thickness)",
              borderColor: "colorPalette.solid",
              color: "colorPalette.fg"
            },
            _complete: {
              bg: "colorPalette.solid",
              borderColor: "colorPalette.solid",
              color: "colorPalette.contrast"
            }
          },
          separator: {
            _complete: {
              bg: "colorPalette.solid"
            }
          }
        },
        subtle: {
          indicator: {
            _incomplete: {
              bg: "bg.muted"
            },
            _current: {
              bg: "colorPalette.muted",
              color: "colorPalette.fg"
            },
            _complete: {
              bg: "colorPalette.emphasized",
              color: "colorPalette.fg"
            }
          },
          separator: {
            _complete: {
              bg: "colorPalette.emphasized"
            }
          }
        }
      },
      size: {
        xs: {
          root: {
            gap: "2.5"
          },
          list: {
            "--steps-size": "sizes.6",
            "--steps-icon-size": "sizes.3.5",
            textStyle: "xs"
          },
          title: {
            textStyle: "sm"
          }
        },
        sm: {
          root: {
            gap: "3"
          },
          list: {
            "--steps-size": "sizes.8",
            "--steps-icon-size": "sizes.4",
            textStyle: "xs"
          },
          title: {
            textStyle: "sm"
          }
        },
        md: {
          root: {
            gap: "4"
          },
          list: {
            "--steps-size": "sizes.10",
            "--steps-icon-size": "sizes.4",
            textStyle: "sm"
          },
          title: {
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            gap: "6"
          },
          list: {
            "--steps-size": "sizes.11",
            "--steps-icon-size": "sizes.5",
            textStyle: "md"
          },
          title: {
            textStyle: "md"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "solid",
      orientation: "horizontal"
    }
  });
  const switchSlotRecipe = defineSlotRecipe({
    slots: switchAnatomy.keys(),
    className: "chakra-switch",
    base: {
      root: {
        display: "inline-flex",
        gap: "2.5",
        alignItems: "center",
        position: "relative",
        verticalAlign: "middle",
        "--switch-diff": "calc(var(--switch-width) - var(--switch-height))",
        "--switch-x": {
          base: "var(--switch-diff)",
          _rtl: "calc(var(--switch-diff) * -1)"
        }
      },
      label: {
        lineHeight: "1",
        userSelect: "none",
        fontSize: "sm",
        fontWeight: "medium",
        _disabled: {
          opacity: "0.5"
        }
      },
      indicator: {
        position: "absolute",
        height: "var(--switch-height)",
        width: "var(--switch-height)",
        fontSize: "var(--switch-indicator-font-size)",
        fontWeight: "medium",
        flexShrink: 0,
        userSelect: "none",
        display: "grid",
        placeContent: "center",
        transition: "inset-inline-start 0.12s ease",
        insetInlineStart: "calc(var(--switch-x) - 2px)",
        _checked: {
          insetInlineStart: "2px"
        }
      },
      control: {
        display: "inline-flex",
        gap: "0.5rem",
        flexShrink: 0,
        justifyContent: "flex-start",
        cursor: "switch",
        borderRadius: "full",
        position: "relative",
        width: "var(--switch-width)",
        height: "var(--switch-height)",
        transition: "backgrounds",
        _disabled: {
          opacity: "0.5",
          cursor: "not-allowed"
        },
        _invalid: {
          outline: "2px solid",
          outlineColor: "border.error",
          outlineOffset: "2px"
        }
      },
      thumb: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
        transitionProperty: "translate",
        transitionDuration: "fast",
        borderRadius: "inherit",
        _checked: {
          translate: "var(--switch-x) 0"
        }
      }
    },
    variants: {
      variant: {
        solid: {
          control: {
            borderRadius: "full",
            bg: "bg.emphasized",
            focusVisibleRing: "outside",
            _checked: {
              bg: "colorPalette.solid"
            }
          },
          thumb: {
            bg: "white",
            width: "var(--switch-height)",
            height: "var(--switch-height)",
            scale: "0.8",
            boxShadow: "sm",
            _checked: {
              bg: "colorPalette.contrast"
            }
          }
        },
        raised: {
          control: {
            borderRadius: "full",
            height: "calc(var(--switch-height) / 2)",
            bg: "bg.muted",
            boxShadow: "inset",
            _checked: {
              bg: "colorPalette.solid/60"
            }
          },
          thumb: {
            width: "var(--switch-height)",
            height: "var(--switch-height)",
            position: "relative",
            top: "calc(var(--switch-height) * -0.25)",
            bg: "white",
            boxShadow: "xs",
            focusVisibleRing: "outside",
            _checked: {
              bg: "colorPalette.solid"
            }
          }
        }
      },
      size: {
        xs: {
          root: {
            "--switch-width": "sizes.6",
            "--switch-height": "sizes.3",
            "--switch-indicator-font-size": "fontSizes.xs"
          }
        },
        sm: {
          root: {
            "--switch-width": "sizes.8",
            "--switch-height": "sizes.4",
            "--switch-indicator-font-size": "fontSizes.xs"
          }
        },
        md: {
          root: {
            "--switch-width": "sizes.10",
            "--switch-height": "sizes.5",
            "--switch-indicator-font-size": "fontSizes.sm"
          }
        },
        lg: {
          root: {
            "--switch-width": "sizes.12",
            "--switch-height": "sizes.6",
            "--switch-indicator-font-size": "fontSizes.md"
          }
        }
      }
    },
    defaultVariants: {
      variant: "solid",
      size: "md"
    }
  });
  const tableSlotRecipe = defineSlotRecipe({
    className: "chakra-table",
    slots: tableAnatomy.keys(),
    base: {
      root: {
        fontVariantNumeric: "lining-nums tabular-nums",
        borderCollapse: "collapse",
        width: "full",
        textAlign: "start",
        verticalAlign: "top"
      },
      row: {
        _selected: {
          bg: "colorPalette.subtle"
        }
      },
      cell: {
        textAlign: "start",
        alignItems: "center"
      },
      columnHeader: {
        fontWeight: "medium",
        textAlign: "start",
        color: "fg"
      },
      caption: {
        fontWeight: "medium",
        textStyle: "xs"
      },
      footer: {
        fontWeight: "medium"
      }
    },
    variants: {
      interactive: {
        true: {
          body: {
            "& tr": {
              _hover: {
                bg: "colorPalette.subtle"
              }
            }
          }
        }
      },
      stickyHeader: {
        true: {
          header: {
            "& :where(tr)": {
              top: "var(--table-sticky-offset, 0)",
              position: "sticky",
              zIndex: 1
            }
          }
        }
      },
      striped: {
        true: {
          row: {
            "&:nth-of-type(odd) td": {
              bg: "bg.muted"
            }
          }
        }
      },
      showColumnBorder: {
        true: {
          columnHeader: {
            "&:not(:last-of-type)": {
              borderInlineEndWidth: "1px"
            }
          },
          cell: {
            "&:not(:last-of-type)": {
              borderInlineEndWidth: "1px"
            }
          }
        }
      },
      variant: {
        line: {
          columnHeader: {
            borderBottomWidth: "1px"
          },
          cell: {
            borderBottomWidth: "1px"
          },
          row: {
            bg: "bg"
          }
        },
        outline: {
          root: {
            boxShadow: "0 0 0 1px {colors.border}"
          },
          columnHeader: {
            borderBottomWidth: "1px"
          },
          header: {
            bg: "bg.muted"
          },
          row: {
            "&:not(:last-of-type)": {
              borderBottomWidth: "1px"
            }
          },
          footer: {
            borderTopWidth: "1px"
          }
        }
      },
      size: {
        sm: {
          root: {
            textStyle: "sm"
          },
          columnHeader: {
            px: "2",
            py: "2"
          },
          cell: {
            px: "2",
            py: "2"
          }
        },
        md: {
          root: {
            textStyle: "sm"
          },
          columnHeader: {
            px: "3",
            py: "3"
          },
          cell: {
            px: "3",
            py: "3"
          }
        },
        lg: {
          root: {
            textStyle: "md"
          },
          columnHeader: {
            px: "4",
            py: "3"
          },
          cell: {
            px: "4",
            py: "3"
          }
        }
      }
    },
    defaultVariants: {
      variant: "line",
      size: "md"
    }
  });
  const tabsSlotRecipe = defineSlotRecipe({
    slots: tabsAnatomy.keys(),
    className: "chakra-tabs",
    base: {
      root: {
        "--tabs-trigger-radius": "radii.l2",
        "--tabs-indicator-shadow": "shadows.xs",
        "--tabs-indicator-bg": "colors.bg",
        position: "relative",
        _horizontal: {
          display: "block"
        },
        _vertical: {
          display: "flex"
        }
      },
      list: {
        display: "inline-flex",
        position: "relative",
        isolation: "isolate",
        minH: "var(--tabs-height)",
        _horizontal: {
          flexDirection: "row"
        },
        _vertical: {
          flexDirection: "column"
        }
      },
      trigger: {
        outline: "0",
        minW: "var(--tabs-height)",
        height: "var(--tabs-height)",
        display: "flex",
        alignItems: "center",
        fontWeight: "medium",
        position: "relative",
        cursor: "button",
        gap: "2",
        _focusVisible: {
          zIndex: 1,
          outline: "2px solid",
          outlineColor: "colorPalette.focusRing"
        },
        _disabled: {
          cursor: "not-allowed",
          opacity: 0.5
        }
      },
      content: {
        focusVisibleRing: "inside",
        _horizontal: {
          width: "100%",
          pt: "var(--tabs-content-padding)"
        },
        _vertical: {
          height: "100%",
          ps: "var(--tabs-content-padding)"
        }
      },
      indicator: {
        width: "var(--width)",
        height: "var(--height)",
        borderRadius: "var(--tabs-trigger-radius)",
        bg: "var(--tabs-indicator-bg)",
        shadow: "var(--tabs-indicator-shadow)",
        zIndex: -1
      }
    },
    variants: {
      fitted: {
        true: {
          list: {
            display: "flex"
          },
          trigger: {
            flex: 1,
            textAlign: "center",
            justifyContent: "center"
          }
        }
      },
      justify: {
        start: {
          list: {
            justifyContent: "flex-start"
          }
        },
        center: {
          list: {
            justifyContent: "center"
          }
        },
        end: {
          list: {
            justifyContent: "flex-end"
          }
        }
      },
      size: {
        sm: {
          root: {
            "--tabs-height": "sizes.9",
            "--tabs-content-padding": "spacing.3"
          },
          trigger: {
            py: "1",
            px: "3",
            textStyle: "sm"
          }
        },
        md: {
          root: {
            "--tabs-height": "sizes.10",
            "--tabs-content-padding": "spacing.4"
          },
          trigger: {
            py: "2",
            px: "4",
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            "--tabs-height": "sizes.11",
            "--tabs-content-padding": "spacing.4.5"
          },
          trigger: {
            py: "2",
            px: "4.5",
            textStyle: "md"
          }
        }
      },
      variant: {
        line: {
          list: {
            display: "flex",
            borderColor: "border",
            _horizontal: {
              borderBottomWidth: "1px"
            },
            _vertical: {
              borderEndWidth: "1px"
            }
          },
          trigger: {
            color: "fg.muted",
            _disabled: {
              _active: { bg: "initial" }
            },
            _selected: {
              color: "fg",
              _horizontal: {
                layerStyle: "indicator.bottom",
                "--indicator-offset-y": "-1px",
                "--indicator-color": "colors.colorPalette.solid"
              },
              _vertical: {
                layerStyle: "indicator.end",
                "--indicator-offset-x": "-1px"
              }
            }
          }
        },
        subtle: {
          trigger: {
            borderRadius: "var(--tabs-trigger-radius)",
            color: "fg.muted",
            _selected: {
              bg: "colorPalette.subtle",
              color: "colorPalette.fg"
            }
          }
        },
        enclosed: {
          list: {
            bg: "bg.muted",
            padding: "1",
            borderRadius: "l3",
            minH: "calc(var(--tabs-height) - 4px)"
          },
          trigger: {
            justifyContent: "center",
            color: "fg.muted",
            borderRadius: "var(--tabs-trigger-radius)",
            _selected: {
              bg: "bg",
              color: "colorPalette.fg",
              shadow: "xs"
            }
          }
        },
        outline: {
          list: {
            "--line-thickness": "1px",
            "--line-offset": "calc(var(--line-thickness) * -1)",
            borderColor: "border",
            display: "flex",
            _horizontal: {
              _before: {
                content: '""',
                position: "absolute",
                bottom: "0px",
                width: "100%",
                borderBottomWidth: "var(--line-thickness)",
                borderBottomColor: "border"
              }
            },
            _vertical: {
              _before: {
                content: '""',
                position: "absolute",
                insetInline: "var(--line-offset)",
                height: "calc(100% - calc(var(--line-thickness) * 2))",
                borderEndWidth: "var(--line-thickness)",
                borderEndColor: "border"
              }
            }
          },
          trigger: {
            color: "fg.muted",
            borderWidth: "1px",
            borderColor: "transparent",
            _selected: {
              bg: "currentBg",
              color: "colorPalette.fg"
            },
            _horizontal: {
              borderTopRadius: "var(--tabs-trigger-radius)",
              marginBottom: "var(--line-offset)",
              marginEnd: { _notLast: "var(--line-offset)" },
              _selected: {
                borderColor: "border",
                borderBottomColor: "transparent"
              }
            },
            _vertical: {
              borderStartRadius: "var(--tabs-trigger-radius)",
              marginEnd: "var(--line-offset)",
              marginBottom: { _notLast: "var(--line-offset)" },
              _selected: {
                borderColor: "border",
                borderEndColor: "transparent"
              }
            }
          }
        },
        plain: {
          trigger: {
            color: "fg.muted",
            _selected: {
              color: "colorPalette.fg"
            },
            borderRadius: "var(--tabs-trigger-radius)",
            "&[data-selected][data-ssr]": {
              bg: "var(--tabs-indicator-bg)",
              shadow: "var(--tabs-indicator-shadow)",
              borderRadius: "var(--tabs-trigger-radius)"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "line"
    }
  });
  const badgeVariant = badgeRecipe.variants?.variant;
  const tagSlotRecipe = defineSlotRecipe({
    slots: tagAnatomy.keys(),
    className: "chakra-tag",
    base: {
      root: {
        display: "inline-flex",
        alignItems: "center",
        verticalAlign: "top",
        maxWidth: "100%",
        userSelect: "none",
        borderRadius: "l2",
        focusVisibleRing: "outside"
      },
      label: {
        lineClamp: "1"
      },
      closeTrigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        outline: "0",
        borderRadius: "l1",
        color: "currentColor",
        focusVisibleRing: "inside",
        focusRingWidth: "2px"
      },
      startElement: {
        flexShrink: 0,
        boxSize: "var(--tag-element-size)",
        ms: "var(--tag-element-offset)",
        "&:has([data-scope=avatar])": {
          boxSize: "var(--tag-avatar-size)",
          ms: "calc(var(--tag-element-offset) * 1.5)"
        },
        _icon: { boxSize: "100%" }
      },
      endElement: {
        flexShrink: 0,
        boxSize: "var(--tag-element-size)",
        me: "var(--tag-element-offset)",
        _icon: { boxSize: "100%" },
        "&:has(button)": {
          ms: "calc(var(--tag-element-offset) * -1)"
        }
      }
    },
    variants: {
      size: {
        sm: {
          root: {
            px: "1.5",
            minH: "4.5",
            gap: "1",
            "--tag-avatar-size": "spacing.3",
            "--tag-element-size": "spacing.3",
            "--tag-element-offset": "-2px"
          },
          label: {
            textStyle: "xs"
          }
        },
        md: {
          root: {
            px: "1.5",
            minH: "5",
            gap: "1",
            "--tag-avatar-size": "spacing.3.5",
            "--tag-element-size": "spacing.3.5",
            "--tag-element-offset": "-2px"
          },
          label: {
            textStyle: "xs"
          }
        },
        lg: {
          root: {
            px: "2",
            minH: "6",
            gap: "1.5",
            "--tag-avatar-size": "spacing.4.5",
            "--tag-element-size": "spacing.4",
            "--tag-element-offset": "-3px"
          },
          label: {
            textStyle: "sm"
          }
        },
        xl: {
          root: {
            px: "2.5",
            minH: "8",
            gap: "1.5",
            "--tag-avatar-size": "spacing.6",
            "--tag-element-size": "spacing.4.5",
            "--tag-element-offset": "-4px"
          },
          label: {
            textStyle: "sm"
          }
        }
      },
      variant: {
        subtle: {
          root: badgeVariant?.subtle
        },
        solid: {
          root: badgeVariant?.solid
        },
        outline: {
          root: badgeVariant?.outline
        },
        surface: {
          root: badgeVariant?.surface
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "surface"
    }
  });
  const tagsInputSlotRecipe = defineSlotRecipe({
    slots: anatomy$1.keys(),
    className: "tags-input",
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        gap: "1.5",
        width: "full"
      },
      label: {
        fontWeight: "medium",
        textStyle: "sm",
        _disabled: {
          opacity: "0.5"
        }
      },
      control: {
        "--focus-color": "colors.colorPalette.focusRing",
        "--error-color": "colors.border.error",
        minH: "var(--tags-input-height)",
        "--input-height": "var(--tags-input-height)",
        px: "var(--tags-input-px)",
        py: "var(--tags-input-py)",
        gap: "var(--tags-input-gap)",
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        borderRadius: "l2",
        pos: "relative",
        transitionProperty: "border-color, box-shadow",
        transitionDuration: "normal",
        _disabled: {
          opacity: "0.5"
        },
        _invalid: {
          borderColor: "var(--error-color)"
        }
      },
      input: {
        flex: "1",
        minWidth: "20",
        outline: "none",
        bg: "transparent",
        color: "fg",
        px: "calc(var(--tags-input-item-px) / 1.25)",
        height: "var(--tags-input-item-height)",
        _readOnly: {
          display: "none"
        }
      },
      item: {
        maxWidth: "100%",
        minWidth: "0"
      },
      itemText: {
        lineClamp: "1",
        minWidth: "0"
      },
      itemInput: {
        outline: "none",
        bg: "transparent",
        minWidth: "2ch",
        color: "inherit",
        px: "var(--tags-input-item-px)",
        height: "var(--tags-input-item-height)"
      },
      itemPreview: {
        height: "var(--tags-input-item-height)",
        userSelect: "none",
        display: "inline-flex",
        alignItems: "center",
        gap: "1",
        rounded: "l1",
        px: "var(--tags-input-item-px)",
        maxWidth: "100%"
      },
      itemDeleteTrigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: "0",
        boxSize: "calc(var(--tags-input-item-height) / 1.5)",
        cursor: { base: "button", _disabled: "initial" },
        me: "-1",
        opacity: "0.4",
        _hover: {
          opacity: "1"
        },
        "[data-highlighted] &": {
          opacity: "1"
        },
        _icon: {
          boxSize: "80%"
        }
      },
      clearTrigger: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSize: "calc(var(--tags-input-item-height) / 1.5)",
        cursor: { base: "button", _disabled: "initial" },
        color: "fg.muted",
        focusVisibleRing: "inside",
        focusRingWidth: "2px",
        rounded: "l1",
        _icon: {
          boxSize: "5"
        }
      }
    },
    variants: {
      size: {
        xs: {
          root: {
            "--tags-input-height": "sizes.8",
            "--tags-input-px": "spacing.1.5",
            "--tags-input-py": "spacing.1",
            "--tags-input-gap": "spacing.1",
            "--tags-input-item-height": "sizes.6",
            "--tags-input-item-px": "spacing.2",
            textStyle: "xs"
          }
        },
        sm: {
          root: {
            "--tags-input-height": "sizes.9",
            "--tags-input-px": "spacing.1.5",
            "--tags-input-py": "spacing.1",
            "--tags-input-gap": "spacing.1",
            "--tags-input-item-height": "sizes.6",
            "--tags-input-item-px": "spacing.2",
            textStyle: "sm"
          }
        },
        md: {
          root: {
            "--tags-input-height": "sizes.10",
            "--tags-input-px": "spacing.1.5",
            "--tags-input-py": "spacing.1",
            "--tags-input-gap": "spacing.1",
            "--tags-input-item-height": "sizes.7",
            "--tags-input-item-px": "spacing.2",
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            "--tags-input-height": "sizes.11",
            "--tags-input-px": "spacing.1.5",
            "--tags-input-py": "spacing.1",
            "--tags-input-gap": "spacing.1",
            "--tags-input-item-height": "sizes.8",
            "--tags-input-item-px": "spacing.2",
            textStyle: "md"
          }
        }
      },
      variant: {
        outline: {
          control: {
            borderWidth: "1px",
            bg: "bg",
            _focus: {
              outlineWidth: "1px",
              outlineStyle: "solid",
              outlineColor: "var(--focus-color)",
              borderColor: "var(--focus-color)",
              _invalid: {
                outlineColor: "var(--error-color)",
                borderColor: "var(--error-color)"
              }
            }
          },
          itemPreview: {
            bg: "colorPalette.subtle",
            _highlighted: {
              bg: "colorPalette.muted"
            }
          }
        },
        subtle: {
          control: {
            bg: "bg.muted",
            borderWidth: "1px",
            borderColor: "transparent",
            _focus: {
              outlineWidth: "1px",
              outlineStyle: "solid",
              outlineColor: "var(--focus-color)",
              borderColor: "var(--focus-color)",
              _invalid: {
                outlineColor: "var(--error-color)",
                borderColor: "var(--error-color)"
              }
            }
          },
          itemPreview: {
            bg: "bg",
            borderWidth: "1px",
            _highlighted: {
              bg: "colorPalette.subtle",
              borderColor: "colorPalette.emphasized"
            }
          }
        },
        flushed: {
          control: {
            borderRadius: "0",
            px: "0",
            bg: "transparent",
            borderBottomWidth: "1px",
            borderBottomColor: "border",
            _focus: {
              borderColor: "var(--focus-color)",
              boxShadow: "0px 1px 0px 0px var(--focus-color)"
            }
          },
          itemPreview: {
            bg: "colorPalette.subtle",
            _highlighted: {
              bg: "colorPalette.muted"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "outline"
    }
  });
  const timelineSlotRecipe = defineSlotRecipe({
    slots: timelineAnatomy.keys(),
    className: "chakra-timeline",
    base: {
      root: {
        display: "flex",
        flexDirection: "column",
        width: "full",
        "--timeline-thickness": "1px",
        "--timeline-gutter": "4px"
      },
      item: {
        "--timeline-content-gap": "spacing.6",
        display: "flex",
        position: "relative",
        alignItems: "flex-start",
        flexShrink: 0,
        gap: "4",
        _last: {
          "--timeline-content-gap": "0"
        }
      },
      separator: {
        display: "var(--timeline-separator-display)",
        position: "absolute",
        borderStartWidth: "var(--timeline-thickness)",
        ms: "calc(-1 * var(--timeline-thickness) / 2)",
        insetInlineStart: "calc(var(--timeline-indicator-size) / 2)",
        insetBlock: "0",
        borderColor: "border"
      },
      indicator: {
        outline: "2px solid {colors.bg}",
        position: "relative",
        flexShrink: "0",
        boxSize: "var(--timeline-indicator-size)",
        fontSize: "var(--timeline-font-size)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "full",
        fontWeight: "medium"
      },
      connector: {
        alignSelf: "stretch",
        position: "relative"
      },
      content: {
        pb: "var(--timeline-content-gap)",
        display: "flex",
        flexDirection: "column",
        width: "full",
        gap: "2"
      },
      title: {
        display: "flex",
        fontWeight: "medium",
        flexWrap: "wrap",
        gap: "1.5",
        alignItems: "center",
        mt: "var(--timeline-margin)"
      },
      description: {
        color: "fg.muted",
        textStyle: "xs"
      }
    },
    variants: {
      variant: {
        subtle: {
          indicator: {
            bg: "colorPalette.muted"
          }
        },
        solid: {
          indicator: {
            bg: "colorPalette.solid",
            color: "colorPalette.contrast"
          }
        },
        outline: {
          indicator: {
            bg: "currentBg",
            borderWidth: "1px",
            borderColor: "colorPalette.muted"
          }
        },
        plain: {}
      },
      showLastSeparator: {
        true: {
          item: {
            _last: {
              "--timeline-separator-display": "initial"
            }
          }
        },
        false: {
          item: {
            _last: {
              "--timeline-separator-display": "none"
            }
          }
        }
      },
      size: {
        sm: {
          root: {
            "--timeline-indicator-size": "sizes.4",
            "--timeline-font-size": "fontSizes.2xs"
          },
          title: {
            textStyle: "xs"
          }
        },
        md: {
          root: {
            "--timeline-indicator-size": "sizes.5",
            "--timeline-font-size": "fontSizes.xs"
          },
          title: {
            textStyle: "sm"
          }
        },
        lg: {
          root: {
            "--timeline-indicator-size": "sizes.6",
            "--timeline-font-size": "fontSizes.xs"
          },
          title: {
            mt: "0.5",
            textStyle: "sm"
          }
        },
        xl: {
          root: {
            "--timeline-indicator-size": "sizes.8",
            "--timeline-font-size": "fontSizes.sm"
          },
          title: {
            mt: "1.5",
            textStyle: "sm"
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "solid",
      showLastSeparator: false
    }
  });
  const toastSlotRecipe = defineSlotRecipe({
    slots: toastAnatomy.keys(),
    className: "chakra-toast",
    base: {
      root: {
        width: "full",
        display: "flex",
        alignItems: "flex-start",
        position: "relative",
        gap: "3",
        py: "4",
        ps: "4",
        pe: "6",
        borderRadius: "l2",
        translate: "var(--x) var(--y)",
        scale: "var(--scale)",
        zIndex: "var(--z-index)",
        height: "var(--height)",
        opacity: "var(--opacity)",
        willChange: "translate, opacity, scale",
        transition: "translate 400ms, scale 400ms, opacity 400ms, height 400ms, box-shadow 200ms",
        transitionTimingFunction: "cubic-bezier(0.21, 1.02, 0.73, 1)",
        _closed: {
          transition: "translate 400ms, scale 400ms, opacity 200ms",
          transitionTimingFunction: "cubic-bezier(0.06, 0.71, 0.55, 1)"
        },
        bg: "bg.panel",
        color: "fg",
        boxShadow: "xl",
        "--toast-trigger-bg": "colors.bg.muted",
        "&[data-type=warning]": {
          bg: "orange.solid",
          color: "orange.contrast",
          "--toast-trigger-bg": "{white/10}",
          "--toast-border-color": "{white/40}"
        },
        "&[data-type=success]": {
          bg: "green.solid",
          color: "green.contrast",
          "--toast-trigger-bg": "{white/10}",
          "--toast-border-color": "{white/40}"
        },
        "&[data-type=error]": {
          bg: "red.solid",
          color: "red.contrast",
          "--toast-trigger-bg": "{white/10}",
          "--toast-border-color": "{white/40}"
        }
      },
      title: {
        fontWeight: "medium",
        textStyle: "sm",
        marginEnd: "2"
      },
      description: {
        display: "inline",
        textStyle: "sm",
        opacity: "0.8"
      },
      indicator: {
        flexShrink: "0",
        boxSize: "5"
      },
      actionTrigger: {
        textStyle: "sm",
        fontWeight: "medium",
        height: "8",
        px: "3",
        borderRadius: "l2",
        alignSelf: "center",
        borderWidth: "1px",
        borderColor: "var(--toast-border-color, inherit)",
        transition: "background 200ms",
        _hover: {
          bg: "var(--toast-trigger-bg)"
        }
      },
      closeTrigger: {
        position: "absolute",
        top: "1",
        insetEnd: "1",
        padding: "1",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        color: "{currentColor/60}",
        borderRadius: "l2",
        textStyle: "md",
        transition: "background 200ms",
        _icon: {
          boxSize: "1em"
        }
      }
    }
  });
  const tooltipSlotRecipe = defineSlotRecipe({
    slots: anatomy.keys(),
    className: "chakra-tooltip",
    base: {
      content: {
        "--tooltip-bg": "colors.bg.inverted",
        bg: "var(--tooltip-bg)",
        color: "fg.inverted",
        px: "2.5",
        py: "1",
        borderRadius: "l2",
        fontWeight: "medium",
        textStyle: "xs",
        boxShadow: "md",
        maxW: "xs",
        zIndex: "tooltip",
        transformOrigin: "var(--transform-origin)",
        _open: {
          animationStyle: "scale-fade-in",
          animationDuration: "fast"
        },
        _closed: {
          animationStyle: "scale-fade-out",
          animationDuration: "fast"
        }
      },
      arrow: {
        "--arrow-size": "sizes.2",
        "--arrow-background": "var(--tooltip-bg)"
      },
      arrowTip: {
        borderTopWidth: "1px",
        borderLeftWidth: "1px",
        borderColor: "var(--tooltip-bg)"
      }
    }
  });
  const baseItemStyle = defineStyle({
    display: "flex",
    alignItems: "center",
    gap: "var(--tree-item-gap)",
    rounded: "l2",
    userSelect: "none",
    position: "relative",
    "--tree-depth": "calc(var(--depth) - 1)",
    "--tree-indentation-offset": "calc(var(--tree-indentation) * var(--tree-depth))",
    "--tree-icon-offset": "calc(var(--tree-icon-size) * var(--tree-depth) * 0.5)",
    "--tree-offset": "calc(var(--tree-padding-inline) + var(--tree-indentation-offset) + var(--tree-icon-offset))",
    ps: "var(--tree-offset)",
    pe: "var(--tree-padding-inline)",
    py: "var(--tree-padding-block)",
    focusVisibleRing: "inside",
    focusRingColor: "border.emphasized",
    focusRingWidth: "2px",
    "&:hover, &:focus-visible": {
      bg: "bg.muted"
    },
    _disabled: {
      layerStyle: "disabled"
    }
  });
  const baseTextStyle = defineStyle({
    flex: "1"
  });
  const subtleVariantStyle = defineStyle({
    _selected: {
      bg: "colorPalette.subtle",
      color: "colorPalette.fg"
    }
  });
  const solidVariantStyle = defineStyle({
    _selected: {
      layerStyle: "fill.solid"
    }
  });
  const treeViewSlotRecipe = defineSlotRecipe({
    slots: anatomy$g.keys(),
    className: "chakra-tree-view",
    base: {
      root: {
        width: "full",
        display: "flex",
        flexDirection: "column",
        gap: "2"
      },
      tree: {
        display: "flex",
        flexDirection: "column",
        "--tree-item-gap": "spacing.2",
        _icon: {
          boxSize: "var(--tree-icon-size)"
        }
      },
      label: {
        fontWeight: "medium",
        textStyle: "sm"
      },
      branch: {
        position: "relative"
      },
      branchContent: {
        position: "relative"
      },
      branchIndentGuide: {
        height: "100%",
        width: "1px",
        bg: "border",
        position: "absolute",
        "--tree-depth": "calc(var(--depth) - 1)",
        "--tree-indentation-offset": "calc(var(--tree-indentation) * var(--tree-depth))",
        "--tree-offset": "calc(var(--tree-padding-inline) + var(--tree-indentation-offset))",
        "--tree-icon-offset": "calc(var(--tree-icon-size) * 0.5 * var(--depth))",
        insetInlineStart: "calc(var(--tree-offset) + var(--tree-icon-offset))",
        zIndex: "1"
      },
      branchIndicator: {
        color: "fg.muted",
        transformOrigin: "center",
        transitionDuration: "normal",
        transitionProperty: "transform",
        transitionTimingFunction: "default",
        _open: {
          transform: "rotate(90deg)"
        }
      },
      branchTrigger: {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center"
      },
      branchControl: baseItemStyle,
      item: baseItemStyle,
      itemText: baseTextStyle,
      branchText: baseTextStyle,
      nodeCheckbox: {
        display: "inline-flex"
      }
    },
    variants: {
      size: {
        md: {
          tree: {
            textStyle: "sm",
            "--tree-indentation": "spacing.4",
            "--tree-padding-inline": "spacing.3",
            "--tree-padding-block": "spacing.1.5",
            "--tree-icon-size": "spacing.4"
          }
        },
        sm: {
          tree: {
            textStyle: "sm",
            "--tree-indentation": "spacing.4",
            "--tree-padding-inline": "spacing.3",
            "--tree-padding-block": "spacing.1",
            "--tree-icon-size": "spacing.3"
          }
        },
        xs: {
          tree: {
            textStyle: "xs",
            "--tree-indentation": "spacing.4",
            "--tree-padding-inline": "spacing.2",
            "--tree-padding-block": "spacing.1",
            "--tree-icon-size": "spacing.3"
          }
        }
      },
      variant: {
        subtle: {
          branchControl: subtleVariantStyle,
          item: subtleVariantStyle
        },
        solid: {
          branchControl: solidVariantStyle,
          item: solidVariantStyle
        }
      },
      animateContent: {
        true: {
          branchContent: {
            _open: {
              animationName: "expand-height, fade-in",
              animationDuration: "moderate"
            },
            _closed: {
              animationName: "collapse-height, fade-out",
              animationDuration: "moderate"
            }
          }
        }
      }
    },
    defaultVariants: {
      size: "md",
      variant: "subtle"
    }
  });
  const slotRecipes = {
    accordion: accordionSlotRecipe,
    actionBar: actionBarSlotRecipe,
    alert: alertSlotRecipe,
    avatar: avatarSlotRecipe,
    blockquote: blockquoteSlotRecipe,
    breadcrumb: breadcrumbSlotRecipe,
    card: cardSlotRecipe,
    carousel: carouselSlotRecipe,
    checkbox: checkboxSlotRecipe,
    checkboxCard: checkboxCardSlotRecipe,
    codeBlock: codeBlockSlotRecipe,
    collapsible: collapsibleSlotRecipe,
    dataList: dataListSlotRecipe,
    dialog: dialogSlotRecipe,
    drawer: drawerSlotRecipe,
    editable: editableSlotRecipe,
    emptyState: emptyStateSlotRecipe,
    field: fieldSlotRecipe,
    fieldset: fieldsetSlotRecipe,
    fileUpload: fileUploadSlotRecipe,
    hoverCard: hoverCardSlotRecipe,
    list: listSlotRecipe,
    listbox: listboxSlotRecipe,
    menu: menuSlotRecipe,
    nativeSelect: nativeSelectSlotRecipe,
    numberInput: numberInputSlotRecipe,
    pinInput: pinInputSlotRecipe,
    popover: popoverSlotRecipe,
    progress: progressSlotRecipe,
    progressCircle: progressCircleSlotRecipe,
    radioCard: radioCardSlotRecipe,
    radioGroup: radioGroupSlotRecipe,
    ratingGroup: ratingGroupSlotRecipe,
    scrollArea: scrollAreaSlotRecipe,
    segmentGroup: segmentGroupSlotRecipe,
    select: selectSlotRecipe,
    combobox: comboboxSlotRecipe,
    slider: sliderSlotRecipe,
    splitter: splitterSlotRecipe,
    stat: statSlotRecipe,
    steps: stepsSlotRecipe,
    switch: switchSlotRecipe,
    table: tableSlotRecipe,
    tabs: tabsSlotRecipe,
    tag: tagSlotRecipe,
    tagsInput: tagsInputSlotRecipe,
    toast: toastSlotRecipe,
    tooltip: tooltipSlotRecipe,
    status: statusSlotRecipe,
    timeline: timelineSlotRecipe,
    colorPicker: colorPickerSlotRecipe,
    qrCode: qrCodeSlotRecipe,
    treeView: treeViewSlotRecipe
  };
  const textStyles = defineTextStyles({
    "2xs": { value: { fontSize: "2xs", lineHeight: "0.75rem" } },
    xs: { value: { fontSize: "xs", lineHeight: "1rem" } },
    sm: { value: { fontSize: "sm", lineHeight: "1.25rem" } },
    md: { value: { fontSize: "md", lineHeight: "1.5rem" } },
    lg: { value: { fontSize: "lg", lineHeight: "1.75rem" } },
    xl: { value: { fontSize: "xl", lineHeight: "1.875rem" } },
    "2xl": { value: { fontSize: "2xl", lineHeight: "2rem" } },
    "3xl": { value: { fontSize: "3xl", lineHeight: "2.375rem" } },
    "4xl": {
      value: {
        fontSize: "4xl",
        lineHeight: "2.75rem",
        letterSpacing: "-0.025em"
      }
    },
    "5xl": {
      value: {
        fontSize: "5xl",
        lineHeight: "3.75rem",
        letterSpacing: "-0.025em"
      }
    },
    "6xl": {
      value: { fontSize: "6xl", lineHeight: "4.5rem", letterSpacing: "-0.025em" }
    },
    "7xl": {
      value: {
        fontSize: "7xl",
        lineHeight: "5.75rem",
        letterSpacing: "-0.025em"
      }
    },
    none: {
      value: {}
    },
    label: {
      value: {
        fontSize: "sm",
        lineHeight: "1.25rem",
        fontWeight: "medium"
      }
    }
  });
  const animations$1 = defineTokens.animations({
    spin: { value: "spin 1s linear infinite" },
    ping: { value: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite" },
    pulse: { value: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" },
    bounce: { value: "bounce 1s infinite" }
  });
  const aspectRatios = defineTokens.aspectRatios({
    square: { value: "1 / 1" },
    landscape: { value: "4 / 3" },
    portrait: { value: "3 / 4" },
    wide: { value: "16 / 9" },
    ultrawide: { value: "18 / 5" },
    golden: { value: "1.618 / 1" }
  });
  const blurs = defineTokens.blurs({
    none: { value: " " },
    sm: { value: "4px" },
    md: { value: "8px" },
    lg: { value: "12px" },
    xl: { value: "16px" },
    "2xl": { value: "24px" },
    "3xl": { value: "40px" },
    "4xl": { value: "64px" }
  });
  const borders$1 = defineTokens.borders({
    xs: { value: "0.5px solid" },
    sm: { value: "1px solid" },
    md: { value: "2px solid" },
    lg: { value: "4px solid" },
    xl: { value: "8px solid" }
  });
  const colors = defineTokens.colors({
    transparent: { value: "transparent" },
    current: { value: "currentColor" },
    black: { value: "#09090B" },
    white: { value: "#FFFFFF" },
    whiteAlpha: {
      50: { value: "rgba(255, 255, 255, 0.04)" },
      100: { value: "rgba(255, 255, 255, 0.06)" },
      200: { value: "rgba(255, 255, 255, 0.08)" },
      300: { value: "rgba(255, 255, 255, 0.16)" },
      400: { value: "rgba(255, 255, 255, 0.24)" },
      500: { value: "rgba(255, 255, 255, 0.36)" },
      600: { value: "rgba(255, 255, 255, 0.48)" },
      700: { value: "rgba(255, 255, 255, 0.64)" },
      800: { value: "rgba(255, 255, 255, 0.80)" },
      900: { value: "rgba(255, 255, 255, 0.92)" },
      950: { value: "rgba(255, 255, 255, 0.95)" }
    },
    blackAlpha: {
      50: { value: "rgba(0, 0, 0, 0.04)" },
      100: { value: "rgba(0, 0, 0, 0.06)" },
      200: { value: "rgba(0, 0, 0, 0.08)" },
      300: { value: "rgba(0, 0, 0, 0.16)" },
      400: { value: "rgba(0, 0, 0, 0.24)" },
      500: { value: "rgba(0, 0, 0, 0.36)" },
      600: { value: "rgba(0, 0, 0, 0.48)" },
      700: { value: "rgba(0, 0, 0, 0.64)" },
      800: { value: "rgba(0, 0, 0, 0.80)" },
      900: { value: "rgba(0, 0, 0, 0.92)" },
      950: { value: "rgba(0, 0, 0, 0.95)" }
    },
    gray: {
      50: { value: "#fafafa" },
      100: { value: "#f4f4f5" },
      200: { value: "#e4e4e7" },
      300: { value: "#d4d4d8" },
      400: { value: "#a1a1aa" },
      500: { value: "#71717a" },
      600: { value: "#52525b" },
      700: { value: "#3f3f46" },
      800: { value: "#27272a" },
      900: { value: "#18181b" },
      950: { value: "#111111" }
    },
    red: {
      50: { value: "#fef2f2" },
      100: { value: "#fee2e2" },
      200: { value: "#fecaca" },
      300: { value: "#fca5a5" },
      400: { value: "#f87171" },
      500: { value: "#ef4444" },
      600: { value: "#dc2626" },
      700: { value: "#991919" },
      800: { value: "#511111" },
      900: { value: "#300c0c" },
      950: { value: "#1f0808" }
    },
    orange: {
      50: { value: "#fff7ed" },
      100: { value: "#ffedd5" },
      200: { value: "#fed7aa" },
      300: { value: "#fdba74" },
      400: { value: "#fb923c" },
      500: { value: "#f97316" },
      600: { value: "#ea580c" },
      700: { value: "#92310a" },
      800: { value: "#6c2710" },
      900: { value: "#3b1106" },
      950: { value: "#220a04" }
    },
    yellow: {
      50: { value: "#fefce8" },
      100: { value: "#fef9c3" },
      200: { value: "#fef08a" },
      300: { value: "#fde047" },
      400: { value: "#facc15" },
      500: { value: "#eab308" },
      600: { value: "#ca8a04" },
      700: { value: "#845209" },
      800: { value: "#713f12" },
      900: { value: "#422006" },
      950: { value: "#281304" }
    },
    green: {
      50: { value: "#f0fdf4" },
      100: { value: "#dcfce7" },
      200: { value: "#bbf7d0" },
      300: { value: "#86efac" },
      400: { value: "#4ade80" },
      500: { value: "#22c55e" },
      600: { value: "#16a34a" },
      700: { value: "#116932" },
      800: { value: "#124a28" },
      900: { value: "#042713" },
      950: { value: "#03190c" }
    },
    teal: {
      50: { value: "#f0fdfa" },
      100: { value: "#ccfbf1" },
      200: { value: "#99f6e4" },
      300: { value: "#5eead4" },
      400: { value: "#2dd4bf" },
      500: { value: "#14b8a6" },
      600: { value: "#0d9488" },
      700: { value: "#0c5d56" },
      800: { value: "#114240" },
      900: { value: "#032726" },
      950: { value: "#021716" }
    },
    blue: {
      50: { value: "#eff6ff" },
      100: { value: "#dbeafe" },
      200: { value: "#bfdbfe" },
      300: { value: "#a3cfff" },
      400: { value: "#60a5fa" },
      500: { value: "#3b82f6" },
      600: { value: "#2563eb" },
      700: { value: "#173da6" },
      800: { value: "#1a3478" },
      900: { value: "#14204a" },
      950: { value: "#0c142e" }
    },
    cyan: {
      50: { value: "#ecfeff" },
      100: { value: "#cffafe" },
      200: { value: "#a5f3fc" },
      300: { value: "#67e8f9" },
      400: { value: "#22d3ee" },
      500: { value: "#06b6d4" },
      600: { value: "#0891b2" },
      700: { value: "#0c5c72" },
      800: { value: "#134152" },
      900: { value: "#072a38" },
      950: { value: "#051b24" }
    },
    purple: {
      50: { value: "#faf5ff" },
      100: { value: "#f3e8ff" },
      200: { value: "#e9d5ff" },
      300: { value: "#d8b4fe" },
      400: { value: "#c084fc" },
      500: { value: "#a855f7" },
      600: { value: "#9333ea" },
      700: { value: "#641ba3" },
      800: { value: "#4a1772" },
      900: { value: "#2f0553" },
      950: { value: "#1a032e" }
    },
    pink: {
      50: { value: "#fdf2f8" },
      100: { value: "#fce7f3" },
      200: { value: "#fbcfe8" },
      300: { value: "#f9a8d4" },
      400: { value: "#f472b6" },
      500: { value: "#ec4899" },
      600: { value: "#db2777" },
      700: { value: "#a41752" },
      800: { value: "#6d0e34" },
      900: { value: "#45061f" },
      950: { value: "#2c0514" }
    }
  });
  const cursor = defineTokens.cursor({
    button: { value: "pointer" },
    checkbox: { value: "default" },
    disabled: { value: "not-allowed" },
    menuitem: { value: "default" },
    option: { value: "default" },
    radio: { value: "default" },
    slider: { value: "default" },
    switch: { value: "pointer" }
  });
  const durations = defineTokens.durations({
    fastest: { value: "50ms" },
    faster: { value: "100ms" },
    fast: { value: "150ms" },
    moderate: { value: "200ms" },
    slow: { value: "300ms" },
    slower: { value: "400ms" },
    slowest: { value: "500ms" }
  });
  const easings = defineTokens.easings({
    "ease-in": { value: "cubic-bezier(0.42, 0, 1, 1)" },
    "ease-out": { value: "cubic-bezier(0, 0, 0.58, 1)" },
    "ease-in-out": { value: "cubic-bezier(0.42, 0, 0.58, 1)" },
    "ease-in-smooth": { value: "cubic-bezier(0.32, 0.72, 0, 1)" }
  });
  const fontSizes = defineTokens.fontSizes({
    "2xs": { value: "0.625rem" },
    xs: { value: "0.75rem" },
    sm: { value: "0.875rem" },
    md: { value: "1rem" },
    lg: { value: "1.125rem" },
    xl: { value: "1.25rem" },
    "2xl": { value: "1.5rem" },
    "3xl": { value: "1.875rem" },
    "4xl": { value: "2.25rem" },
    "5xl": { value: "3rem" },
    "6xl": { value: "3.75rem" },
    "7xl": { value: "4.5rem" },
    "8xl": { value: "6rem" },
    "9xl": { value: "8rem" }
  });
  const fontWeights = defineTokens.fontWeights({
    thin: { value: "100" },
    extralight: { value: "200" },
    light: { value: "300" },
    normal: { value: "400" },
    medium: { value: "500" },
    semibold: { value: "600" },
    bold: { value: "700" },
    extrabold: { value: "800" },
    black: { value: "900" }
  });
  const fallback = `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
  const fonts = defineTokens.fonts({
    heading: {
      value: `Inter, ${fallback}`
    },
    body: {
      value: `Inter, ${fallback}`
    },
    mono: {
      value: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
    }
  });
  const keyframes$1 = defineKeyframes({
    spin: {
      "0%": { transform: "rotate(0deg)" },
      "100%": { transform: "rotate(360deg)" }
    },
    pulse: {
      "50%": { opacity: "0.5" }
    },
    ping: {
      "75%, 100%": {
        transform: "scale(2)",
        opacity: "0"
      }
    },
    bounce: {
      "0%, 100%": {
        transform: "translateY(-25%)",
        animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
      },
      "50%": {
        transform: "none",
        animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
      }
    },
    "bg-position": {
      from: { backgroundPosition: "var(--animate-from, 1rem) 0" },
      to: { backgroundPosition: "var(--animate-to, 0) 0" }
    },
    position: {
      from: {
        insetInlineStart: "var(--animate-from-x)",
        insetBlockStart: "var(--animate-from-y)"
      },
      to: {
        insetInlineStart: "var(--animate-to-x)",
        insetBlockStart: "var(--animate-to-y)"
      }
    },
    "circular-progress": {
      "0%": {
        strokeDasharray: "1, 400",
        strokeDashoffset: "0"
      },
      "50%": {
        strokeDasharray: "400, 400",
        strokeDashoffset: "-100%"
      },
      "100%": {
        strokeDasharray: "400, 400",
        strokeDashoffset: "-260%"
      }
    },
"expand-height": {
      from: { height: "var(--collapsed-height, 0)" },
      to: { height: "var(--height)" }
    },
    "collapse-height": {
      from: { height: "var(--height)" },
      to: { height: "var(--collapsed-height, 0)" }
    },
    "expand-width": {
      from: { width: "var(--collapsed-width, 0)" },
      to: { width: "var(--width)" }
    },
    "collapse-width": {
      from: { height: "var(--width)" },
      to: { height: "var(--collapsed-width, 0)" }
    },
"fade-in": {
      from: { opacity: 0 },
      to: { opacity: 1 }
    },
    "fade-out": {
      from: { opacity: 1 },
      to: { opacity: 0 }
    },
"slide-from-left-full": {
      from: { translate: "-100% 0" },
      to: { translate: "0 0" }
    },
    "slide-from-right-full": {
      from: { translate: "100% 0" },
      to: { translate: "0 0" }
    },
    "slide-from-top-full": {
      from: { translate: "0 -100%" },
      to: { translate: "0 0" }
    },
    "slide-from-bottom-full": {
      from: { translate: "0 100%" },
      to: { translate: "0 0" }
    },
"slide-to-left-full": {
      from: { translate: "0 0" },
      to: { translate: "-100% 0" }
    },
    "slide-to-right-full": {
      from: { translate: "0 0" },
      to: { translate: "100% 0" }
    },
    "slide-to-top-full": {
      from: { translate: "0 0" },
      to: { translate: "0 -100%" }
    },
    "slide-to-bottom-full": {
      from: { translate: "0 0" },
      to: { translate: "0 100%" }
    },
"slide-from-top": {
      "0%": { translate: "0 -0.5rem" },
      to: { translate: "0" }
    },
    "slide-from-bottom": {
      "0%": { translate: "0 0.5rem" },
      to: { translate: "0" }
    },
    "slide-from-left": {
      "0%": { translate: "-0.5rem 0" },
      to: { translate: "0" }
    },
    "slide-from-right": {
      "0%": { translate: "0.5rem 0" },
      to: { translate: "0" }
    },
"slide-to-top": {
      "0%": { translate: "0" },
      to: { translate: "0 -0.5rem" }
    },
    "slide-to-bottom": {
      "0%": { translate: "0" },
      to: { translate: "0 0.5rem" }
    },
    "slide-to-left": {
      "0%": { translate: "0" },
      to: { translate: "-0.5rem 0" }
    },
    "slide-to-right": {
      "0%": { translate: "0" },
      to: { translate: "0.5rem 0" }
    },
"scale-in": {
      from: { scale: "0.95" },
      to: { scale: "1" }
    },
    "scale-out": {
      from: { scale: "1" },
      to: { scale: "0.95" }
    }
  });
  const letterSpacings = defineTokens.letterSpacings({
    tighter: { value: "-0.05em" },
    tight: { value: "-0.025em" },
    wide: { value: "0.025em" },
    wider: { value: "0.05em" },
    widest: { value: "0.1em" }
  });
  const lineHeights = defineTokens.lineHeights({
    shorter: { value: 1.25 },
    short: { value: 1.375 },
    moderate: { value: 1.5 },
    tall: { value: 1.625 },
    taller: { value: 2 }
  });
  const radii = defineTokens.radii({
    none: { value: "0" },
    "2xs": { value: "0.0625rem" },
    xs: { value: "0.125rem" },
    sm: { value: "0.25rem" },
    md: { value: "0.375rem" },
    lg: { value: "0.5rem" },
    xl: { value: "0.75rem" },
    "2xl": { value: "1rem" },
    "3xl": { value: "1.5rem" },
    "4xl": { value: "2rem" },
    full: { value: "9999px" }
  });
  const spacing = defineTokens.spacing({
    0.5: { value: "0.125rem" },
    1: { value: "0.25rem" },
    1.5: { value: "0.375rem" },
    2: { value: "0.5rem" },
    2.5: { value: "0.625rem" },
    3: { value: "0.75rem" },
    3.5: { value: "0.875rem" },
    4: { value: "1rem" },
    4.5: { value: "1.125rem" },
    5: { value: "1.25rem" },
    6: { value: "1.5rem" },
    7: { value: "1.75rem" },
    8: { value: "2rem" },
    9: { value: "2.25rem" },
    10: { value: "2.5rem" },
    11: { value: "2.75rem" },
    12: { value: "3rem" },
    14: { value: "3.5rem" },
    16: { value: "4rem" },
    20: { value: "5rem" },
    24: { value: "6rem" },
    28: { value: "7rem" },
    32: { value: "8rem" },
    36: { value: "9rem" },
    40: { value: "10rem" },
    44: { value: "11rem" },
    48: { value: "12rem" },
    52: { value: "13rem" },
    56: { value: "14rem" },
    60: { value: "15rem" },
    64: { value: "16rem" },
    72: { value: "18rem" },
    80: { value: "20rem" },
    96: { value: "24rem" }
  });
  const largeSizes = defineTokens.sizes({
    "3xs": { value: "14rem" },
    "2xs": { value: "16rem" },
    xs: { value: "20rem" },
    sm: { value: "24rem" },
    md: { value: "28rem" },
    lg: { value: "32rem" },
    xl: { value: "36rem" },
    "2xl": { value: "42rem" },
    "3xl": { value: "48rem" },
    "4xl": { value: "56rem" },
    "5xl": { value: "64rem" },
    "6xl": { value: "72rem" },
    "7xl": { value: "80rem" },
    "8xl": { value: "90rem" }
  });
  const namedSizes = defineTokens.sizes({
    max: { value: "max-content" },
    min: { value: "min-content" },
    fit: { value: "fit-content" },
    prose: { value: "60ch" },
    full: { value: "100%" },
    dvh: { value: "100dvh" },
    svh: { value: "100svh" },
    lvh: { value: "100lvh" },
    dvw: { value: "100dvw" },
    svw: { value: "100svw" },
    lvw: { value: "100lvw" },
    vw: { value: "100vw" },
    vh: { value: "100vh" }
  });
  const fractionalSizes = defineTokens.sizes({
    "1/2": { value: "50%" },
    "1/3": { value: "33.333333%" },
    "2/3": { value: "66.666667%" },
    "1/4": { value: "25%" },
    "3/4": { value: "75%" },
    "1/5": { value: "20%" },
    "2/5": { value: "40%" },
    "3/5": { value: "60%" },
    "4/5": { value: "80%" },
    "1/6": { value: "16.666667%" },
    "2/6": { value: "33.333333%" },
    "3/6": { value: "50%" },
    "4/6": { value: "66.666667%" },
    "5/6": { value: "83.333333%" },
    "1/12": { value: "8.333333%" },
    "2/12": { value: "16.666667%" },
    "3/12": { value: "25%" },
    "4/12": { value: "33.333333%" },
    "5/12": { value: "41.666667%" },
    "6/12": { value: "50%" },
    "7/12": { value: "58.333333%" },
    "8/12": { value: "66.666667%" },
    "9/12": { value: "75%" },
    "10/12": { value: "83.333333%" },
    "11/12": { value: "91.666667%" }
  });
  const sizes = defineTokens.sizes({
    ...largeSizes,
    ...spacing,
    ...fractionalSizes,
    ...namedSizes
  });
  const zIndices = defineTokens.zIndex({
    hide: { value: -1 },
    base: { value: 0 },
    docked: { value: 10 },
    dropdown: { value: 1e3 },
    sticky: { value: 1100 },
    banner: { value: 1200 },
    overlay: { value: 1300 },
    modal: { value: 1400 },
    popover: { value: 1500 },
    skipNav: { value: 1600 },
    toast: { value: 1700 },
    tooltip: { value: 1800 },
    max: { value: 2147483647 }
  });
  const tokens = {
    aspectRatios,
    animations: animations$1,
    blurs,
    borders: borders$1,
    colors,
    durations,
    easings,
    fonts,
    fontSizes,
    fontWeights,
    letterSpacings,
    lineHeights,
    radii,
    spacing,
    sizes,
    zIndex: zIndices,
    cursor
  };
  const semanticTokens = {
    colors: semanticColors,
    shadows: semanticShadows,
    radii: semanticRadii
  };
  const cssVarsPrefix = "chakra";
  const cssVarsRoot = ":where(html, .chakra-theme)";
  const defaultThemeConfig = defineConfig({
    preflight: true,
    cssVarsPrefix,
    cssVarsRoot,
    globalCss,
    theme: {
      breakpoints,
      keyframes: keyframes$1,
      tokens,
      semanticTokens,
      recipes,
      slotRecipes,
      textStyles,
      layerStyles,
      animationStyles
    }
  });
  const defaultConfig = mergeConfigs(defaultBaseConfig, defaultThemeConfig);
  const defaultSystem = createSystem(defaultConfig);
  function useSlotRecipe(options) {
    const { key, recipe: recipeProp } = options;
    const sys = useChakraContext();
    return reactExports.useMemo(() => {
      const recipe = recipeProp || (key != null ? sys.getSlotRecipe(key) : {});
      return sys.sva(structuredClone(recipe));
    }, [key, recipeProp, sys]);
  }
  const upperFirst = (str) => str.charAt(0).toUpperCase() + str.slice(1);
  const createSlotRecipeContext = (options) => {
    const { key: recipeKey, recipe: recipeConfig } = options;
    const contextName = upperFirst(
      recipeKey || recipeConfig.className || "Component"
    );
    const [StylesProvider, useStyles] = createContext$1({
      name: `${contextName}StylesContext`,
      errorMessage: `use${contextName}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `
    });
    const [ClassNamesProvider, useClassNames] = createContext$1({
      name: `${contextName}ClassNameContext`,
      errorMessage: `use${contextName}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${contextName}.Root />" `,
      strict: false
    });
    const [PropsProvider, usePropsContext2] = createContext$1({
      strict: false,
      name: `${contextName}PropsContext`,
      providerName: `${contextName}PropsContext`,
      defaultValue: {}
    });
    function useRecipeResult2(props) {
      const { unstyled, ...restProps } = props;
      const slotRecipe = useSlotRecipe({
        key: recipeKey,
        recipe: restProps.recipe || recipeConfig
      });
      const [variantProps2, otherProps] = reactExports.useMemo(
        () => slotRecipe.splitVariantProps(restProps),
        [restProps, slotRecipe]
      );
      const styles = reactExports.useMemo(
        () => unstyled ? EMPTY_SLOT_STYLES : slotRecipe(variantProps2),
        [unstyled, variantProps2, slotRecipe]
      );
      return {
        styles,
        classNames: slotRecipe.classNameMap,
        props: otherProps
      };
    }
    function withRootProvider(Component, options2 = {}) {
      const { defaultProps } = options2;
      const StyledComponent = (inProps) => {
        const propsContext = usePropsContext2();
        const props = reactExports.useMemo(
          () => mergeProps$1(defaultProps, propsContext, inProps),
          [propsContext, inProps]
        );
        const { styles, classNames, props: rootProps } = useRecipeResult2(props);
        return jsxRuntimeExports.jsx(StylesProvider, { value: styles, children: jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames, children: jsxRuntimeExports.jsx(Component, { ...rootProps }) }) });
      };
      StyledComponent.displayName = Component.displayName || Component.name;
      return StyledComponent;
    }
    const withProvider2 = (Component, slot, options2) => {
      const { defaultProps, ...restOptions } = options2 ?? {};
      const SuperComponent = chakra(Component, {}, restOptions);
      const StyledComponent = reactExports.forwardRef((inProps, ref) => {
        const propsContext = usePropsContext2();
        const props = reactExports.useMemo(
          () => mergeProps$1(defaultProps ?? {}, propsContext, inProps),
          [propsContext, inProps]
        );
        const { styles, props: rootProps, classNames } = useRecipeResult2(props);
        const className = classNames[slot];
        const element = jsxRuntimeExports.jsx(StylesProvider, { value: styles, children: jsxRuntimeExports.jsx(ClassNamesProvider, { value: classNames, children: jsxRuntimeExports.jsx(
          SuperComponent,
          {
            ref,
            ...rootProps,
            css: [styles[slot], props.css],
            className: cx(props.className, className)
          }
        ) }) });
        return options2?.wrapElement?.(element, props) ?? element;
      });
      StyledComponent.displayName = Component.displayName || Component.name;
      return StyledComponent;
    };
    const withContext2 = (Component, slot, options2) => {
      const SuperComponent = chakra(Component, {}, options2);
      const StyledComponent = reactExports.forwardRef((props, ref) => {
        const { unstyled, ...restProps } = props;
        const styles = useStyles();
        const classNames = useClassNames();
        const className = classNames?.[slot];
        return jsxRuntimeExports.jsx(
          SuperComponent,
          {
            ...restProps,
            css: [!unstyled && slot ? styles[slot] : void 0, props.css],
            ref,
            className: cx(props.className, className)
          }
        );
      });
      StyledComponent.displayName = Component.displayName || Component.name;
      return StyledComponent;
    };
    return {
      StylesProvider,
      ClassNamesProvider,
      PropsProvider,
      usePropsContext: usePropsContext2,
      useRecipeResult: useRecipeResult2,
      withProvider: withProvider2,
      withContext: withContext2,
      withRootProvider,
      useStyles,
      useClassNames
    };
  };
  const AbsoluteCenter = chakra("div", {
    base: {
      position: "absolute",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    variants: {
      axis: {
        horizontal: {
          insetStart: "50%",
          translate: "-50%",
          _rtl: {
            translate: "50%"
          }
        },
        vertical: {
          top: "50%",
          translate: "0 -50%"
        },
        both: {
          insetStart: "50%",
          top: "50%",
          translate: "-50% -50%",
          _rtl: {
            translate: "50% -50%"
          }
        }
      }
    },
    defaultVariants: {
      axis: "both"
    }
  });
  AbsoluteCenter.displayName = "AbsoluteCenter";
  const dataAttr = (condition) => condition ? "" : void 0;
  const { withContext: withContext$4 } = createRecipeContext({
    key: "spinner"
  });
  const Spinner = withContext$4("span");
  Spinner.displayName = "Spinner";
  const Loader = reactExports.forwardRef(
    function Loader2(props, ref) {
      const {
        spinner = jsxRuntimeExports.jsx(Spinner, { size: "inherit", borderWidth: "0.125em", color: "inherit" }),
        spinnerPlacement = "start",
        children,
        text,
        visible = true,
        ...rest
      } = props;
      if (!visible) return children;
      if (text) {
        return jsxRuntimeExports.jsxs(Span, { ref, display: "contents", ...rest, children: [
          spinnerPlacement === "start" && spinner,
          text,
          spinnerPlacement === "end" && spinner
        ] });
      }
      if (spinner) {
        return jsxRuntimeExports.jsxs(Span, { ref, display: "contents", ...rest, children: [
jsxRuntimeExports.jsx(AbsoluteCenter, { display: "inline-flex", children: spinner }),
jsxRuntimeExports.jsx(Span, { visibility: "hidden", display: "contents", children })
        ] });
      }
      return jsxRuntimeExports.jsx(Span, { ref, display: "contents", ...rest, children });
    }
  );
  Loader.displayName = "Loader";
  const { useRecipeResult: useRecipeResult$1, usePropsContext } = createRecipeContext(
    { key: "button" }
  );
  const Button = reactExports.forwardRef(
    function Button2(inProps, ref) {
      const propsContext = usePropsContext();
      const props = reactExports.useMemo(
        () => mergeProps$1(propsContext, inProps),
        [propsContext, inProps]
      );
      const result = useRecipeResult$1(props);
      const {
        loading,
        loadingText,
        children,
        spinner,
        spinnerPlacement,
        ...rest
      } = result.props;
      return jsxRuntimeExports.jsx(
        chakra.button,
        {
          type: "button",
          ref,
          ...rest,
          "data-loading": dataAttr(loading),
          disabled: loading || rest.disabled,
          className: cx(result.className, props.className),
          css: [result.styles, props.css],
          children: !props.asChild && loading ? jsxRuntimeExports.jsx(
            Loader,
            {
              spinner,
              text: loadingText,
              spinnerPlacement,
              children
            }
          ) : children
        }
      );
    }
  );
  Button.displayName = "Button";
  const IconButton = reactExports.forwardRef(
    function IconButton2(props, ref) {
      return jsxRuntimeExports.jsx(
        Button,
        {
          px: "0",
          py: "0",
          _icon: { fontSize: "1.2em" },
          ref,
          ...props
        }
      );
    }
  );
  IconButton.displayName = "IconButton";
  function Show(props) {
    const { when, fallback: fallback2, children } = props;
    let result;
    if (!when) {
      result = fallback2;
    } else {
      result = typeof children === "function" ? children(when) : children;
    }
    return reactExports.isValidElement(result) ? result : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: result });
  }
  const ClientOnly = (props) => {
    const { children, fallback: fallback2 } = props;
    const [hasMounted, setHasMounted] = reactExports.useState(false);
    reactExports.useEffect(() => {
      setHasMounted(true);
    }, []);
    return jsxRuntimeExports.jsx(Show, { when: hasMounted, fallback: fallback2, children });
  };
  function getSeparatorStyles(options) {
    const { gap, direction } = options;
    const styles = {
      column: {
        marginY: gap,
        marginX: 0,
        borderInlineStartWidth: 0,
        borderTopWidth: "1px"
      },
      "column-reverse": {
        marginY: gap,
        marginX: 0,
        borderInlineStartWidth: 0,
        borderTopWidth: "1px"
      },
      row: {
        marginX: gap,
        marginY: 0,
        borderInlineStartWidth: "1px",
        borderTopWidth: 0
      },
      "row-reverse": {
        marginX: gap,
        marginY: 0,
        borderInlineStartWidth: "1px",
        borderTopWidth: 0
      }
    };
    return {
      "&": mapObject(direction, (value) => styles[value])
    };
  }
  function getValidChildren(children) {
    return reactExports.Children.toArray(children).filter(
      (child) => reactExports.isValidElement(child)
    );
  }
  const Stack = reactExports.forwardRef(
    function Stack2(props, ref) {
      const {
        direction = "column",
        align,
        justify,
        gap = "0.5rem",
        wrap: wrap2,
        children,
        separator,
        className,
        ...rest
      } = props;
      const separatorStyle = reactExports.useMemo(
        () => getSeparatorStyles({ gap, direction }),
        [gap, direction]
      );
      const clones = reactExports.useMemo(() => {
        if (!reactExports.isValidElement(separator)) return children;
        return getValidChildren(children).map((child, index, arr) => {
          const key = typeof child.key !== "undefined" ? child.key : index;
          const typedSep = separator;
          const sep = reactExports.cloneElement(typedSep, {
            css: [separatorStyle, typedSep.props.css]
          });
          return jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
            child,
            index === arr.length - 1 ? null : sep
          ] }, key);
        });
      }, [children, separator, separatorStyle]);
      return jsxRuntimeExports.jsx(
        chakra.div,
        {
          ref,
          display: "flex",
          alignItems: align,
          justifyContent: justify,
          flexDirection: direction,
          flexWrap: wrap2,
          gap: separator ? void 0 : gap,
          className: cx("chakra-stack", className),
          ...rest,
          children: clones
        }
      );
    }
  );
  Stack.displayName = "Stack";
  function For(props) {
    const { each, fallback: fallback2, children } = props;
    if (each?.length === 0) {
      return fallback2 || null;
    }
    return each?.map(children);
  }
  const Flex = reactExports.forwardRef(
    function Flex2(props, ref) {
      const {
        direction,
        align,
        justify,
        wrap: wrap2,
        basis,
        grow,
        shrink,
        inline,
        ...rest
      } = props;
      return jsxRuntimeExports.jsx(
        chakra.div,
        {
          ref,
          ...rest,
          css: {
            display: inline ? "inline-flex" : "flex",
            flexDirection: direction,
            alignItems: align,
            justifyContent: justify,
            flexWrap: wrap2,
            flexBasis: basis,
            flexGrow: grow,
            flexShrink: shrink,
            ...props.css
          }
        }
      );
    }
  );
  Flex.displayName = "Flex";
  const { withContext: withContext$3 } = createRecipeContext({
    key: "link"
  });
  const Link = withContext$3("a");
  Link.displayName = "Link";
  const {
    withProvider: withProvider$1,
    withContext: withContext$2
  } = createSlotRecipeContext({ key: "scrollArea" });
  withProvider$1(ScrollAreaRootProvider, "root", { forwardAsChild: true });
  const ScrollAreaRoot = withProvider$1(
    ScrollAreaRoot$1,
    "root",
    { forwardAsChild: true }
  );
  const ScrollAreaViewport = withContext$2(ScrollAreaViewport$1, "viewport", { forwardAsChild: true });
  const ScrollAreaContent = withContext$2(ScrollAreaContent$1, "content", { forwardAsChild: true });
  const ScrollAreaThumb = withContext$2(ScrollAreaThumb$1, "thumb", { forwardAsChild: true });
  withContext$2(ScrollAreaScrollbar, "scrollbar", {
    forwardAsChild: true,
    defaultProps: {
      children: jsxRuntimeExports.jsx(ScrollAreaThumb, {})
    }
  });
  withContext$2(ScrollAreaCorner, "corner", { forwardAsChild: true });
  const { useRecipeResult } = createRecipeContext({
    key: "separator"
  });
  const Separator = reactExports.forwardRef(
    function Separator2(props, ref) {
      const { styles, className, props: otherProps } = useRecipeResult(props);
      const orientation = props.orientation || "horizontal";
      return jsxRuntimeExports.jsx(
        chakra.span,
        {
          ref,
          role: isString$1(orientation) ? "separator" : "presentation",
          "aria-orientation": isString$1(orientation) ? orientation : void 0,
          ...omit(otherProps, ["orientation"]),
          className: cx(className, props.className),
          css: [styles, props.css]
        }
      );
    }
  );
  Separator.displayName = "Separator";
  const { withContext: withContext$1 } = createRecipeContext({
    key: "skeleton"
  });
  const Skeleton = withContext$1("div");
  Skeleton.displayName = "Skeleton";
  const SkeletonCircle = reactExports.forwardRef(function SkeletonCircle2(props, ref) {
    const { size: size2, ...rest } = props;
    return jsxRuntimeExports.jsx(Circle, { size: size2, asChild: true, ref, children: jsxRuntimeExports.jsx(Skeleton, { ...rest }) });
  });
  SkeletonCircle.displayName = "SkeletonCircle";
  const SkeletonText = reactExports.forwardRef(
    function SkeletonText2(props, ref) {
      const { noOfLines = 3, gap, rootProps, ...rest } = props;
      return jsxRuntimeExports.jsx(Stack, { gap, width: "full", ref, ...rootProps, children: Array.from({ length: noOfLines }).map((_2, index) => jsxRuntimeExports.jsx(
        Skeleton,
        {
          height: "4",
          _last: { maxW: noOfLines === 1 ? "100%" : "80%" },
          ...rest
        },
        index
      )) });
    }
  );
  SkeletonText.displayName = "SkeletonText";
  const HStack = reactExports.forwardRef(
    function HStack2(props, ref) {
      return jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "row", ref });
    }
  );
  HStack.displayName = "HStack";
  const VStack = reactExports.forwardRef(
    function VStack2(props, ref) {
      return jsxRuntimeExports.jsx(Stack, { align: "center", ...props, direction: "column", ref });
    }
  );
  VStack.displayName = "VStack";
  const {
    withProvider,
    withContext
  } = createSlotRecipeContext({ key: "tabs" });
  withProvider(TabsRootProvider, "root", { forwardAsChild: true });
  const TabsRoot = withProvider(
    TabsRoot$1,
    "root",
    { forwardAsChild: true }
  );
  const TabsTrigger = withContext(
    TabTrigger,
    "trigger",
    { forwardAsChild: true }
  );
  const TabsContent = withContext(
    TabContent,
    "content",
    { forwardAsChild: true }
  );
  withContext("div", "contentGroup");
  const TabsList = withContext(
    TabList,
    "list",
    { forwardAsChild: true }
  );
  const TabsIndicator = withContext(
    TabIndicator,
    "indicator",
    { forwardAsChild: true }
  );
  const Cell = (props) => {
    const $ = compilerRuntimeExports.c(2);
    let t0;
    if ($[0] !== props) {
      t0 = jsxRuntimeExports.jsx(Box, { h: "150px", bg: "whiteAlpha.500", borderRadius: "md", padding: "1", ...props });
      $[0] = props;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  };
  const LayoutGroupContext = reactExports.createContext({});
  function useConstant(init) {
    const ref = reactExports.useRef(null);
    if (ref.current === null) {
      ref.current = init();
    }
    return ref.current;
  }
  const isBrowser = typeof window !== "undefined";
  const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
  const PresenceContext = reactExports.createContext(null);
  function addUniqueItem(arr, item) {
    if (arr.indexOf(item) === -1)
      arr.push(item);
  }
  function removeItem(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1)
      arr.splice(index, 1);
  }
  const clamp = (min2, max2, v) => {
    if (v > max2)
      return max2;
    if (v < min2)
      return min2;
    return v;
  };
  let invariant = () => {
  };
  const MotionGlobalConfig = {};
  const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }
  const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
function memo(callback) {
    let result;
    return () => {
      if (result === void 0)
        result = callback();
      return result;
    };
  }
  const noop = (any) => any;
  const combineFunctions = (a, b2) => (v) => b2(a(v));
  const pipe = (...transformers) => transformers.reduce(combineFunctions);
  const progress = (from2, to, value) => {
    const toFromDifference = to - from2;
    return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
  };
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(handler) {
      addUniqueItem(this.subscriptions, handler);
      return () => removeItem(this.subscriptions, handler);
    }
    notify(a, b2, c) {
      const numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a, b2, c);
      } else {
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b2, c);
        }
      }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const secondsToMilliseconds = (seconds) => seconds * 1e3;
  const millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
  function velocityPerSecond(velocity, frameDuration) {
    return frameDuration ? velocity * (1e3 / frameDuration) : 0;
  }
  const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
  const subdivisionPrecision = 1e-7;
  const subdivisionMaxIterations = 12;
  function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x2;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noop;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
  }
  const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
  const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
  const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
  const backIn = reverseEasing(backOut);
  const backInOut = mirrorEasing(backIn);
  const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
  const circIn = (p) => 1 - Math.sin(Math.acos(p));
  const circOut = reverseEasing(circIn);
  const circInOut = mirrorEasing(circIn);
  const easeIn = cubicBezier(0.42, 0, 1, 1);
  const easeOut = cubicBezier(0, 0, 0.58, 1);
  const easeInOut = cubicBezier(0.42, 0, 0.58, 1);
  const isEasingArray = (ease2) => {
    return Array.isArray(ease2) && typeof ease2[0] !== "number";
  };
  const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
  const easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
  };
  const isValidEasing = (easing) => {
    return typeof easing === "string";
  };
  const easingDefinitionToFunction = (definition) => {
    if (isBezierDefinition(definition)) {
      invariant(definition.length === 4);
      const [x1, y1, x2, y2] = definition;
      return cubicBezier(x1, y1, x2, y2);
    } else if (isValidEasing(definition)) {
      return easingLookup[definition];
    }
    return definition;
  };
  const stepsOrder = [
    "setup",
"read",
"resolveKeyframes",
"preUpdate",
"update",
"preRender",
"render",
"postRender"
];
  function createRenderStep(runNextFrame, stepName) {
    let thisFrame = new Set();
    let nextFrame = new Set();
    let isProcessing = false;
    let flushNextFrame = false;
    const toKeepAlive = new WeakSet();
    let latestFrameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    function triggerCallback(callback) {
      if (toKeepAlive.has(callback)) {
        step.schedule(callback);
        runNextFrame();
      }
      callback(latestFrameData);
    }
    const step = {
schedule: (callback, keepAlive = false, immediate = false) => {
        const addToCurrentFrame = immediate && isProcessing;
        const queue = addToCurrentFrame ? thisFrame : nextFrame;
        if (keepAlive)
          toKeepAlive.add(callback);
        if (!queue.has(callback))
          queue.add(callback);
        return callback;
      },
cancel: (callback) => {
        nextFrame.delete(callback);
        toKeepAlive.delete(callback);
      },
process: (frameData2) => {
        latestFrameData = frameData2;
        if (isProcessing) {
          flushNextFrame = true;
          return;
        }
        isProcessing = true;
        [thisFrame, nextFrame] = [nextFrame, thisFrame];
        thisFrame.forEach(triggerCallback);
        thisFrame.clear();
        isProcessing = false;
        if (flushNextFrame) {
          flushNextFrame = false;
          step.process(frameData2);
        }
      }
    };
    return step;
  }
  const maxElapsed = 40;
  function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
    let runNextFrame = false;
    let useDefaultElapsed = true;
    const state2 = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    const flagRunNextFrame = () => runNextFrame = true;
    const steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(flagRunNextFrame);
      return acc;
    }, {});
    const { setup: setup2, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
    const processBatch = () => {
      const timestamp = MotionGlobalConfig.useManualTiming ? state2.timestamp : performance.now();
      runNextFrame = false;
      if (!MotionGlobalConfig.useManualTiming) {
        state2.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state2.timestamp, maxElapsed), 1);
      }
      state2.timestamp = timestamp;
      state2.isProcessing = true;
      setup2.process(state2);
      read.process(state2);
      resolveKeyframes.process(state2);
      preUpdate.process(state2);
      update.process(state2);
      preRender.process(state2);
      render.process(state2);
      postRender.process(state2);
      state2.isProcessing = false;
      if (runNextFrame && allowKeepAlive) {
        useDefaultElapsed = false;
        scheduleNextBatch(processBatch);
      }
    };
    const wake = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!state2.isProcessing) {
        scheduleNextBatch(processBatch);
      }
    };
    const schedule = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          wake();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    const cancel = (process2) => {
      for (let i = 0; i < stepsOrder.length; i++) {
        steps[stepsOrder[i]].cancel(process2);
      }
    };
    return { schedule, cancel, state: state2, steps };
  }
  const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
  let now;
  function clearTime() {
    now = void 0;
  }
  const time = {
    now: () => {
      if (now === void 0) {
        time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
      }
      return now;
    },
    set: (newTime) => {
      now = newTime;
      queueMicrotask(clearTime);
    }
  };
  const checkStringStartsWith = (token2) => (key) => typeof key === "string" && key.startsWith(token2);
  const isCSSVariableName = checkStringStartsWith("--");
  const startsAsVariableToken = checkStringStartsWith("var(--");
  const isCSSVariableToken = (value) => {
    const startsWithToken = startsAsVariableToken(value);
    if (!startsWithToken)
      return false;
    return singleCssVariableRegex.test(value.split("/*")[0].trim());
  };
  const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
  const number = {
    test: (v) => typeof v === "number",
    parse: parseFloat,
    transform: (v) => v
  };
  const alpha = {
    ...number,
    transform: (v) => clamp(0, 1, v)
  };
  const scale = {
    ...number,
    default: 1
  };
  const sanitize = (v) => Math.round(v * 1e5) / 1e5;
  const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function isNullish(v) {
    return v == null;
  }
  const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
  const isColorString = (type, testProp) => (v) => {
    return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
  };
  const splitColor = (aName, bName, cName) => (v) => {
    if (typeof v !== "string")
      return v;
    const [a, b2, c, alpha2] = v.match(floatRegex);
    return {
      [aName]: parseFloat(a),
      [bName]: parseFloat(b2),
      [cName]: parseFloat(c),
      alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
    };
  };
  const clampRgbUnit = (v) => clamp(0, 255, v);
  const rgbUnit = {
    ...number,
    transform: (v) => Math.round(clampRgbUnit(v))
  };
  const rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
  };
  function parseHex(v) {
    let r = "";
    let g = "";
    let b2 = "";
    let a = "";
    if (v.length > 5) {
      r = v.substring(1, 3);
      g = v.substring(3, 5);
      b2 = v.substring(5, 7);
      a = v.substring(7, 9);
    } else {
      r = v.substring(1, 2);
      g = v.substring(2, 3);
      b2 = v.substring(3, 4);
      a = v.substring(4, 5);
      r += r;
      g += g;
      b2 += b2;
      a += a;
    }
    return {
      red: parseInt(r, 16),
      green: parseInt(g, 16),
      blue: parseInt(b2, 16),
      alpha: a ? parseInt(a, 16) / 255 : 1
    };
  }
  const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
  };
  const createUnitType = (unit) => ({
    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
    parse: parseFloat,
    transform: (v) => `${v}${unit}`
  });
  const degrees = createUnitType("deg");
  const percent = createUnitType("%");
  const px = createUnitType("px");
  const vh = createUnitType("vh");
  const vw = createUnitType("vw");
  const progressPercentage = (() => ({
    ...percent,
    parse: (v) => percent.parse(v) / 100,
    transform: (v) => percent.transform(v * 100)
  }))();
  const hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
      return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
    }
  };
  const color = {
    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
    parse: (v) => {
      if (rgba.test(v)) {
        return rgba.parse(v);
      } else if (hsla.test(v)) {
        return hsla.parse(v);
      } else {
        return hex.parse(v);
      }
    },
    transform: (v) => {
      return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
    },
    getAnimatableNone: (v) => {
      const parsed = color.parse(v);
      parsed.alpha = 0;
      return color.transform(parsed);
    }
  };
  const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function test(v) {
    return isNaN(v) && typeof v === "string" && (v.match(floatRegex)?.length || 0) + (v.match(colorRegex)?.length || 0) > 0;
  }
  const NUMBER_TOKEN = "number";
  const COLOR_TOKEN = "color";
  const VAR_TOKEN = "var";
  const VAR_FUNCTION_TOKEN = "var(";
  const SPLIT_TOKEN = "${}";
  const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(value) {
    const originalValue = value.toString();
    const values = [];
    const indexes = {
      color: [],
      number: [],
      var: []
    };
    const types = [];
    let i = 0;
    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
      if (color.test(parsedValue)) {
        indexes.color.push(i);
        types.push(COLOR_TOKEN);
        values.push(color.parse(parsedValue));
      } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
        indexes.var.push(i);
        types.push(VAR_TOKEN);
        values.push(parsedValue);
      } else {
        indexes.number.push(i);
        types.push(NUMBER_TOKEN);
        values.push(parseFloat(parsedValue));
      }
      ++i;
      return SPLIT_TOKEN;
    });
    const split = tokenised.split(SPLIT_TOKEN);
    return { values, split, indexes, types };
  }
  function parseComplexValue(v) {
    return analyseComplexValue(v).values;
  }
  function createTransformer(source) {
    const { split, types } = analyseComplexValue(source);
    const numSections = split.length;
    return (v) => {
      let output = "";
      for (let i = 0; i < numSections; i++) {
        output += split[i];
        if (v[i] !== void 0) {
          const type = types[i];
          if (type === NUMBER_TOKEN) {
            output += sanitize(v[i]);
          } else if (type === COLOR_TOKEN) {
            output += color.transform(v[i]);
          } else {
            output += v[i];
          }
        }
      }
      return output;
    };
  }
  const convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
  function getAnimatableNone$1(v) {
    const parsed = parseComplexValue(v);
    const transformer = createTransformer(v);
    return transformer(parsed.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
  };
  function hueToRgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
    hue /= 360;
    saturation /= 100;
    lightness /= 100;
    let red = 0;
    let green = 0;
    let blue = 0;
    if (!saturation) {
      red = green = blue = lightness;
    } else {
      const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
      const p = 2 * lightness - q;
      red = hueToRgb(p, q, hue + 1 / 3);
      green = hueToRgb(p, q, hue);
      blue = hueToRgb(p, q, hue - 1 / 3);
    }
    return {
      red: Math.round(red * 255),
      green: Math.round(green * 255),
      blue: Math.round(blue * 255),
      alpha: alpha2
    };
  }
  function mixImmediate(a, b2) {
    return (p) => p > 0 ? b2 : a;
  }
  const mixNumber$1 = (from2, to, progress2) => {
    return from2 + (to - from2) * progress2;
  };
  const mixLinearColor = (from2, to, v) => {
    const fromExpo = from2 * from2;
    const expo = v * (to * to - fromExpo) + fromExpo;
    return expo < 0 ? 0 : Math.sqrt(expo);
  };
  const colorTypes = [hex, rgba, hsla];
  const getColorType = (v) => colorTypes.find((type) => type.test(v));
  function asRGBA(color2) {
    const type = getColorType(color2);
    if (!Boolean(type))
      return false;
    let model = type.parse(color2);
    if (type === hsla) {
      model = hslaToRgba(model);
    }
    return model;
  }
  const mixColor = (from2, to) => {
    const fromRGBA = asRGBA(from2);
    const toRGBA = asRGBA(to);
    if (!fromRGBA || !toRGBA) {
      return mixImmediate(from2, to);
    }
    const blended = { ...fromRGBA };
    return (v) => {
      blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
      blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
      blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
      blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
      return rgba.transform(blended);
    };
  };
  const invisibleValues = new Set(["none", "hidden"]);
  function mixVisibility(origin, target) {
    if (invisibleValues.has(origin)) {
      return (p) => p <= 0 ? origin : target;
    } else {
      return (p) => p >= 1 ? target : origin;
    }
  }
  function mixNumber(a, b2) {
    return (p) => mixNumber$1(a, b2, p);
  }
  function getMixer(a) {
    if (typeof a === "number") {
      return mixNumber;
    } else if (typeof a === "string") {
      return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
    } else if (Array.isArray(a)) {
      return mixArray;
    } else if (typeof a === "object") {
      return color.test(a) ? mixColor : mixObject;
    }
    return mixImmediate;
  }
  function mixArray(a, b2) {
    const output = [...a];
    const numValues = output.length;
    const blendValue = a.map((v, i) => getMixer(v)(v, b2[i]));
    return (p) => {
      for (let i = 0; i < numValues; i++) {
        output[i] = blendValue[i](p);
      }
      return output;
    };
  }
  function mixObject(a, b2) {
    const output = { ...a, ...b2 };
    const blendValue = {};
    for (const key in output) {
      if (a[key] !== void 0 && b2[key] !== void 0) {
        blendValue[key] = getMixer(a[key])(a[key], b2[key]);
      }
    }
    return (v) => {
      for (const key in blendValue) {
        output[key] = blendValue[key](v);
      }
      return output;
    };
  }
  function matchOrder(origin, target) {
    const orderedOrigin = [];
    const pointers = { color: 0, var: 0, number: 0 };
    for (let i = 0; i < target.values.length; i++) {
      const type = target.types[i];
      const originIndex = origin.indexes[type][pointers[type]];
      const originValue = origin.values[originIndex] ?? 0;
      orderedOrigin[i] = originValue;
      pointers[type]++;
    }
    return orderedOrigin;
  }
  const mixComplex = (origin, target) => {
    const template = complex.createTransformer(target);
    const originStats = analyseComplexValue(origin);
    const targetStats = analyseComplexValue(target);
    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
    if (canInterpolate) {
      if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
        return mixVisibility(origin, target);
      }
      return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
    } else {
      return mixImmediate(origin, target);
    }
  };
  function mix(from2, to, p) {
    if (typeof from2 === "number" && typeof to === "number" && typeof p === "number") {
      return mixNumber$1(from2, to, p);
    }
    const mixer = getMixer(from2);
    return mixer(from2, to);
  }
  const frameloopDriver = (update) => {
    const passTimestamp = ({ timestamp }) => update(timestamp);
    return {
      start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
      stop: () => cancelFrame(passTimestamp),
now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    };
  };
  const generateLinearEasing = (easing, duration, resolution = 10) => {
    let points = "";
    const numPoints = Math.max(Math.round(duration / resolution), 2);
    for (let i = 0; i < numPoints; i++) {
      points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
    }
    return `linear(${points.substring(0, points.length - 2)})`;
  };
  const maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(generator) {
    let duration = 0;
    const timeStep = 50;
    let state2 = generator.next(duration);
    while (!state2.done && duration < maxGeneratorDuration) {
      duration += timeStep;
      state2 = generator.next(duration);
    }
    return duration >= maxGeneratorDuration ? Infinity : duration;
  }
  function createGeneratorEasing(options, scale2 = 100, createGenerator) {
    const generator = createGenerator({ ...options, keyframes: [0, scale2] });
    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: (progress2) => {
        return generator.next(duration * progress2).value / scale2;
      },
      duration: millisecondsToSeconds(duration)
    };
  }
  const velocitySampleDuration = 5;
  function calcGeneratorVelocity(resolveValue, t, current) {
    const prevT = Math.max(t - velocitySampleDuration, 0);
    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
  }
  const springDefaults = {
stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
duration: 800,
bounce: 0.3,
    visualDuration: 0.3,

restSpeed: {
      granular: 0.01,
      default: 2
    },
    restDelta: {
      granular: 5e-3,
      default: 0.5
    },
minDuration: 0.01,
maxDuration: 10,
minDamping: 0.05,
    maxDamping: 1
  };
  const safeMin = 1e-3;
  function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
    let envelope;
    let derivative;
    let dampingRatio = 1 - bounce;
    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
    if (dampingRatio < 1) {
      envelope = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const a = exponentialDecay - velocity;
        const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
        const c = Math.exp(-delta);
        return safeMin - a / b2 * c;
      };
      derivative = (undampedFreq2) => {
        const exponentialDecay = undampedFreq2 * dampingRatio;
        const delta = exponentialDecay * duration;
        const d = delta * velocity + velocity;
        const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
        const f = Math.exp(-delta);
        const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
        const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
        return factor * ((d - e) * f) / g;
      };
    } else {
      envelope = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b2 = (undampedFreq2 - velocity) * duration + 1;
        return -safeMin + a * b2;
      };
      derivative = (undampedFreq2) => {
        const a = Math.exp(-undampedFreq2 * duration);
        const b2 = (velocity - undampedFreq2) * (duration * duration);
        return a * b2;
      };
    }
    const initialGuess = 5 / duration;
    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
    duration = secondsToMilliseconds(duration);
    if (isNaN(undampedFreq)) {
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration
      };
    } else {
      const stiffness = Math.pow(undampedFreq, 2) * mass;
      return {
        stiffness,
        damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
        duration
      };
    }
  }
  const rootIterations = 12;
  function approximateRoot(envelope, derivative, initialGuess) {
    let result = initialGuess;
    for (let i = 1; i < rootIterations; i++) {
      result = result - envelope(result) / derivative(result);
    }
    return result;
  }
  function calcAngularFreq(undampedFreq, dampingRatio) {
    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
  }
  const durationKeys = ["duration", "bounce"];
  const physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(options, keys) {
    return keys.some((key) => options[key] !== void 0);
  }
  function getSpringOptions(options) {
    let springOptions = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: false,
      ...options
    };
    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
      if (options.visualDuration) {
        const visualDuration = options.visualDuration;
        const root2 = 2 * Math.PI / (visualDuration * 1.2);
        const stiffness = root2 * root2;
        const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
        springOptions = {
          ...springOptions,
          mass: springDefaults.mass,
          stiffness,
          damping
        };
      } else {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          mass: springDefaults.mass
        };
        springOptions.isResolvedFromDuration = true;
      }
    }
    return springOptions;
  }
  function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
    const options = typeof optionsOrVisualDuration !== "object" ? {
      visualDuration: optionsOrVisualDuration,
      keyframes: [0, 1],
      bounce
    } : optionsOrVisualDuration;
    let { restSpeed, restDelta } = options;
    const origin = options.keyframes[0];
    const target = options.keyframes[options.keyframes.length - 1];
    const state2 = { done: false, value: origin };
    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
      ...options,
      velocity: - millisecondsToSeconds(options.velocity || 0)
    });
    const initialVelocity = velocity || 0;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const initialDelta = target - origin;
    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
    restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
    let resolveSpring;
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
        const freqForT = Math.min(dampedAngularFreq * t, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
    const generator = {
      calculatedDuration: isResolvedFromDuration ? duration || null : null,
      next: (t) => {
        const current = resolveSpring(t);
        if (!isResolvedFromDuration) {
          let currentVelocity = t === 0 ? initialVelocity : 0;
          if (dampingRatio < 1) {
            currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
          }
          const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
          const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
          state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
        } else {
          state2.done = t >= duration;
        }
        state2.value = state2.done ? target : current;
        return state2;
      },
      toString: () => {
        const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
        const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
        return calculatedDuration + "ms " + easing;
      },
      toTransition: () => {
      }
    };
    return generator;
  }
  spring.applyToOptions = (options) => {
    const generatorOptions = createGeneratorEasing(options, 100, spring);
    options.ease = generatorOptions.ease;
    options.duration = secondsToMilliseconds(generatorOptions.duration);
    options.type = "keyframes";
    return options;
  };
  function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
    const origin = keyframes2[0];
    const state2 = {
      done: false,
      value: origin
    };
    const isOutOfBounds = (v) => min2 !== void 0 && v < min2 || max2 !== void 0 && v > max2;
    const nearestBoundary = (v) => {
      if (min2 === void 0)
        return max2;
      if (max2 === void 0)
        return min2;
      return Math.abs(min2 - v) < Math.abs(max2 - v) ? min2 : max2;
    };
    let amplitude = power * velocity;
    const ideal = origin + amplitude;
    const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
    if (target !== ideal)
      amplitude = target - origin;
    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
    const calcLatest = (t) => target + calcDelta(t);
    const applyFriction = (t) => {
      const delta = calcDelta(t);
      const latest = calcLatest(t);
      state2.done = Math.abs(delta) <= restDelta;
      state2.value = state2.done ? target : latest;
    };
    let timeReachedBoundary;
    let spring$1;
    const checkCatchBoundary = (t) => {
      if (!isOutOfBounds(state2.value))
        return;
      timeReachedBoundary = t;
      spring$1 = spring({
        keyframes: [state2.value, nearestBoundary(state2.value)],
        velocity: calcGeneratorVelocity(calcLatest, t, state2.value),
damping: bounceDamping,
        stiffness: bounceStiffness,
        restDelta,
        restSpeed
      });
    };
    checkCatchBoundary(0);
    return {
      calculatedDuration: null,
      next: (t) => {
        let hasUpdatedFrame = false;
        if (!spring$1 && timeReachedBoundary === void 0) {
          hasUpdatedFrame = true;
          applyFriction(t);
          checkCatchBoundary(t);
        }
        if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
          return spring$1.next(t - timeReachedBoundary);
        } else {
          !hasUpdatedFrame && applyFriction(t);
          return state2;
        }
      }
    };
  }
  function createMixers(output, ease2, customMixer) {
    const mixers = [];
    const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
    const numMixers = output.length - 1;
    for (let i = 0; i < numMixers; i++) {
      let mixer = mixerFactory(output[i], output[i + 1]);
      if (ease2) {
        const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
        mixer = pipe(easingFunction, mixer);
      }
      mixers.push(mixer);
    }
    return mixers;
  }
  function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
    const inputLength = input.length;
    invariant(inputLength === output.length);
    if (inputLength === 1)
      return () => output[0];
    if (inputLength === 2 && output[0] === output[1])
      return () => output[1];
    const isZeroDeltaRange = input[0] === input[1];
    if (input[0] > input[inputLength - 1]) {
      input = [...input].reverse();
      output = [...output].reverse();
    }
    const mixers = createMixers(output, ease2, mixer);
    const numMixers = mixers.length;
    const interpolator = (v) => {
      if (isZeroDeltaRange && v < input[0])
        return output[0];
      let i = 0;
      if (numMixers > 1) {
        for (; i < input.length - 2; i++) {
          if (v < input[i + 1])
            break;
        }
      }
      const progressInRange = progress(input[i], input[i + 1], v);
      return mixers[i](progressInRange);
    };
    return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
  }
  function fillOffset(offset2, remaining) {
    const min2 = offset2[offset2.length - 1];
    for (let i = 1; i <= remaining; i++) {
      const offsetProgress = progress(0, remaining, i);
      offset2.push(mixNumber$1(min2, 1, offsetProgress));
    }
  }
  function defaultOffset(arr) {
    const offset2 = [0];
    fillOffset(offset2, arr.length - 1);
    return offset2;
  }
  function convertOffsetToTimes(offset2, duration) {
    return offset2.map((o) => o * duration);
  }
  function defaultEasing(values, easing) {
    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
  }
  function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
    const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
    const state2 = {
      done: false,
      value: keyframeValues[0]
    };
    const absoluteTimes = convertOffsetToTimes(

times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
      duration
    );
    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
    return {
      calculatedDuration: duration,
      next: (t) => {
        state2.value = mapTimeToKeyframe(t);
        state2.done = t >= duration;
        return state2;
      }
    };
  }
  const isNotNull$1 = (value) => value !== null;
  function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
    const resolvedKeyframes = keyframes2.filter(isNotNull$1);
    const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
    const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
    return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
  }
  const transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
  };
  function replaceTransitionType(transition) {
    if (typeof transition.type === "string") {
      transition.type = transitionTypeMap[transition.type];
    }
  }
  class WithPromise {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((resolve) => {
        this.resolve = resolve;
      });
    }
    notifyFinished() {
      this.resolve();
    }
then(onResolve, onReject) {
      return this.finished.then(onResolve, onReject);
    }
  }
  const percentToProgress = (percent2) => percent2 / 100;
  class JSAnimation extends WithPromise {
    constructor(options) {
      super();
      this.state = "idle";
      this.startTime = null;
      this.isStopped = false;
      this.currentTime = 0;
      this.holdTime = null;
      this.playbackSpeed = 1;
      this.stop = () => {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
        this.isStopped = true;
        if (this.state === "idle")
          return;
        this.teardown();
        this.options.onStop?.();
      };
      this.options = options;
      this.initAnimation();
      this.play();
      if (options.autoplay === false)
        this.pause();
    }
    initAnimation() {
      const { options } = this;
      replaceTransitionType(options);
      const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
      let { keyframes: keyframes$12 } = options;
      const generatorFactory = type || keyframes;
      if (generatorFactory !== keyframes && typeof keyframes$12[0] !== "number") {
        this.mixKeyframes = pipe(percentToProgress, mix(keyframes$12[0], keyframes$12[1]));
        keyframes$12 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$12 });
      if (repeatType === "mirror") {
        this.mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$12].reverse(),
          velocity: -velocity
        });
      }
      if (generator.calculatedDuration === null) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      this.calculatedDuration = calculatedDuration;
      this.resolvedDuration = calculatedDuration + repeatDelay;
      this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
      this.generator = generator;
    }
    updateTime(timestamp) {
      const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
      if (this.holdTime !== null) {
        this.currentTime = this.holdTime;
      } else {
        this.currentTime = animationTime;
      }
    }
    tick(timestamp, sample = false) {
      const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
      if (this.startTime === null)
        return generator.next(0);
      const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
      if (this.speed > 0) {
        this.startTime = Math.min(this.startTime, timestamp);
      } else if (this.speed < 0) {
        this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
      }
      if (sample) {
        this.currentTime = timestamp;
      } else {
        this.updateTime(timestamp);
      }
      const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
      const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
      this.currentTime = Math.max(timeWithoutDelay, 0);
      if (this.state === "finished" && this.holdTime === null) {
        this.currentTime = totalDuration;
      }
      let elapsed = this.currentTime;
      let frameGenerator = generator;
      if (repeat) {
        const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
        let currentIteration = Math.floor(progress2);
        let iterationProgress = progress2 % 1;
        if (!iterationProgress && progress2 >= 1) {
          iterationProgress = 1;
        }
        iterationProgress === 1 && currentIteration--;
        currentIteration = Math.min(currentIteration, repeat + 1);
        const isOddIteration = Boolean(currentIteration % 2);
        if (isOddIteration) {
          if (repeatType === "reverse") {
            iterationProgress = 1 - iterationProgress;
            if (repeatDelay) {
              iterationProgress -= repeatDelay / resolvedDuration;
            }
          } else if (repeatType === "mirror") {
            frameGenerator = mirroredGenerator;
          }
        }
        elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
      }
      const state2 = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
      if (mixKeyframes) {
        state2.value = mixKeyframes(state2.value);
      }
      let { done } = state2;
      if (!isInDelayPhase && calculatedDuration !== null) {
        done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
      }
      const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
      if (isAnimationFinished && type !== inertia) {
        state2.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
      }
      if (onUpdate) {
        onUpdate(state2.value);
      }
      if (isAnimationFinished) {
        this.finish();
      }
      return state2;
    }
then(resolve, reject) {
      return this.finished.then(resolve, reject);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime);
      this.currentTime = newTime;
      if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
        this.holdTime = newTime;
      } else if (this.driver) {
        this.startTime = this.driver.now() - newTime / this.playbackSpeed;
      }
      this.driver?.start(false);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(newSpeed) {
      this.updateTime(time.now());
      const hasChanged = this.playbackSpeed !== newSpeed;
      this.playbackSpeed = newSpeed;
      if (hasChanged) {
        this.time = millisecondsToSeconds(this.currentTime);
      }
    }
    play() {
      if (this.isStopped)
        return;
      const { driver = frameloopDriver, startTime } = this.options;
      if (!this.driver) {
        this.driver = driver((timestamp) => this.tick(timestamp));
      }
      this.options.onPlay?.();
      const now2 = this.driver.now();
      if (this.state === "finished") {
        this.updateFinished();
        this.startTime = now2;
      } else if (this.holdTime !== null) {
        this.startTime = now2 - this.holdTime;
      } else if (!this.startTime) {
        this.startTime = startTime ?? now2;
      }
      if (this.state === "finished" && this.speed < 0) {
        this.startTime += this.calculatedDuration;
      }
      this.holdTime = null;
      this.state = "running";
      this.driver.start();
    }
    pause() {
      this.state = "paused";
      this.updateTime(time.now());
      this.holdTime = this.currentTime;
    }
    complete() {
      if (this.state !== "running") {
        this.play();
      }
      this.state = "finished";
      this.holdTime = null;
    }
    finish() {
      this.notifyFinished();
      this.teardown();
      this.state = "finished";
      this.options.onComplete?.();
    }
    cancel() {
      this.holdTime = null;
      this.startTime = 0;
      this.tick(0);
      this.teardown();
      this.options.onCancel?.();
    }
    teardown() {
      this.state = "idle";
      this.stopDriver();
      this.startTime = this.holdTime = null;
    }
    stopDriver() {
      if (!this.driver)
        return;
      this.driver.stop();
      this.driver = void 0;
    }
    sample(sampleTime) {
      this.startTime = 0;
      return this.tick(sampleTime, true);
    }
    attachTimeline(timeline) {
      if (this.options.allowFlatten) {
        this.options.type = "keyframes";
        this.options.ease = "linear";
        this.initAnimation();
      }
      this.driver?.stop();
      return timeline.observe(this);
    }
  }
  function fillWildcards(keyframes2) {
    for (let i = 1; i < keyframes2.length; i++) {
      keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
    }
  }
  const radToDeg = (rad) => rad * 180 / Math.PI;
  const rotate = (v) => {
    const angle = radToDeg(Math.atan2(v[1], v[0]));
    return rebaseAngle(angle);
  };
  const matrix2dParsers = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
    rotate,
    rotateZ: rotate,
    skewX: (v) => radToDeg(Math.atan(v[1])),
    skewY: (v) => radToDeg(Math.atan(v[2])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
  };
  const rebaseAngle = (angle) => {
    angle = angle % 360;
    if (angle < 0)
      angle += 360;
    return angle;
  };
  const rotateZ = rotate;
  const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
  const matrix3dParsers = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX,
    scaleY,
    scale: (v) => (scaleX(v) + scaleY(v)) / 2,
    rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
    rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
    rotateZ,
    rotate: rotateZ,
    skewX: (v) => radToDeg(Math.atan(v[4])),
    skewY: (v) => radToDeg(Math.atan(v[1])),
    skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
  };
  function defaultTransformValue(name) {
    return name.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(transform, name) {
    if (!transform || transform === "none") {
      return defaultTransformValue(name);
    }
    const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let parsers;
    let match2;
    if (matrix3dMatch) {
      parsers = matrix3dParsers;
      match2 = matrix3dMatch;
    } else {
      const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      parsers = matrix2dParsers;
      match2 = matrix2dMatch;
    }
    if (!match2) {
      return defaultTransformValue(name);
    }
    const valueParser = parsers[name];
    const values = match2[1].split(",").map(convertTransformToNumber);
    return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
  }
  const readTransformValue = (instance, name) => {
    const { transform = "none" } = getComputedStyle(instance);
    return parseValueFromTransform(transform, name);
  };
  function convertTransformToNumber(value) {
    return parseFloat(value.trim());
  }
  const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY"
  ];
  const transformProps = (() => new Set(transformPropOrder))();
  const isNumOrPxType = (v) => v === number || v === px;
  const transformKeys = new Set(["x", "y", "z"]);
  const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
  function removeNonTranslationalTransform(visualElement) {
    const removedTransforms = [];
    nonTranslationalTransformKeys.forEach((key) => {
      const value = visualElement.getValue(key);
      if (value !== void 0) {
        removedTransforms.push([key, value.get()]);
        value.set(key.startsWith("scale") ? 1 : 0);
      }
    });
    return removedTransforms;
  }
  const positionalValues = {
width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
    top: (_bbox, { top }) => parseFloat(top),
    left: (_bbox, { left }) => parseFloat(left),
    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
    right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
    y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
  };
  positionalValues.translateX = positionalValues.x;
  positionalValues.translateY = positionalValues.y;
  const toResolve = new Set();
  let isScheduled = false;
  let anyNeedsMeasurement = false;
  let isForced = false;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
      const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
      const transformsToRestore = new Map();
      elementsToMeasure.forEach((element) => {
        const removedTransforms = removeNonTranslationalTransform(element);
        if (!removedTransforms.length)
          return;
        transformsToRestore.set(element, removedTransforms);
        element.render();
      });
      resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
      elementsToMeasure.forEach((element) => {
        element.render();
        const restore = transformsToRestore.get(element);
        if (restore) {
          restore.forEach(([key, value]) => {
            element.getValue(key)?.set(value);
          });
        }
      });
      resolversToMeasure.forEach((resolver) => resolver.measureEndState());
      resolversToMeasure.forEach((resolver) => {
        if (resolver.suspendedScrollY !== void 0) {
          window.scrollTo(0, resolver.suspendedScrollY);
        }
      });
    }
    anyNeedsMeasurement = false;
    isScheduled = false;
    toResolve.forEach((resolver) => resolver.complete(isForced));
    toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((resolver) => {
      resolver.readKeyframes();
      if (resolver.needsMeasurement) {
        anyNeedsMeasurement = true;
      }
    });
  }
  function flushKeyframeResolvers() {
    isForced = true;
    readAllKeyframes();
    measureAllKeyframes();
    isForced = false;
  }
  class KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
      this.state = "pending";
      this.isAsync = false;
      this.needsMeasurement = false;
      this.unresolvedKeyframes = [...unresolvedKeyframes];
      this.onComplete = onComplete;
      this.name = name;
      this.motionValue = motionValue2;
      this.element = element;
      this.isAsync = isAsync;
    }
    scheduleResolve() {
      this.state = "scheduled";
      if (this.isAsync) {
        toResolve.add(this);
        if (!isScheduled) {
          isScheduled = true;
          frame.read(readAllKeyframes);
          frame.resolveKeyframes(measureAllKeyframes);
        }
      } else {
        this.readKeyframes();
        this.complete();
      }
    }
    readKeyframes() {
      const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
      if (unresolvedKeyframes[0] === null) {
        const currentValue = motionValue2?.get();
        const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
        if (currentValue !== void 0) {
          unresolvedKeyframes[0] = currentValue;
        } else if (element && name) {
          const valueAsRead = element.readValue(name, finalKeyframe);
          if (valueAsRead !== void 0 && valueAsRead !== null) {
            unresolvedKeyframes[0] = valueAsRead;
          }
        }
        if (unresolvedKeyframes[0] === void 0) {
          unresolvedKeyframes[0] = finalKeyframe;
        }
        if (motionValue2 && currentValue === void 0) {
          motionValue2.set(unresolvedKeyframes[0]);
        }
      }
      fillWildcards(unresolvedKeyframes);
    }
    setFinalKeyframe() {
    }
    measureInitialState() {
    }
    renderEndStyles() {
    }
    measureEndState() {
    }
    complete(isForcedComplete = false) {
      this.state = "complete";
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
      toResolve.delete(this);
    }
    cancel() {
      if (this.state === "scheduled") {
        toResolve.delete(this);
        this.state = "pending";
      }
    }
    resume() {
      if (this.state === "pending")
        this.scheduleResolve();
    }
  }
  const isCSSVar = (name) => name.startsWith("--");
  function setStyle(element, name, value) {
    isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
  }
  const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);
  const supportsFlags = {};
  function memoSupports(callback, supportsFlag) {
    const memoized = memo(callback);
    return () => supportsFlags[supportsFlag] ?? memoized();
  }
  const supportsLinearEasing = memoSupports(() => {
    try {
      document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch (e) {
      return false;
    }
    return true;
  }, "linearEasing");
  const cubicBezierAsString = ([a, b2, c, d]) => `cubic-bezier(${a}, ${b2}, ${c}, ${d})`;
  const supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
  };
  function mapEasingToNativeEasing(easing, duration) {
    if (!easing) {
      return void 0;
    } else if (typeof easing === "function") {
      return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
    } else if (isBezierDefinition(easing)) {
      return cubicBezierAsString(easing);
    } else if (Array.isArray(easing)) {
      return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
    } else {
      return supportedWaapiEasing[easing];
    }
  }
  function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
    const keyframeOptions = {
      [valueName]: keyframes2
    };
    if (times)
      keyframeOptions.offset = times;
    const easing = mapEasingToNativeEasing(ease2, duration);
    if (Array.isArray(easing))
      keyframeOptions.easing = easing;
    const options = {
      delay: delay2,
      duration,
      easing: !Array.isArray(easing) ? easing : "linear",
      fill: "both",
      iterations: repeat + 1,
      direction: repeatType === "reverse" ? "alternate" : "normal"
    };
    if (pseudoElement)
      options.pseudoElement = pseudoElement;
    const animation = element.animate(keyframeOptions, options);
    return animation;
  }
  function isGenerator(type) {
    return typeof type === "function" && "applyToOptions" in type;
  }
  function applyGeneratorOptions({ type, ...options }) {
    if (isGenerator(type) && supportsLinearEasing()) {
      return type.applyToOptions(options);
    } else {
      options.duration ?? (options.duration = 300);
      options.ease ?? (options.ease = "easeOut");
    }
    return options;
  }
  class NativeAnimation extends WithPromise {
    constructor(options) {
      super();
      this.finishedTime = null;
      this.isStopped = false;
      if (!options)
        return;
      const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
      this.isPseudoElement = Boolean(pseudoElement);
      this.allowFlatten = allowFlatten;
      this.options = options;
      invariant(typeof options.type !== "string");
      const transition = applyGeneratorOptions(options);
      this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
      if (transition.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = () => {
        this.finishedTime = this.time;
        if (!pseudoElement) {
          const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
          if (this.updateMotionValue) {
            this.updateMotionValue(keyframe);
          } else {
            setStyle(element, name, keyframe);
          }
          this.animation.cancel();
        }
        onComplete?.();
        this.notifyFinished();
      };
    }
    play() {
      if (this.isStopped)
        return;
      this.animation.play();
      if (this.state === "finished") {
        this.updateFinished();
      }
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch (e) {
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      const { state: state2 } = this;
      if (state2 === "idle" || state2 === "finished") {
        return;
      }
      if (this.updateMotionValue) {
        this.updateMotionValue();
      } else {
        this.commitStyles();
      }
      if (!this.isPseudoElement)
        this.cancel();
    }
commitStyles() {
      if (!this.isPseudoElement) {
        this.animation.commitStyles?.();
      }
    }
    get duration() {
      const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(duration));
    }
    get iterationDuration() {
      const { delay: delay2 = 0 } = this.options || {};
      return this.duration + millisecondsToSeconds(delay2);
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(newTime) {
      this.finishedTime = null;
      this.animation.currentTime = secondsToMilliseconds(newTime);
    }
get speed() {
      return this.animation.playbackRate;
    }
    set speed(newSpeed) {
      if (newSpeed < 0)
        this.finishedTime = null;
      this.animation.playbackRate = newSpeed;
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(newStartTime) {
      this.animation.startTime = newStartTime;
    }
attachTimeline({ timeline, observe }) {
      if (this.allowFlatten) {
        this.animation.effect?.updateTiming({ easing: "linear" });
      }
      this.animation.onfinish = null;
      if (timeline && supportsScrollTimeline()) {
        this.animation.timeline = timeline;
        return noop;
      } else {
        return observe(this);
      }
    }
  }
  const unsupportedEasingFunctions = {
    anticipate,
    backInOut,
    circInOut
  };
  function isUnsupportedEase(key) {
    return key in unsupportedEasingFunctions;
  }
  function replaceStringEasing(transition) {
    if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
      transition.ease = unsupportedEasingFunctions[transition.ease];
    }
  }
  const sampleDelta = 10;
  class NativeAnimationExtended extends NativeAnimation {
    constructor(options) {
      replaceStringEasing(options);
      replaceTransitionType(options);
      super(options);
      if (options.startTime) {
        this.startTime = options.startTime;
      }
      this.options = options;
    }
updateMotionValue(value) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      if (!motionValue2)
        return;
      if (value !== void 0) {
        motionValue2.set(value);
        return;
      }
      const sampleAnimation = new JSAnimation({
        ...options,
        autoplay: false
      });
      const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
      sampleAnimation.stop();
    }
  }
  const isAnimatable = (value, name) => {
    if (name === "zIndex")
      return false;
    if (typeof value === "number" || Array.isArray(value))
      return true;
    if (typeof value === "string" &&
(complex.test(value) || value === "0") &&
!value.startsWith("url(")) {
      return true;
    }
    return false;
  };
  function hasKeyframesChanged(keyframes2) {
    const current = keyframes2[0];
    if (keyframes2.length === 1)
      return true;
    for (let i = 0; i < keyframes2.length; i++) {
      if (keyframes2[i] !== current)
        return true;
    }
  }
  function canAnimate(keyframes2, name, type, velocity) {
    const originKeyframe = keyframes2[0];
    if (originKeyframe === null)
      return false;
    if (name === "display" || name === "visibility")
      return true;
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(originKeyframe, name);
    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
    if (!isOriginAnimatable || !isTargetAnimatable) {
      return false;
    }
    return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
  }
  function makeAnimationInstant(options) {
    options.duration = 0;
    options.type = "keyframes";
  }
  const acceleratedValues = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform"

]);
  const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
  function supportsBrowserAnimation(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    const subject = motionValue2?.owner?.current;
    if (!(subject instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) &&
!onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
  const MAX_RESOLVE_DELAY = 40;
  class AsyncMotionValueAnimation extends WithPromise {
    constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
      super();
      this.stop = () => {
        if (this._animation) {
          this._animation.stop();
          this.stopTimeline?.();
        }
        this.keyframeResolver?.cancel();
      };
      this.createdAt = time.now();
      const optionsWithDefaults = {
        autoplay,
        delay: delay2,
        type,
        repeat,
        repeatDelay,
        repeatType,
        name,
        motionValue: motionValue2,
        element,
        ...options
      };
      const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
      this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
      this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
      this.keyframeResolver = void 0;
      const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
      this.resolvedAt = time.now();
      if (!canAnimate(keyframes2, name, type, velocity)) {
        if (MotionGlobalConfig.instantAnimations || !delay2) {
          onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
        }
        keyframes2[0] = keyframes2[keyframes2.length - 1];
        makeAnimationInstant(options);
        options.repeat = 0;
      }
      const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
      const resolvedOptions = {
        startTime,
        finalKeyframe,
        ...options,
        keyframes: keyframes2
      };
      const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
        ...resolvedOptions,
        element: resolvedOptions.motionValue.owner.current
      }) : new JSAnimation(resolvedOptions);
      animation.finished.then(() => this.notifyFinished()).catch(noop);
      if (this.pendingTimeline) {
        this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
        this.pendingTimeline = void 0;
      }
      this._animation = animation;
    }
    get finished() {
      if (!this._animation) {
        return this._finished;
      } else {
        return this.animation.finished;
      }
    }
    then(onResolve, _onReject) {
      return this.finished.finally(onResolve).then(() => {
      });
    }
    get animation() {
      if (!this._animation) {
        this.keyframeResolver?.resume();
        flushKeyframeResolvers();
      }
      return this._animation;
    }
    get duration() {
      return this.animation.duration;
    }
    get iterationDuration() {
      return this.animation.iterationDuration;
    }
    get time() {
      return this.animation.time;
    }
    set time(newTime) {
      this.animation.time = newTime;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(newSpeed) {
      this.animation.speed = newSpeed;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(timeline) {
      if (this._animation) {
        this.stopTimeline = this.animation.attachTimeline(timeline);
      } else {
        this.pendingTimeline = timeline;
      }
      return () => this.stop();
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      if (this._animation) {
        this.animation.cancel();
      }
      this.keyframeResolver?.cancel();
    }
  }
  const splitCSSVariableRegex = (
/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
  );
  function parseCSSVariable(current) {
    const match2 = splitCSSVariableRegex.exec(current);
    if (!match2)
      return [,];
    const [, token1, token2, fallback2] = match2;
    return [`--${token1 ?? token2}`, fallback2];
  }
  function getVariableValue(current, element, depth = 1) {
    const [token2, fallback2] = parseCSSVariable(current);
    if (!token2)
      return;
    const resolved = window.getComputedStyle(element).getPropertyValue(token2);
    if (resolved) {
      const trimmed = resolved.trim();
      return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
    }
    return isCSSVariableToken(fallback2) ? getVariableValue(fallback2, element, depth + 1) : fallback2;
  }
  function getValueTransition(transition, key) {
    return transition?.[key] ?? transition?.["default"] ?? transition;
  }
  const positionalKeys = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...transformPropOrder
  ]);
  const auto = {
    test: (v) => v === "auto",
    parse: (v) => v
  };
  const testValueType = (v) => (type) => type.test(v);
  const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
  const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
  function isNone(value) {
    if (typeof value === "number") {
      return value === 0;
    } else if (value !== null) {
      return value === "none" || value === "0" || isZeroValueString(value);
    } else {
      return true;
    }
  }
  const maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
  function applyDefaultFilter(v) {
    const [name, value] = v.slice(0, -1).split("(");
    if (name === "drop-shadow")
      return v;
    const [number2] = value.match(floatRegex) || [];
    if (!number2)
      return v;
    const unit = value.replace(number2, "");
    let defaultValue = maxDefaults.has(name) ? 1 : 0;
    if (number2 !== value)
      defaultValue *= 100;
    return name + "(" + defaultValue + unit + ")";
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
  const filter = {
    ...complex,
    getAnimatableNone: (v) => {
      const functions = v.match(functionRegex);
      return functions ? functions.map(applyDefaultFilter).join(" ") : v;
    }
  };
  const int = {
    ...number,
    transform: Math.round
  };
  const transformValueTypes = {
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px
  };
  const numberValueTypes = {
borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
backgroundPositionX: px,
    backgroundPositionY: px,
    ...transformValueTypes,
    zIndex: int,
fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
  };
  const defaultValueTypes = {
    ...numberValueTypes,
color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
  };
  const getDefaultValueType = (key) => defaultValueTypes[key];
  function getAnimatableNone(key, value) {
    let defaultValueType = getDefaultValueType(key);
    if (defaultValueType !== filter)
      defaultValueType = complex;
    return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
  }
  const invalidTemplates = new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
    let i = 0;
    let animatableTemplate = void 0;
    while (i < unresolvedKeyframes.length && !animatableTemplate) {
      const keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
        animatableTemplate = unresolvedKeyframes[i];
      }
      i++;
    }
    if (animatableTemplate && name) {
      for (const noneIndex of noneKeyframeIndexes) {
        unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
      }
    }
  }
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
      super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
    }
    readKeyframes() {
      const { unresolvedKeyframes, element, name } = this;
      if (!element || !element.current)
        return;
      super.readKeyframes();
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        let keyframe = unresolvedKeyframes[i];
        if (typeof keyframe === "string") {
          keyframe = keyframe.trim();
          if (isCSSVariableToken(keyframe)) {
            const resolved = getVariableValue(keyframe, element.current);
            if (resolved !== void 0) {
              unresolvedKeyframes[i] = resolved;
            }
            if (i === unresolvedKeyframes.length - 1) {
              this.finalKeyframe = keyframe;
            }
          }
        }
      }
      this.resolveNoneKeyframes();
      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
        return;
      }
      const [origin, target] = unresolvedKeyframes;
      const originType = findDimensionValueType(origin);
      const targetType = findDimensionValueType(target);
      if (originType === targetType)
        return;
      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
        for (let i = 0; i < unresolvedKeyframes.length; i++) {
          const value = unresolvedKeyframes[i];
          if (typeof value === "string") {
            unresolvedKeyframes[i] = parseFloat(value);
          }
        }
      } else if (positionalValues[name]) {
        this.needsMeasurement = true;
      }
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes, name } = this;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
          noneKeyframeIndexes.push(i);
        }
      }
      if (noneKeyframeIndexes.length) {
        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
      }
    }
    measureInitialState() {
      const { element, unresolvedKeyframes, name } = this;
      if (!element || !element.current)
        return;
      if (name === "height") {
        this.suspendedScrollY = window.pageYOffset;
      }
      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      unresolvedKeyframes[0] = this.measuredOrigin;
      const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (measureKeyframe !== void 0) {
        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
      }
    }
    measureEndState() {
      const { element, name, unresolvedKeyframes } = this;
      if (!element || !element.current)
        return;
      const value = element.getValue(name);
      value && value.jump(this.measuredOrigin, false);
      const finalKeyframeIndex = unresolvedKeyframes.length - 1;
      const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
      if (finalKeyframe !== null && this.finalKeyframe === void 0) {
        this.finalKeyframe = finalKeyframe;
      }
      if (this.removedTransforms?.length) {
        this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
          element.getValue(unsetTransformName).set(unsetTransformValue);
        });
      }
      this.resolveNoneKeyframes();
    }
  }
  function resolveElements(elementOrSelector, scope, selectorCache) {
    if (elementOrSelector instanceof EventTarget) {
      return [elementOrSelector];
    } else if (typeof elementOrSelector === "string") {
      let root2 = document;
      const elements = root2.querySelectorAll(elementOrSelector);
      return elements ? Array.from(elements) : [];
    }
    return Array.from(elementOrSelector);
  }
  const getValueAsType = (value, type) => {
    return type && typeof value === "number" ? type.transform(value) : value;
  };
  function isHTMLElement(element) {
    return isObject(element) && "offsetHeight" in element;
  }
  const MAX_VELOCITY_DELTA = 30;
  const isFloat = (value) => {
    return !isNaN(parseFloat(value));
  };
  class MotionValue {
constructor(init, options = {}) {
      this.canTrackVelocity = null;
      this.events = {};
      this.updateAndNotify = (v) => {
        const currentTime = time.now();
        if (this.updatedAt !== currentTime) {
          this.setPrevFrameValue();
        }
        this.prev = this.current;
        this.setCurrent(v);
        if (this.current !== this.prev) {
          this.events.change?.notify(this.current);
          if (this.dependents) {
            for (const dependent of this.dependents) {
              dependent.dirty();
            }
          }
        }
      };
      this.hasAnimated = false;
      this.setCurrent(init);
      this.owner = options.owner;
    }
    setCurrent(current) {
      this.current = current;
      this.updatedAt = time.now();
      if (this.canTrackVelocity === null && current !== void 0) {
        this.canTrackVelocity = isFloat(this.current);
      }
    }
    setPrevFrameValue(prevFrameValue = this.current) {
      this.prevFrameValue = prevFrameValue;
      this.prevUpdatedAt = this.updatedAt;
    }
onChange(subscription) {
      return this.on("change", subscription);
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      const unsubscribe = this.events[eventName].add(callback);
      if (eventName === "change") {
        return () => {
          unsubscribe();
          frame.read(() => {
            if (!this.events.change.getSize()) {
              this.stop();
            }
          });
        };
      }
      return unsubscribe;
    }
    clearListeners() {
      for (const eventManagers in this.events) {
        this.events[eventManagers].clear();
      }
    }
attach(passiveEffect, stopPassiveEffect) {
      this.passiveEffect = passiveEffect;
      this.stopPassiveEffect = stopPassiveEffect;
    }
set(v) {
      if (!this.passiveEffect) {
        this.updateAndNotify(v);
      } else {
        this.passiveEffect(v, this.updateAndNotify);
      }
    }
    setWithVelocity(prev2, current, delta) {
      this.set(current);
      this.prev = void 0;
      this.prevFrameValue = prev2;
      this.prevUpdatedAt = this.updatedAt - delta;
    }
jump(v, endAnimation = true) {
      this.updateAndNotify(v);
      this.prev = v;
      this.prevUpdatedAt = this.prevFrameValue = void 0;
      endAnimation && this.stop();
      if (this.stopPassiveEffect)
        this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(dependent) {
      if (!this.dependents) {
        this.dependents = new Set();
      }
      this.dependents.add(dependent);
    }
    removeDependent(dependent) {
      if (this.dependents) {
        this.dependents.delete(dependent);
      }
    }
get() {
      return this.current;
    }
getPrevious() {
      return this.prev;
    }
getVelocity() {
      const currentTime = time.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
        return 0;
      }
      const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
      return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
    }
start(startAnimation) {
      this.stop();
      return new Promise((resolve) => {
        this.hasAnimated = true;
        this.animation = startAnimation(resolve);
        if (this.events.animationStart) {
          this.events.animationStart.notify();
        }
      }).then(() => {
        if (this.events.animationComplete) {
          this.events.animationComplete.notify();
        }
        this.clearAnimation();
      });
    }
stop() {
      if (this.animation) {
        this.animation.stop();
        if (this.events.animationCancel) {
          this.events.animationCancel.notify();
        }
      }
      this.clearAnimation();
    }
isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
destroy() {
      this.dependents?.clear();
      this.events.destroy?.notify();
      this.clearListeners();
      this.stop();
      if (this.stopPassiveEffect) {
        this.stopPassiveEffect();
      }
    }
  }
  function motionValue(init, options) {
    return new MotionValue(init, options);
  }
  const { schedule: microtask } = createRenderBatcher(queueMicrotask, false);
  const isDragging = {
    x: false,
    y: false
  };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function setDragLock(axis) {
    if (axis === "x" || axis === "y") {
      if (isDragging[axis]) {
        return null;
      } else {
        isDragging[axis] = true;
        return () => {
          isDragging[axis] = false;
        };
      }
    } else {
      if (isDragging.x || isDragging.y) {
        return null;
      } else {
        isDragging.x = isDragging.y = true;
        return () => {
          isDragging.x = isDragging.y = false;
        };
      }
    }
  }
  function setupGesture(elementOrSelector, options) {
    const elements = resolveElements(elementOrSelector);
    const gestureAbortController = new AbortController();
    const eventOptions = {
      passive: true,
      ...options,
      signal: gestureAbortController.signal
    };
    const cancel = () => gestureAbortController.abort();
    return [elements, eventOptions, cancel];
  }
  function isValidHover(event) {
    return !(event.pointerType === "touch" || isDragActive());
  }
  function hover(elementOrSelector, onHoverStart, options = {}) {
    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
    const onPointerEnter = (enterEvent) => {
      if (!isValidHover(enterEvent))
        return;
      const { target } = enterEvent;
      const onHoverEnd = onHoverStart(target, enterEvent);
      if (typeof onHoverEnd !== "function" || !target)
        return;
      const onPointerLeave = (leaveEvent) => {
        if (!isValidHover(leaveEvent))
          return;
        onHoverEnd(leaveEvent);
        target.removeEventListener("pointerleave", onPointerLeave);
      };
      target.addEventListener("pointerleave", onPointerLeave, eventOptions);
    };
    elements.forEach((element) => {
      element.addEventListener("pointerenter", onPointerEnter, eventOptions);
    });
    return cancel;
  }
  const isNodeOrChild = (parent, child) => {
    if (!child) {
      return false;
    } else if (parent === child) {
      return true;
    } else {
      return isNodeOrChild(parent, child.parentElement);
    }
  };
  const isPrimaryPointer = (event) => {
    if (event.pointerType === "mouse") {
      return typeof event.button !== "number" || event.button <= 0;
    } else {
      return event.isPrimary !== false;
    }
  };
  const focusableElements = new Set([
    "BUTTON",
    "INPUT",
    "SELECT",
    "TEXTAREA",
    "A"
  ]);
  function isElementKeyboardAccessible(element) {
    return focusableElements.has(element.tagName) || element.tabIndex !== -1;
  }
  const isPressing = new WeakSet();
  function filterEvents(callback) {
    return (event) => {
      if (event.key !== "Enter")
        return;
      callback(event);
    };
  }
  function firePointerEvent(target, type) {
    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
  }
  const enableKeyboardPress = (focusEvent, eventOptions) => {
    const element = focusEvent.currentTarget;
    if (!element)
      return;
    const handleKeydown = filterEvents(() => {
      if (isPressing.has(element))
        return;
      firePointerEvent(element, "down");
      const handleKeyup = filterEvents(() => {
        firePointerEvent(element, "up");
      });
      const handleBlur = () => firePointerEvent(element, "cancel");
      element.addEventListener("keyup", handleKeyup, eventOptions);
      element.addEventListener("blur", handleBlur, eventOptions);
    });
    element.addEventListener("keydown", handleKeydown, eventOptions);
    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
  };
  function isValidPressEvent(event) {
    return isPrimaryPointer(event) && !isDragActive();
  }
  function press(targetOrSelector, onPressStart, options = {}) {
    const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
    const startPress = (startEvent) => {
      const target = startEvent.currentTarget;
      if (!isValidPressEvent(startEvent))
        return;
      isPressing.add(target);
      const onPressEnd = onPressStart(target, startEvent);
      const onPointerEnd = (endEvent, success) => {
        window.removeEventListener("pointerup", onPointerUp);
        window.removeEventListener("pointercancel", onPointerCancel);
        if (isPressing.has(target)) {
          isPressing.delete(target);
        }
        if (!isValidPressEvent(endEvent)) {
          return;
        }
        if (typeof onPressEnd === "function") {
          onPressEnd(endEvent, { success });
        }
      };
      const onPointerUp = (upEvent) => {
        onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
      };
      const onPointerCancel = (cancelEvent) => {
        onPointerEnd(cancelEvent, false);
      };
      window.addEventListener("pointerup", onPointerUp, eventOptions);
      window.addEventListener("pointercancel", onPointerCancel, eventOptions);
    };
    targets.forEach((target) => {
      const pointerDownTarget = options.useGlobalTarget ? window : target;
      pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
      if (isHTMLElement(target)) {
        target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
        if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
          target.tabIndex = 0;
        }
      }
    });
    return cancelEvents;
  }
  function isSVGElement(element) {
    return isObject(element) && "ownerSVGElement" in element;
  }
  function isSVGSVGElement(element) {
    return isSVGElement(element) && element.tagName === "svg";
  }
  const isMotionValue = (value) => Boolean(value && value.getVelocity);
  const valueTypes = [...dimensionValueTypes, color, complex];
  const findValueType = (v) => valueTypes.find(testValueType(v));
  const MotionConfigContext = reactExports.createContext({
    transformPagePoint: (p) => p,
    isStatic: false,
    reducedMotion: "never"
  });
  function setRef(ref, value) {
    if (typeof ref === "function") {
      return ref(value);
    } else if (ref !== null && ref !== void 0) {
      ref.current = value;
    }
  }
  function composeRefs(...refs) {
    return (node2) => {
      let hasCleanup = false;
      const cleanups = refs.map((ref) => {
        const cleanup = setRef(ref, node2);
        if (!hasCleanup && typeof cleanup === "function") {
          hasCleanup = true;
        }
        return cleanup;
      });
      if (hasCleanup) {
        return () => {
          for (let i = 0; i < cleanups.length; i++) {
            const cleanup = cleanups[i];
            if (typeof cleanup === "function") {
              cleanup();
            } else {
              setRef(refs[i], null);
            }
          }
        };
      }
    };
  }
  function useComposedRefs(...refs) {
    return reactExports.useCallback(composeRefs(...refs), refs);
  }
  class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(prevProps) {
      const element = this.props.childRef.current;
      if (element && prevProps.isPresent && !this.props.isPresent) {
        const parent = element.offsetParent;
        const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
        const size2 = this.props.sizeRef.current;
        size2.height = element.offsetHeight || 0;
        size2.width = element.offsetWidth || 0;
        size2.top = element.offsetTop;
        size2.left = element.offsetLeft;
        size2.right = parentWidth - size2.width - size2.left;
      }
      return null;
    }
componentDidUpdate() {
    }
    render() {
      return this.props.children;
    }
  }
  function PopChild({ children, isPresent, anchorX, root: root2 }) {
    const id2 = reactExports.useId();
    const ref = reactExports.useRef(null);
    const size2 = reactExports.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      right: 0
    });
    const { nonce } = reactExports.useContext(MotionConfigContext);
    const composedRef = useComposedRefs(ref, children?.ref);
    reactExports.useInsertionEffect(() => {
      const { width, height, top, left, right } = size2.current;
      if (isPresent || !ref.current || !width || !height)
        return;
      const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
      ref.current.dataset.motionPopId = id2;
      const style = document.createElement("style");
      if (nonce)
        style.nonce = nonce;
      const parent = root2 ?? document.head;
      parent.appendChild(style);
      if (style.sheet) {
        style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `);
      }
      return () => {
        if (parent.contains(style)) {
          parent.removeChild(style);
        }
      };
    }, [isPresent]);
    return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: reactExports.cloneElement(children, { ref: composedRef }) });
  }
  const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root: root2 }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id2 = reactExports.useId();
    let isReusedContext = true;
    let context = reactExports.useMemo(() => {
      isReusedContext = false;
      return {
        id: id2,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
          presenceChildren.set(childId, true);
          for (const isComplete of presenceChildren.values()) {
            if (!isComplete)
              return;
          }
          onExitComplete && onExitComplete();
        },
        register: (childId) => {
          presenceChildren.set(childId, false);
          return () => presenceChildren.delete(childId);
        }
      };
    }, [isPresent, presenceChildren, onExitComplete]);
    if (presenceAffectsLayout && isReusedContext) {
      context = { ...context };
    }
    reactExports.useMemo(() => {
      presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    reactExports.useEffect(() => {
      !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
      children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, root: root2, children });
    }
    return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
  };
  function newChildrenMap() {
    return new Map();
  }
  function usePresence(subscribe = true) {
    const context = reactExports.useContext(PresenceContext);
    if (context === null)
      return [true, null];
    const { isPresent, onExitComplete, register } = context;
    const id2 = reactExports.useId();
    reactExports.useEffect(() => {
      if (subscribe) {
        return register(id2);
      }
    }, [subscribe]);
    const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
  }
  const getChildKey = (child) => child.key || "";
  function onlyElements(children) {
    const filtered = [];
    reactExports.Children.forEach(children, (child) => {
      if (reactExports.isValidElement(child))
        filtered.push(child);
    });
    return filtered;
  }
  const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", root: root2 }) => {
    const [isParentPresent, safeToRemove] = usePresence(propagate);
    const presentChildren = reactExports.useMemo(() => onlyElements(children), [children]);
    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
    const isInitialRender = reactExports.useRef(true);
    const pendingPresentChildren = reactExports.useRef(presentChildren);
    const exitComplete = useConstant(() => new Map());
    const [diffedChildren, setDiffedChildren] = reactExports.useState(presentChildren);
    const [renderedChildren, setRenderedChildren] = reactExports.useState(presentChildren);
    useIsomorphicLayoutEffect(() => {
      isInitialRender.current = false;
      pendingPresentChildren.current = presentChildren;
      for (let i = 0; i < renderedChildren.length; i++) {
        const key = getChildKey(renderedChildren[i]);
        if (!presentKeys.includes(key)) {
          if (exitComplete.get(key) !== true) {
            exitComplete.set(key, false);
          }
        } else {
          exitComplete.delete(key);
        }
      }
    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
    const exitingChildren = [];
    if (presentChildren !== diffedChildren) {
      let nextChildren = [...presentChildren];
      for (let i = 0; i < renderedChildren.length; i++) {
        const child = renderedChildren[i];
        const key = getChildKey(child);
        if (!presentKeys.includes(key)) {
          nextChildren.splice(i, 0, child);
          exitingChildren.push(child);
        }
      }
      if (mode === "wait" && exitingChildren.length) {
        nextChildren = exitingChildren;
      }
      setRenderedChildren(onlyElements(nextChildren));
      setDiffedChildren(presentChildren);
      return null;
    }
    const { forceRender } = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach((isExitComplete) => {
          if (!isExitComplete)
            isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender?.();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && safeToRemove?.();
          onExitComplete && onExitComplete();
        }
      };
      return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root: root2, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key);
    }) });
  };
  const LazyContext = reactExports.createContext({ strict: false });
  const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag"
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
  };
  const featureDefinitions = {};
  for (const key in featureProps) {
    featureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }
  function loadFeatures(features) {
    for (const key in features) {
      featureDefinitions[key] = {
        ...featureDefinitions[key],
        ...features[key]
      };
    }
  }
  const validMotionProps = new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport"
  ]);
  function isValidMotionProp(key) {
    return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
  }
  let shouldForward = (key) => !isValidMotionProp(key);
  function loadExternalIsValidProp(isValidProp) {
    if (typeof isValidProp !== "function")
      return;
    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  }
  try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
  } catch {
  }
  function filterProps(props, isDom2, forwardMotionProps) {
    const filteredProps = {};
    for (const key in props) {
      if (key === "values" && typeof props.values === "object")
        continue;
      if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom2 && !isValidMotionProp(key) ||
props["draggable"] && key.startsWith("onDrag")) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }
  const MotionContext = reactExports.createContext({});
  function isAnimationControls(v) {
    return v !== null && typeof v === "object" && typeof v.start === "function";
  }
  function isVariantLabel(v) {
    return typeof v === "string" || Array.isArray(v);
  }
  const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit"
  ];
  const variantProps = ["initial", ...variantPriorityOrder];
  function isControllingVariants(props) {
    return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
  }
  function isVariantNode(props) {
    return Boolean(isControllingVariants(props) || props.variants);
  }
  function getCurrentTreeVariants(props, context) {
    if (isControllingVariants(props)) {
      const { initial, animate } = props;
      return {
        initial: initial === false || isVariantLabel(initial) ? initial : void 0,
        animate: isVariantLabel(animate) ? animate : void 0
      };
    }
    return props.inherit !== false ? context : {};
  }
  function useCreateMotionContext(props) {
    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
    return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
  }
  function variantLabelsAsDependency(prop) {
    return Array.isArray(prop) ? prop.join(" ") : prop;
  }
  const scaleCorrectors = {};
  function addScaleCorrector(correctors) {
    for (const key in correctors) {
      scaleCorrectors[key] = correctors[key];
      if (isCSSVariableName(key)) {
        scaleCorrectors[key].isCSSVariable = true;
      }
    }
  }
  function isForcedMotionValue(key, { layout: layout2, layoutId }) {
    return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
  }
  const translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
  };
  const numTransforms = transformPropOrder.length;
  function buildTransform(latestValues, transform, transformTemplate) {
    let transformString = "";
    let transformIsDefault = true;
    for (let i = 0; i < numTransforms; i++) {
      const key = transformPropOrder[i];
      const value = latestValues[key];
      if (value === void 0)
        continue;
      let valueIsDefault = true;
      if (typeof value === "number") {
        valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
      } else {
        valueIsDefault = parseFloat(value) === 0;
      }
      if (!valueIsDefault || transformTemplate) {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (!valueIsDefault) {
          transformIsDefault = false;
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${valueAsType}) `;
        }
        if (transformTemplate) {
          transform[key] = valueAsType;
        }
      }
    }
    transformString = transformString.trim();
    if (transformTemplate) {
      transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
    } else if (transformIsDefault) {
      transformString = "none";
    }
    return transformString;
  }
  function buildHTMLStyles(state2, latestValues, transformTemplate) {
    const { style, vars, transformOrigin } = state2;
    let hasTransform2 = false;
    let hasTransformOrigin = false;
    for (const key in latestValues) {
      const value = latestValues[key];
      if (transformProps.has(key)) {
        hasTransform2 = true;
        continue;
      } else if (isCSSVariableName(key)) {
        vars[key] = value;
        continue;
      } else {
        const valueAsType = getValueAsType(value, numberValueTypes[key]);
        if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
    }
    if (!latestValues.transform) {
      if (hasTransform2 || transformTemplate) {
        style.transform = buildTransform(latestValues, state2.transform, transformTemplate);
      } else if (style.transform) {
        style.transform = "none";
      }
    }
    if (hasTransformOrigin) {
      const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
      style.transformOrigin = `${originX} ${originY} ${originZ}`;
    }
  }
  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
  });
  function copyRawValuesOnly(target, source, props) {
    for (const key in source) {
      if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
        target[key] = source[key];
      }
    }
  }
  function useInitialMotionValues({ transformTemplate }, visualState) {
    return reactExports.useMemo(() => {
      const state2 = createHtmlRenderState();
      buildHTMLStyles(state2, visualState, transformTemplate);
      return Object.assign({}, state2.vars, state2.style);
    }, [visualState]);
  }
  function useStyle(props, visualState) {
    const styleProp = props.style || {};
    const style = {};
    copyRawValuesOnly(style, styleProp, props);
    Object.assign(style, useInitialMotionValues(props, visualState));
    return style;
  }
  function useHTMLProps(props, visualState) {
    const htmlProps2 = {};
    const style = useStyle(props, visualState);
    if (props.drag && props.dragListener !== false) {
      htmlProps2.draggable = false;
      style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
      style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
    }
    if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
      htmlProps2.tabIndex = 0;
    }
    htmlProps2.style = style;
    return htmlProps2;
  }
  const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
  };
  const camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
  };
  function buildSVGPath(attrs, length2, spacing2 = 1, offset2 = 0, useDashCase = true) {
    attrs.pathLength = 1;
    const keys = useDashCase ? dashKeys : camelKeys;
    attrs[keys.offset] = px.transform(-offset2);
    const pathLength = px.transform(length2);
    const pathSpacing = px.transform(spacing2);
    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
  }
  function buildSVGAttrs(state2, {
    attrX,
    attrY,
    attrScale,
    pathLength,
    pathSpacing = 1,
    pathOffset = 0,
...latest
  }, isSVGTag2, transformTemplate, styleProp) {
    buildHTMLStyles(state2, latest, transformTemplate);
    if (isSVGTag2) {
      if (state2.style.viewBox) {
        state2.attrs.viewBox = state2.style.viewBox;
      }
      return;
    }
    state2.attrs = state2.style;
    state2.style = {};
    const { attrs, style } = state2;
    if (attrs.transform) {
      style.transform = attrs.transform;
      delete attrs.transform;
    }
    if (style.transform || attrs.transformOrigin) {
      style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
      delete attrs.transformOrigin;
    }
    if (style.transform) {
      style.transformBox = styleProp?.transformBox ?? "fill-box";
      delete attrs.transformBox;
    }
    if (attrX !== void 0)
      attrs.x = attrX;
    if (attrY !== void 0)
      attrs.y = attrY;
    if (attrScale !== void 0)
      attrs.scale = attrScale;
    if (pathLength !== void 0) {
      buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
    }
  }
  const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
  });
  const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
  function useSVGProps(props, visualState, _isStatic, Component) {
    const visualProps = reactExports.useMemo(() => {
      const state2 = createSvgRenderState();
      buildSVGAttrs(state2, visualState, isSVGTag(Component), props.transformTemplate, props.style);
      return {
        ...state2.attrs,
        style: { ...state2.style }
      };
    }, [visualState]);
    if (props.style) {
      const rawStyles = {};
      copyRawValuesOnly(rawStyles, props.style, props);
      visualProps.style = { ...rawStyles, ...visualProps.style };
    }
    return visualProps;
  }
  const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view"
  ];
  function isSVGComponent(Component) {
    if (
typeof Component !== "string" ||
Component.includes("-")
    ) {
      return false;
    } else if (
lowercaseSVGElements.indexOf(Component) > -1 ||
/[A-Z]/u.test(Component)
    ) {
      return true;
    }
    return false;
  }
  function useRender(Component, props, ref, { latestValues }, isStatic, forwardMotionProps = false) {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  }
  function getValueState(visualElement) {
    const state2 = [{}, {}];
    visualElement?.values.forEach((value, key) => {
      state2[0][key] = value.get();
      state2[1][key] = value.getVelocity();
    });
    return state2;
  }
  function resolveVariantFromProps(props, definition, custom, visualElement) {
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    if (typeof definition === "string") {
      definition = props.variants && props.variants[definition];
    }
    if (typeof definition === "function") {
      const [current, velocity] = getValueState(visualElement);
      definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
    }
    return definition;
  }
  function resolveMotionValue(value) {
    return isMotionValue(value) ? value.get() : value;
  }
  function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
    const state2 = {
      latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
      renderState: createRenderState()
    };
    return state2;
  }
  function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
    const values = {};
    const motionValues = scrapeMotionValues(props, {});
    for (const key in motionValues) {
      values[key] = resolveMotionValue(motionValues[key]);
    }
    let { initial, animate } = props;
    const isControllingVariants$1 = isControllingVariants(props);
    const isVariantNode$1 = isVariantNode(props);
    if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
      if (initial === void 0)
        initial = context.initial;
      if (animate === void 0)
        animate = context.animate;
    }
    let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
    const variantToSet = isInitialAnimationBlocked ? animate : initial;
    if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
      const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
      for (let i = 0; i < list.length; i++) {
        const resolved = resolveVariantFromProps(props, list[i]);
        if (resolved) {
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd) {
            values[key] = transitionEnd[key];
          }
        }
      }
    }
    return values;
  }
  const makeUseVisualState = (config) => (props, isStatic) => {
    const context = reactExports.useContext(MotionContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const make = () => makeState(config, props, context, presenceContext);
    return isStatic ? make() : useConstant(make);
  };
  function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
    const { style } = props;
    const newValues = {};
    for (const key in style) {
      if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
        newValues[key] = style[key];
      }
    }
    return newValues;
  }
  const useHTMLVisualState = makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  });
  function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    for (const key in props) {
      if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
        const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
        newValues[targetKey] = props[key];
      }
    }
    return newValues;
  }
  const useSVGVisualState = makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState
  });
  const motionComponentSymbol = Symbol.for("motionComponentSymbol");
  function isRefObject(ref) {
    return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
  }
  function useMotionRef(visualState, visualElement, externalRef) {
    return reactExports.useCallback(
      (instance) => {
        if (instance) {
          visualState.onMount && visualState.onMount(instance);
        }
        if (visualElement) {
          if (instance) {
            visualElement.mount(instance);
          } else {
            visualElement.unmount();
          }
        }
        if (externalRef) {
          if (typeof externalRef === "function") {
            externalRef(instance);
          } else if (isRefObject(externalRef)) {
            externalRef.current = instance;
          }
        }
      },
[visualElement]
    );
  }
  const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
  const optimizedAppearDataId = "framerAppearId";
  const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
  const SwitchLayoutGroupContext = reactExports.createContext({});
  function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
    const { visualElement: parent } = reactExports.useContext(MotionContext);
    const lazyContext = reactExports.useContext(LazyContext);
    const presenceContext = reactExports.useContext(PresenceContext);
    const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
    const visualElementRef = reactExports.useRef(null);
    createVisualElement = createVisualElement || lazyContext.renderer;
    if (!visualElementRef.current && createVisualElement) {
      visualElementRef.current = createVisualElement(Component, {
        visualState,
        parent,
        props,
        presenceContext,
        blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
        reducedMotionConfig
      });
    }
    const visualElement = visualElementRef.current;
    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
    if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
      createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
    }
    const isMounted = reactExports.useRef(false);
    reactExports.useInsertionEffect(() => {
      if (visualElement && isMounted.current) {
        visualElement.update(props, presenceContext);
      }
    });
    const optimisedAppearId = props[optimizedAppearDataAttribute];
    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
    useIsomorphicLayoutEffect(() => {
      if (!visualElement)
        return;
      isMounted.current = true;
      window.MotionIsMounted = true;
      visualElement.updateFeatures();
      visualElement.scheduleRenderMicrotask();
      if (wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
    });
    reactExports.useEffect(() => {
      if (!visualElement)
        return;
      if (!wantsHandoff.current && visualElement.animationState) {
        visualElement.animationState.animateChanges();
      }
      if (wantsHandoff.current) {
        queueMicrotask(() => {
          window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
        });
        wantsHandoff.current = false;
      }
      visualElement.enteringChildren = void 0;
    });
    return visualElement;
  }
  function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
    const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
    visualElement.projection.setOptions({
      layoutId,
      layout: layout2,
      alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
      visualElement,
animationType: typeof layout2 === "string" ? layout2 : "both",
      initialPromotionConfig,
      crossfade: layoutCrossfade,
      layoutScroll,
      layoutRoot
    });
  }
  function getClosestProjectingNode(visualElement) {
    if (!visualElement)
      return void 0;
    return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
  }
  function createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {
    preloadedFeatures && loadFeatures(preloadedFeatures);
    const useVisualState = isSVGComponent(Component) ? useSVGVisualState : useHTMLVisualState;
    function MotionDOMComponent(props, externalRef) {
      let MeasureLayout2;
      const configAndProps = {
        ...reactExports.useContext(MotionConfigContext),
        ...props,
        layoutId: useLayoutId(props)
      };
      const { isStatic } = configAndProps;
      const context = useCreateMotionContext(props);
      const visualState = useVisualState(props, isStatic);
      if (!isStatic && isBrowser) {
        useStrictMode();
        const layoutProjection = getProjectionFunctionality(configAndProps);
        MeasureLayout2 = layoutProjection.MeasureLayout;
        context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
      }
      return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] });
    }
    MotionDOMComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
    const ForwardRefMotionComponent = reactExports.forwardRef(MotionDOMComponent);
    ForwardRefMotionComponent[motionComponentSymbol] = Component;
    return ForwardRefMotionComponent;
  }
  function useLayoutId({ layoutId }) {
    const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
    return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
  }
  function useStrictMode(configAndProps, preloadedFeatures) {
    reactExports.useContext(LazyContext).strict;
  }
  function getProjectionFunctionality(props) {
    const { drag: drag2, layout: layout2 } = featureDefinitions;
    if (!drag2 && !layout2)
      return {};
    const combined = { ...drag2, ...layout2 };
    return {
      MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
      ProjectionNode: combined.ProjectionNode
    };
  }
  function createMotionProxy(preloadedFeatures, createVisualElement) {
    if (typeof Proxy === "undefined") {
      return createMotionComponent;
    }
    const componentCache = new Map();
    const factory = (Component, options) => {
      return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);
    };
    const deprecatedFactoryFunction = (Component, options) => {
      return factory(Component, options);
    };
    return new Proxy(deprecatedFactoryFunction, {
get: (_target, key) => {
        if (key === "create")
          return factory;
        if (!componentCache.has(key)) {
          componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
        }
        return componentCache.get(key);
      }
    });
  }
  function convertBoundingBoxToBox({ top, left, right, bottom }) {
    return {
      x: { min: left, max: right },
      y: { min: top, max: bottom }
    };
  }
  function convertBoxToBoundingBox({ x: x2, y }) {
    return { top: y.min, right: x2.max, bottom: y.max, left: x2.min };
  }
  function transformBoxPoints(point, transformPoint2) {
    if (!transformPoint2)
      return point;
    const topLeft = transformPoint2({ x: point.left, y: point.top });
    const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
    return {
      top: topLeft.y,
      left: topLeft.x,
      bottom: bottomRight.y,
      right: bottomRight.x
    };
  }
  function isIdentityScale(scale2) {
    return scale2 === void 0 || scale2 === 1;
  }
  function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
    return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
  }
  function hasTransform(values) {
    return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
  }
  function has2DTranslate(values) {
    return is2DTranslate(values.x) || is2DTranslate(values.y);
  }
  function is2DTranslate(value) {
    return value && value !== "0%";
  }
  function scalePoint(point, scale2, originPoint) {
    const distanceFromOrigin = point - originPoint;
    const scaled = scale2 * distanceFromOrigin;
    return originPoint + scaled;
  }
  function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
    if (boxScale !== void 0) {
      point = scalePoint(point, boxScale, originPoint);
    }
    return scalePoint(point, scale2, originPoint) + translate;
  }
  function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
    axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function applyBoxDelta(box, { x: x2, y }) {
    applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999;
  const TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
    const treeLength = treePath.length;
    if (!treeLength)
      return;
    treeScale.x = treeScale.y = 1;
    let node2;
    let delta;
    for (let i = 0; i < treeLength; i++) {
      node2 = treePath[i];
      delta = node2.projectionDelta;
      const { visualElement } = node2.options;
      if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
        continue;
      }
      if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
        transformBox(box, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        });
      }
      if (delta) {
        treeScale.x *= delta.x.scale;
        treeScale.y *= delta.y.scale;
        applyBoxDelta(box, delta);
      }
      if (isSharedTransition && hasTransform(node2.latestValues)) {
        transformBox(box, node2.latestValues);
      }
    }
    if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
      treeScale.x = 1;
    }
    if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
      treeScale.y = 1;
    }
  }
  function translateAxis(axis, distance2) {
    axis.min = axis.min + distance2;
    axis.max = axis.max + distance2;
  }
  function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
  }
  function transformBox(box, transform) {
    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
  }
  function measureViewportBox(instance, transformPoint2) {
    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
  }
  function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
    const viewportBox = measureViewportBox(element, transformPagePoint);
    const { scroll } = rootProjectionNode2;
    if (scroll) {
      translateAxis(viewportBox.x, scroll.offset.x);
      translateAxis(viewportBox.y, scroll.offset.y);
    }
    return viewportBox;
  }
  const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  });
  const createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
  });
  const createAxis = () => ({ min: 0, max: 0 });
  const createBox = () => ({
    x: createAxis(),
    y: createAxis()
  });
  const prefersReducedMotion = { current: null };
  const hasReducedMotionListener = { current: false };
  function initPrefersReducedMotion() {
    hasReducedMotionListener.current = true;
    if (!isBrowser)
      return;
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
      const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
      setReducedMotionPreferences();
    } else {
      prefersReducedMotion.current = false;
    }
  }
  const visualElementStore = new WeakMap();
  function updateMotionValuesFromProps(element, next2, prev2) {
    for (const key in next2) {
      const nextValue = next2[key];
      const prevValue = prev2[key];
      if (isMotionValue(nextValue)) {
        element.addValue(key, nextValue);
      } else if (isMotionValue(prevValue)) {
        element.addValue(key, motionValue(nextValue, { owner: element }));
      } else if (prevValue !== nextValue) {
        if (element.hasValue(key)) {
          const existingValue = element.getValue(key);
          if (existingValue.liveStyle === true) {
            existingValue.jump(nextValue);
          } else if (!existingValue.hasAnimated) {
            existingValue.set(nextValue);
          }
        } else {
          const latestValue = element.getStaticValue(key);
          element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
        }
      }
    }
    for (const key in prev2) {
      if (next2[key] === void 0)
        element.removeValue(key);
    }
    return next2;
  }
  const propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete"
  ];
  class VisualElement {
scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
      return {};
    }
    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
      this.current = null;
      this.children = new Set();
      this.isVariantNode = false;
      this.isControllingVariants = false;
      this.shouldReduceMotion = null;
      this.values = new Map();
      this.KeyframeResolver = KeyframeResolver;
      this.features = {};
      this.valueSubscriptions = new Map();
      this.prevMotionValues = {};
      this.events = {};
      this.propEventSubscriptions = {};
      this.notifyUpdate = () => this.notify("Update", this.latestValues);
      this.render = () => {
        if (!this.current)
          return;
        this.triggerBuild();
        this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
      };
      this.renderScheduledAt = 0;
      this.scheduleRender = () => {
        const now2 = time.now();
        if (this.renderScheduledAt < now2) {
          this.renderScheduledAt = now2;
          frame.render(this.render, false, true);
        }
      };
      const { latestValues, renderState } = visualState;
      this.latestValues = latestValues;
      this.baseTarget = { ...latestValues };
      this.initialValues = props.initial ? { ...latestValues } : {};
      this.renderState = renderState;
      this.parent = parent;
      this.props = props;
      this.presenceContext = presenceContext;
      this.depth = parent ? parent.depth + 1 : 0;
      this.reducedMotionConfig = reducedMotionConfig;
      this.options = options;
      this.blockInitialAnimation = Boolean(blockInitialAnimation);
      this.isControllingVariants = isControllingVariants(props);
      this.isVariantNode = isVariantNode(props);
      if (this.isVariantNode) {
        this.variantChildren = new Set();
      }
      this.manuallyAnimateOnMount = Boolean(parent && parent.current);
      const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
      for (const key in initialMotionValues) {
        const value = initialMotionValues[key];
        if (latestValues[key] !== void 0 && isMotionValue(value)) {
          value.set(latestValues[key]);
        }
      }
    }
    mount(instance) {
      this.current = instance;
      visualElementStore.set(instance, this);
      if (this.projection && !this.projection.instance) {
        this.projection.mount(instance);
      }
      if (this.parent && this.isVariantNode && !this.isControllingVariants) {
        this.removeFromVariantTree = this.parent.addVariantChild(this);
      }
      this.values.forEach((value, key) => this.bindToMotionValue(key, value));
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
      this.parent?.addChild(this);
      this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount();
      cancelFrame(this.notifyUpdate);
      cancelFrame(this.render);
      this.valueSubscriptions.forEach((remove2) => remove2());
      this.valueSubscriptions.clear();
      this.removeFromVariantTree && this.removeFromVariantTree();
      this.parent?.removeChild(this);
      for (const key in this.events) {
        this.events[key].clear();
      }
      for (const key in this.features) {
        const feature = this.features[key];
        if (feature) {
          feature.unmount();
          feature.isMounted = false;
        }
      }
      this.current = null;
    }
    addChild(child) {
      this.children.add(child);
      this.enteringChildren ?? (this.enteringChildren = new Set());
      this.enteringChildren.add(child);
    }
    removeChild(child) {
      this.children.delete(child);
      this.enteringChildren && this.enteringChildren.delete(child);
    }
    bindToMotionValue(key, value) {
      if (this.valueSubscriptions.has(key)) {
        this.valueSubscriptions.get(key)();
      }
      const valueIsTransform = transformProps.has(key);
      if (valueIsTransform && this.onBindTransform) {
        this.onBindTransform();
      }
      const removeOnChange = value.on("change", (latestValue) => {
        this.latestValues[key] = latestValue;
        this.props.onUpdate && frame.preRender(this.notifyUpdate);
        if (valueIsTransform && this.projection) {
          this.projection.isTransformDirty = true;
        }
        this.scheduleRender();
      });
      let removeSyncCheck;
      if (window.MotionCheckAppearSync) {
        removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
      }
      this.valueSubscriptions.set(key, () => {
        removeOnChange();
        if (removeSyncCheck)
          removeSyncCheck();
        if (value.owner)
          value.stop();
      });
    }
    sortNodePosition(other) {
      if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
        return 0;
      }
      return this.sortInstanceNodePosition(this.current, other.current);
    }
    updateFeatures() {
      let key = "animation";
      for (key in featureDefinitions) {
        const featureDefinition = featureDefinitions[key];
        if (!featureDefinition)
          continue;
        const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
        if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
          this.features[key] = new FeatureConstructor(this);
        }
        if (this.features[key]) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
    }
    getStaticValue(key) {
      return this.latestValues[key];
    }
    setStaticValue(key, value) {
      this.latestValues[key] = value;
    }
update(props, presenceContext) {
      if (props.transformTemplate || this.props.transformTemplate) {
        this.scheduleRender();
      }
      this.prevProps = this.props;
      this.props = props;
      this.prevPresenceContext = this.presenceContext;
      this.presenceContext = presenceContext;
      for (let i = 0; i < propEventHandlers.length; i++) {
        const key = propEventHandlers[i];
        if (this.propEventSubscriptions[key]) {
          this.propEventSubscriptions[key]();
          delete this.propEventSubscriptions[key];
        }
        const listenerName = "on" + key;
        const listener = props[listenerName];
        if (listener) {
          this.propEventSubscriptions[key] = this.on(key, listener);
        }
      }
      this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
      if (this.handleChildMotionValue) {
        this.handleChildMotionValue();
      }
    }
    getProps() {
      return this.props;
    }
getVariant(name) {
      return this.props.variants ? this.props.variants[name] : void 0;
    }
getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
    }
addVariantChild(child) {
      const closestVariantNode = this.getClosestVariantNode();
      if (closestVariantNode) {
        closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
        return () => closestVariantNode.variantChildren.delete(child);
      }
    }
addValue(key, value) {
      const existingValue = this.values.get(key);
      if (value !== existingValue) {
        if (existingValue)
          this.removeValue(key);
        this.bindToMotionValue(key, value);
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
    }
removeValue(key) {
      this.values.delete(key);
      const unsubscribe = this.valueSubscriptions.get(key);
      if (unsubscribe) {
        unsubscribe();
        this.valueSubscriptions.delete(key);
      }
      delete this.latestValues[key];
      this.removeValueFromRenderState(key, this.renderState);
    }
hasValue(key) {
      return this.values.has(key);
    }
    getValue(key, defaultValue) {
      if (this.props.values && this.props.values[key]) {
        return this.props.values[key];
      }
      let value = this.values.get(key);
      if (value === void 0 && defaultValue !== void 0) {
        value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
        this.addValue(key, value);
      }
      return value;
    }
readValue(key, target) {
      let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
      if (value !== void 0 && value !== null) {
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(target)) {
          value = getAnimatableNone(key, target);
        }
        this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
      }
      return isMotionValue(value) ? value.get() : value;
    }
setBaseTarget(key, value) {
      this.baseTarget[key] = value;
    }
getBaseTarget(key) {
      const { initial } = this.props;
      let valueFromInitial;
      if (typeof initial === "string" || typeof initial === "object") {
        const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
        if (variant) {
          valueFromInitial = variant[key];
        }
      }
      if (initial && valueFromInitial !== void 0) {
        return valueFromInitial;
      }
      const target = this.getBaseTargetFromProps(this.props, key);
      if (target !== void 0 && !isMotionValue(target))
        return target;
      return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
    }
    on(eventName, callback) {
      if (!this.events[eventName]) {
        this.events[eventName] = new SubscriptionManager();
      }
      return this.events[eventName].add(callback);
    }
    notify(eventName, ...args) {
      if (this.events[eventName]) {
        this.events[eventName].notify(...args);
      }
    }
    scheduleRenderMicrotask() {
      microtask.render(this.render);
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments);
      this.KeyframeResolver = DOMKeyframesResolver;
    }
    sortInstanceNodePosition(a, b2) {
      return a.compareDocumentPosition(b2) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(props, key) {
      return props.style ? props.style[key] : void 0;
    }
    removeValueFromRenderState(key, { vars, style }) {
      delete vars[key];
      delete style[key];
    }
    handleChildMotionValue() {
      if (this.childSubscription) {
        this.childSubscription();
        delete this.childSubscription;
      }
      const { children } = this.props;
      if (isMotionValue(children)) {
        this.childSubscription = children.on("change", (latest) => {
          if (this.current) {
            this.current.textContent = `${latest}`;
          }
        });
      }
    }
  }
  function renderHTML(element, { style, vars }, styleProp, projection) {
    const elementStyle = element.style;
    let key;
    for (key in style) {
      elementStyle[key] = style[key];
    }
    projection?.applyProjectionStyles(elementStyle, styleProp);
    for (key in vars) {
      elementStyle.setProperty(key, vars[key]);
    }
  }
  function getComputedStyle$1(element) {
    return window.getComputedStyle(element);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "html";
      this.renderInstance = renderHTML;
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
      } else {
        const computedStyle = getComputedStyle$1(instance);
        const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
        return typeof value === "string" ? value.trim() : value;
      }
    }
    measureInstanceViewportBox(instance, { transformPagePoint }) {
      return measureViewportBox(instance, transformPagePoint);
    }
    build(renderState, latestValues, props) {
      buildHTMLStyles(renderState, latestValues, props.transformTemplate);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
    }
  }
  const camelCaseAttributes = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust"
  ]);
  function renderSVG(element, renderState, _styleProp, projection) {
    renderHTML(element, renderState, void 0, projection);
    for (const key in renderState.attrs) {
      element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
    }
  }
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.isSVGTag = false;
      this.measureInstanceViewportBox = createBox;
    }
    getBaseTargetFromProps(props, key) {
      return props[key];
    }
    readValueFromInstance(instance, key) {
      if (transformProps.has(key)) {
        const defaultType = getDefaultValueType(key);
        return defaultType ? defaultType.default || 0 : 0;
      }
      key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
      return instance.getAttribute(key);
    }
    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
      return scrapeMotionValuesFromProps(props, prevProps, visualElement);
    }
    build(renderState, latestValues, props) {
      buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
    }
    renderInstance(instance, renderState, styleProp, projection) {
      renderSVG(instance, renderState, styleProp, projection);
    }
    mount(instance) {
      this.isSVGTag = isSVGTag(instance.tagName);
      super.mount(instance);
    }
  }
  const createDomVisualElement = (Component, options) => {
    return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
      allowProjection: Component !== reactExports.Fragment
    });
  };
  function resolveVariant(visualElement, definition, custom) {
    const props = visualElement.getProps();
    return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
  }
  const isKeyframesTarget = (v) => {
    return Array.isArray(v);
  };
  function setMotionValue(visualElement, key, value) {
    if (visualElement.hasValue(key)) {
      visualElement.getValue(key).set(value);
    } else {
      visualElement.addValue(key, motionValue(value));
    }
  }
  function resolveFinalValueInKeyframes(v) {
    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
  }
  function setTarget(visualElement, definition) {
    const resolved = resolveVariant(visualElement, definition);
    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
    target = { ...target, ...transitionEnd };
    for (const key in target) {
      const value = resolveFinalValueInKeyframes(target[key]);
      setMotionValue(visualElement, key, value);
    }
  }
  function isWillChangeMotionValue(value) {
    return Boolean(isMotionValue(value) && value.add);
  }
  function addValueToWillChange(visualElement, key) {
    const willChange = visualElement.getValue("willChange");
    if (isWillChangeMotionValue(willChange)) {
      return willChange.add(key);
    } else if (!willChange && MotionGlobalConfig.WillChange) {
      const newWillChange = new MotionGlobalConfig.WillChange("auto");
      visualElement.addValue("willChange", newWillChange);
      newWillChange.add(key);
    }
  }
  function getOptimisedAppearId(visualElement) {
    return visualElement.props[optimizedAppearDataAttribute];
  }
  const isNotNull = (value) => value !== null;
  function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
    const resolvedKeyframes = keyframes2.filter(isNotNull);
    const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
    return resolvedKeyframes[index];
  }
  const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
  const criticallyDampedSpring = (target) => ({
    type: "spring",
    stiffness: 550,
    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  });
  const keyframesTransition = {
    type: "keyframes",
    duration: 0.8
  };
  const ease = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3
  };
  const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
    if (keyframes2.length > 2) {
      return keyframesTransition;
    } else if (transformProps.has(valueKey)) {
      return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
    }
    return ease;
  };
  function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
    return !!Object.keys(transition).length;
  }
  const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
    const valueTransition = getValueTransition(transition, name) || {};
    const delay2 = valueTransition.delay || transition.delay || 0;
    let { elapsed = 0 } = transition;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const options = {
      keyframes: Array.isArray(target) ? target : [null, target],
      ease: "easeOut",
      velocity: value.getVelocity(),
      ...valueTransition,
      delay: -elapsed,
      onUpdate: (v) => {
        value.set(v);
        valueTransition.onUpdate && valueTransition.onUpdate(v);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      },
      name,
      motionValue: value,
      element: isHandoff ? void 0 : element
    };
    if (!isTransitionDefined(valueTransition)) {
      Object.assign(options, getDefaultTransition(name, options));
    }
    options.duration && (options.duration = secondsToMilliseconds(options.duration));
    options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
    if (options.from !== void 0) {
      options.keyframes[0] = options.from;
    }
    let shouldSkip = false;
    if (options.type === false || options.duration === 0 && !options.repeatDelay) {
      makeAnimationInstant(options);
      if (options.delay === 0) {
        shouldSkip = true;
      }
    }
    if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
      shouldSkip = true;
      makeAnimationInstant(options);
      options.delay = 0;
    }
    options.allowFlatten = !valueTransition.type && !valueTransition.ease;
    if (shouldSkip && !isHandoff && value.get() !== void 0) {
      const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
      if (finalKeyframe !== void 0) {
        frame.update(() => {
          options.onUpdate(finalKeyframe);
          options.onComplete();
        });
        return;
      }
    }
    return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
  };
  function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
    needsAnimating[key] = false;
    return shouldBlock;
  }
  function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
    if (transitionOverride)
      transition = transitionOverride;
    const animations2 = [];
    const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
    for (const key in target) {
      const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
      const valueTarget = target[key];
      if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
        continue;
      }
      const valueTransition = {
        delay: delay2,
        ...getValueTransition(transition || {}, key)
      };
      const currentValue = value.get();
      if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
        continue;
      }
      let isHandoff = false;
      if (window.MotionHandoffAnimation) {
        const appearId = getOptimisedAppearId(visualElement);
        if (appearId) {
          const startTime = window.MotionHandoffAnimation(appearId, key, frame);
          if (startTime !== null) {
            valueTransition.startTime = startTime;
            isHandoff = true;
          }
        }
      }
      addValueToWillChange(visualElement, key);
      value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
      const animation = value.animation;
      if (animation) {
        animations2.push(animation);
      }
    }
    if (transitionEnd) {
      Promise.all(animations2).then(() => {
        frame.update(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      });
    }
    return animations2;
  }
  function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
    const index = Array.from(children).sort((a, b2) => a.sortNodePosition(b2)).indexOf(child);
    const numChildren = children.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    return delayIsFunction ? delayChildren(index, numChildren) : staggerDirection === 1 ? index * staggerChildren : maxStaggerDuration - index * staggerChildren;
  }
  function animateVariant(visualElement, variant, options = {}) {
    const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
    if (options.transitionOverride) {
      transition = options.transitionOverride;
    }
    const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
      const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
      return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
    } : () => Promise.resolve();
    const { when } = transition;
    if (when) {
      const [first2, last2] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
      return first2().then(() => last2());
    } else {
      return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
    }
  }
  function animateChildren(visualElement, variant, delay2 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
    const animations2 = [];
    for (const child of visualElement.variantChildren) {
      child.notify("AnimationStart", variant);
      animations2.push(animateVariant(child, variant, {
        ...options,
        delay: delay2 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
      }).then(() => child.notify("AnimationComplete", variant)));
    }
    return Promise.all(animations2);
  }
  function animateVisualElement(visualElement, definition, options = {}) {
    visualElement.notify("AnimationStart", definition);
    let animation;
    if (Array.isArray(definition)) {
      const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
      animation = Promise.all(animations2);
    } else if (typeof definition === "string") {
      animation = animateVariant(visualElement, definition, options);
    } else {
      const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
      animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
    }
    return animation.then(() => {
      visualElement.notify("AnimationComplete", definition);
    });
  }
  function shallowCompare(next2, prev2) {
    if (!Array.isArray(prev2))
      return false;
    const prevLength = prev2.length;
    if (prevLength !== next2.length)
      return false;
    for (let i = 0; i < prevLength; i++) {
      if (prev2[i] !== next2[i])
        return false;
    }
    return true;
  }
  const numVariantProps = variantProps.length;
  function getVariantContext(visualElement) {
    if (!visualElement)
      return void 0;
    if (!visualElement.isControllingVariants) {
      const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
      if (visualElement.props.initial !== void 0) {
        context2.initial = visualElement.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name = variantProps[i];
      const prop = visualElement.props[name];
      if (isVariantLabel(prop) || prop === false) {
        context[name] = prop;
      }
    }
    return context;
  }
  const reversePriorityOrder = [...variantPriorityOrder].reverse();
  const numAnimationTypes = variantPriorityOrder.length;
  function animateList(visualElement) {
    return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  }
  function createAnimationState(visualElement) {
    let animate = animateList(visualElement);
    let state2 = createState();
    let isInitialRender = true;
    const buildResolvedTypeValues = (type) => (acc, definition) => {
      const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
      if (resolved) {
        const { transition, transitionEnd, ...target } = resolved;
        acc = { ...acc, ...target, ...transitionEnd };
      }
      return acc;
    };
    function setAnimateFunction(makeAnimator) {
      animate = makeAnimator(visualElement);
    }
    function animateChanges(changedActiveType) {
      const { props } = visualElement;
      const context = getVariantContext(visualElement.parent) || {};
      const animations2 = [];
      const removedKeys = new Set();
      let encounteredKeys = {};
      let removedVariantIndex = Infinity;
      for (let i = 0; i < numAnimationTypes; i++) {
        const type = reversePriorityOrder[i];
        const typeState = state2[type];
        const prop = props[type] !== void 0 ? props[type] : context[type];
        const propIsVariant = isVariantLabel(prop);
        const activeDelta = type === changedActiveType ? typeState.isActive : null;
        if (activeDelta === false)
          removedVariantIndex = i;
        let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
        if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
          isInherited = false;
        }
        typeState.protectedKeys = { ...encounteredKeys };
        if (
!typeState.isActive && activeDelta === null ||
!prop && !typeState.prevProp ||
isAnimationControls(prop) || typeof prop === "boolean"
        ) {
          continue;
        }
        const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
        let shouldAnimateType = variantDidChange ||
type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
i > removedVariantIndex && propIsVariant;
        let handledRemovedValues = false;
        const definitionList = Array.isArray(prop) ? prop : [prop];
        let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
        if (activeDelta === false)
          resolvedValues = {};
        const { prevResolvedValues = {} } = typeState;
        const allKeys = {
          ...prevResolvedValues,
          ...resolvedValues
        };
        const markToAnimate = (key) => {
          shouldAnimateType = true;
          if (removedKeys.has(key)) {
            handledRemovedValues = true;
            removedKeys.delete(key);
          }
          typeState.needsAnimating[key] = true;
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = false;
        };
        for (const key in allKeys) {
          const next2 = resolvedValues[key];
          const prev2 = prevResolvedValues[key];
          if (encounteredKeys.hasOwnProperty(key))
            continue;
          let valueHasChanged = false;
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
            valueHasChanged = !shallowCompare(next2, prev2);
          } else {
            valueHasChanged = next2 !== prev2;
          }
          if (valueHasChanged) {
            if (next2 !== void 0 && next2 !== null) {
              markToAnimate(key);
            } else {
              removedKeys.add(key);
            }
          } else if (next2 !== void 0 && removedKeys.has(key)) {
            markToAnimate(key);
          } else {
            typeState.protectedKeys[key] = true;
          }
        }
        typeState.prevProp = prop;
        typeState.prevResolvedValues = resolvedValues;
        if (typeState.isActive) {
          encounteredKeys = { ...encounteredKeys, ...resolvedValues };
        }
        if (isInitialRender && visualElement.blockInitialAnimation) {
          shouldAnimateType = false;
        }
        const willAnimateViaParent = isInherited && variantDidChange;
        const needsAnimating = !willAnimateViaParent || handledRemovedValues;
        if (shouldAnimateType && needsAnimating) {
          animations2.push(...definitionList.map((animation) => {
            const options = { type };
            if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
              const { parent } = visualElement;
              const parentVariant = resolveVariant(parent, animation);
              if (parent.enteringChildren && parentVariant) {
                const { delayChildren } = parentVariant.transition || {};
                options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
              }
            }
            return {
              animation,
              options
            };
          }));
        }
      }
      if (removedKeys.size) {
        const fallbackAnimation = {};
        if (typeof props.initial !== "boolean") {
          const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
          if (initialTransition && initialTransition.transition) {
            fallbackAnimation.transition = initialTransition.transition;
          }
        }
        removedKeys.forEach((key) => {
          const fallbackTarget = visualElement.getBaseTarget(key);
          const motionValue2 = visualElement.getValue(key);
          if (motionValue2)
            motionValue2.liveStyle = true;
          fallbackAnimation[key] = fallbackTarget ?? null;
        });
        animations2.push({ animation: fallbackAnimation });
      }
      let shouldAnimate = Boolean(animations2.length);
      if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
        shouldAnimate = false;
      }
      isInitialRender = false;
      return shouldAnimate ? animate(animations2) : Promise.resolve();
    }
    function setActive(type, isActive) {
      if (state2[type].isActive === isActive)
        return Promise.resolve();
      visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
      state2[type].isActive = isActive;
      const animations2 = animateChanges(type);
      for (const key in state2) {
        state2[key].protectedKeys = {};
      }
      return animations2;
    }
    return {
      animateChanges,
      setActive,
      setAnimateFunction,
      getState: () => state2,
      reset: () => {
        state2 = createState();
      }
    };
  }
  function checkVariantsDidChange(prev2, next2) {
    if (typeof next2 === "string") {
      return next2 !== prev2;
    } else if (Array.isArray(next2)) {
      return !shallowCompare(next2, prev2);
    }
    return false;
  }
  function createTypeState(isActive = false) {
    return {
      isActive,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
    };
  }
  function createState() {
    return {
      animate: createTypeState(true),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState()
    };
  }
  class Feature {
    constructor(node2) {
      this.isMounted = false;
      this.node = node2;
    }
    update() {
    }
  }
  class AnimationFeature extends Feature {
constructor(node2) {
      super(node2);
      node2.animationState || (node2.animationState = createAnimationState(node2));
    }
    updateAnimationControlsSubscription() {
      const { animate } = this.node.getProps();
      if (isAnimationControls(animate)) {
        this.unmountControls = animate.subscribe(this.node);
      }
    }
mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate } = this.node.getProps();
      const { animate: prevAnimate } = this.node.prevProps || {};
      if (animate !== prevAnimate) {
        this.updateAnimationControlsSubscription();
      }
    }
    unmount() {
      this.node.animationState.reset();
      this.unmountControls?.();
    }
  }
  let id$1 = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments);
      this.id = id$1++;
    }
    update() {
      if (!this.node.presenceContext)
        return;
      const { isPresent, onExitComplete } = this.node.presenceContext;
      const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || isPresent === prevIsPresent) {
        return;
      }
      const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
      if (onExitComplete && !isPresent) {
        exitAnimation.then(() => {
          onExitComplete(this.id);
        });
      }
    }
    mount() {
      const { register, onExitComplete } = this.node.presenceContext || {};
      if (onExitComplete) {
        onExitComplete(this.id);
      }
      if (register) {
        this.unmount = register(this.id);
      }
    }
    unmount() {
    }
  }
  const animations = {
    animation: {
      Feature: AnimationFeature
    },
    exit: {
      Feature: ExitAnimationFeature
    }
  };
  function addDomEvent(target, eventName, handler, options = { passive: true }) {
    target.addEventListener(eventName, handler, options);
    return () => target.removeEventListener(eventName, handler);
  }
  function extractEventInfo(event) {
    return {
      point: {
        x: event.pageX,
        y: event.pageY
      }
    };
  }
  const addPointerInfo = (handler) => {
    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
  };
  function addPointerEvent(target, eventName, handler, options) {
    return addDomEvent(target, eventName, addPointerInfo(handler), options);
  }
  const SCALE_PRECISION = 1e-4;
  const SCALE_MIN = 1 - SCALE_PRECISION;
  const SCALE_MAX = 1 + SCALE_PRECISION;
  const TRANSLATE_PRECISION = 0.01;
  const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
  const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(axis) {
    return axis.max - axis.min;
  }
  function isNear(value, target, maxDistance) {
    return Math.abs(value - target) <= maxDistance;
  }
  function calcAxisDelta(delta, source, target, origin = 0.5) {
    delta.origin = origin;
    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
    delta.scale = calcLength(target) / calcLength(source);
    delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
    if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
      delta.scale = 1;
    }
    if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
      delta.translate = 0;
    }
  }
  function calcBoxDelta(delta, source, target, origin) {
    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
  }
  function calcRelativeAxis(target, relative, parent) {
    target.min = parent.min + relative.min;
    target.max = target.min + calcLength(relative);
  }
  function calcRelativeBox(target, relative, parent) {
    calcRelativeAxis(target.x, relative.x, parent.x);
    calcRelativeAxis(target.y, relative.y, parent.y);
  }
  function calcRelativeAxisPosition(target, layout2, parent) {
    target.min = layout2.min - parent.min;
    target.max = target.min + calcLength(layout2);
  }
  function calcRelativePosition(target, layout2, parent) {
    calcRelativeAxisPosition(target.x, layout2.x, parent.x);
    calcRelativeAxisPosition(target.y, layout2.y, parent.y);
  }
  function eachAxis(callback) {
    return [callback("x"), callback("y")];
  }
  const getContextWindow = ({ current }) => {
    return current ? current.ownerDocument.defaultView : null;
  };
  const distance = (a, b2) => Math.abs(a - b2);
  function distance2D(a, b2) {
    const xDelta = distance(a.x, b2.x);
    const yDelta = distance(a.y, b2.y);
    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
  }
  class PanSession {
    constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3 } = {}) {
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.contextWindow = window;
      this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
        const isPanStarted = this.startEvent !== null;
        const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        const { point: point2 } = info2;
        const { timestamp: timestamp2 } = frameData;
        this.history.push({ ...point2, timestamp: timestamp2 });
        const { onStart, onMove } = this.handlers;
        if (!isPanStarted) {
          onStart && onStart(this.lastMoveEvent, info2);
          this.startEvent = this.lastMoveEvent;
        }
        onMove && onMove(this.lastMoveEvent, info2);
      };
      this.handlePointerMove = (event2, info2) => {
        this.lastMoveEvent = event2;
        this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
        frame.update(this.updatePoint, true);
      };
      this.handlePointerUp = (event2, info2) => {
        this.end();
        const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
        if (this.dragSnapToOrigin)
          resumeAnimation && resumeAnimation();
        if (!(this.lastMoveEvent && this.lastMoveEventInfo))
          return;
        const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
        if (this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (!isPrimaryPointer(event))
        return;
      this.dragSnapToOrigin = dragSnapToOrigin;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      this.distanceThreshold = distanceThreshold;
      this.contextWindow = contextWindow || window;
      const info = extractEventInfo(event);
      const initialInfo = transformPoint(info, this.transformPagePoint);
      const { point } = initialInfo;
      const { timestamp } = frameData;
      this.history = [{ ...point, timestamp }];
      const { onSessionStart } = handlers;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    }
    updateHandlers(handlers) {
      this.handlers = handlers;
    }
    end() {
      this.removeListeners && this.removeListeners();
      cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(info, transformPagePoint) {
    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
  }
  function subtractPoint(a, b2) {
    return { x: a.x - b2.x, y: a.y - b2.y };
  }
  function getPanInfo({ point }, history) {
    return {
      point,
      delta: subtractPoint(point, lastDevicePoint(history)),
      offset: subtractPoint(point, startDevicePoint(history)),
      velocity: getVelocity(history, 0.1)
    };
  }
  function startDevicePoint(history) {
    return history[0];
  }
  function lastDevicePoint(history) {
    return history[history.length - 1];
  }
  function getVelocity(history, timeDelta) {
    if (history.length < 2) {
      return { x: 0, y: 0 };
    }
    let i = history.length - 1;
    let timestampedPoint = null;
    const lastPoint = lastDevicePoint(history);
    while (i >= 0) {
      timestampedPoint = history[i];
      if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
        break;
      }
      i--;
    }
    if (!timestampedPoint) {
      return { x: 0, y: 0 };
    }
    const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
    if (time2 === 0) {
      return { x: 0, y: 0 };
    }
    const currentVelocity = {
      x: (lastPoint.x - timestampedPoint.x) / time2,
      y: (lastPoint.y - timestampedPoint.y) / time2
    };
    if (currentVelocity.x === Infinity) {
      currentVelocity.x = 0;
    }
    if (currentVelocity.y === Infinity) {
      currentVelocity.y = 0;
    }
    return currentVelocity;
  }
  function applyConstraints(point, { min: min2, max: max2 }, elastic) {
    if (min2 !== void 0 && point < min2) {
      point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
    } else if (max2 !== void 0 && point > max2) {
      point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
    }
    return point;
  }
  function calcRelativeAxisConstraints(axis, min2, max2) {
    return {
      min: min2 !== void 0 ? axis.min + min2 : void 0,
      max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
    };
  }
  function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
    return {
      x: calcRelativeAxisConstraints(layoutBox.x, left, right),
      y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
    };
  }
  function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
    let min2 = constraintsAxis.min - layoutAxis.min;
    let max2 = constraintsAxis.max - layoutAxis.max;
    if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
      [min2, max2] = [max2, min2];
    }
    return { min: min2, max: max2 };
  }
  function calcViewportConstraints(layoutBox, constraintsBox) {
    return {
      x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
      y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
    };
  }
  function calcOrigin(source, target) {
    let origin = 0.5;
    const sourceLength = calcLength(source);
    const targetLength = calcLength(target);
    if (targetLength > sourceLength) {
      origin = progress(target.min, target.max - sourceLength, source.min);
    } else if (sourceLength > targetLength) {
      origin = progress(source.min, source.max - targetLength, target.min);
    }
    return clamp(0, 1, origin);
  }
  function rebaseAxisConstraints(layout2, constraints) {
    const relativeConstraints = {};
    if (constraints.min !== void 0) {
      relativeConstraints.min = constraints.min - layout2.min;
    }
    if (constraints.max !== void 0) {
      relativeConstraints.max = constraints.max - layout2.min;
    }
    return relativeConstraints;
  }
  const defaultElastic = 0.35;
  function resolveDragElastic(dragElastic = defaultElastic) {
    if (dragElastic === false) {
      dragElastic = 0;
    } else if (dragElastic === true) {
      dragElastic = defaultElastic;
    }
    return {
      x: resolveAxisElastic(dragElastic, "left", "right"),
      y: resolveAxisElastic(dragElastic, "top", "bottom")
    };
  }
  function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
    return {
      min: resolvePointElastic(dragElastic, minLabel),
      max: resolvePointElastic(dragElastic, maxLabel)
    };
  }
  function resolvePointElastic(dragElastic, label) {
    return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
  }
  const elementDragControls = new WeakMap();
  class VisualElementDragControls {
    constructor(visualElement) {
      this.openDragLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
      this.visualElement = visualElement;
    }
    start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
      const { presenceContext } = this.visualElement;
      if (presenceContext && presenceContext.isPresent === false)
        return;
      const onSessionStart = (event) => {
        const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
        dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
        if (snapToCursor) {
          this.snapToCursor(extractEventInfo(event).point);
        }
      };
      const onStart = (event, info) => {
        const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
        if (drag2 && !dragPropagation) {
          if (this.openDragLock)
            this.openDragLock();
          this.openDragLock = setDragLock(drag2);
          if (!this.openDragLock)
            return;
        }
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.isDragging = true;
        this.currentDirection = null;
        this.resolveConstraints();
        if (this.visualElement.projection) {
          this.visualElement.projection.isAnimationBlocked = true;
          this.visualElement.projection.target = void 0;
        }
        eachAxis((axis) => {
          let current = this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            const { projection } = this.visualElement;
            if (projection && projection.layout) {
              const measuredAxis = projection.layout.layoutBox[axis];
              if (measuredAxis) {
                const length2 = calcLength(measuredAxis);
                current = length2 * (parseFloat(current) / 100);
              }
            }
          }
          this.originPoint[axis] = current;
        });
        if (onDragStart) {
          frame.postRender(() => onDragStart(event, info));
        }
        addValueToWillChange(this.visualElement, "transform");
        const { animationState } = this.visualElement;
        animationState && animationState.setActive("whileDrag", true);
      };
      const onMove = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
        if (!dragPropagation && !this.openDragLock)
          return;
        const { offset: offset2 } = info;
        if (dragDirectionLock && this.currentDirection === null) {
          this.currentDirection = getCurrentDirection(offset2);
          if (this.currentDirection !== null) {
            onDirectionLock && onDirectionLock(this.currentDirection);
          }
          return;
        }
        this.updateAxis("x", info.point, offset2);
        this.updateAxis("y", info.point, offset2);
        this.visualElement.render();
        onDrag && onDrag(event, info);
      };
      const onSessionEnd = (event, info) => {
        this.latestPointerEvent = event;
        this.latestPanInfo = info;
        this.stop(event, info);
        this.latestPointerEvent = null;
        this.latestPanInfo = null;
      };
      const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
      const { dragSnapToOrigin } = this.getProps();
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      }, {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        distanceThreshold,
        contextWindow: getContextWindow(this.visualElement)
      });
    }
stop(event, panInfo) {
      const finalEvent = event || this.latestPointerEvent;
      const finalPanInfo = panInfo || this.latestPanInfo;
      const isDragging2 = this.isDragging;
      this.cancel();
      if (!isDragging2 || !finalPanInfo || !finalEvent)
        return;
      const { velocity } = finalPanInfo;
      this.startAnimation(velocity);
      const { onDragEnd } = this.getProps();
      if (onDragEnd) {
        frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
      }
    }
cancel() {
      this.isDragging = false;
      const { projection, animationState } = this.visualElement;
      if (projection) {
        projection.isAnimationBlocked = false;
      }
      this.panSession && this.panSession.end();
      this.panSession = void 0;
      const { dragPropagation } = this.getProps();
      if (!dragPropagation && this.openDragLock) {
        this.openDragLock();
        this.openDragLock = null;
      }
      animationState && animationState.setActive("whileDrag", false);
    }
    updateAxis(axis, _point, offset2) {
      const { drag: drag2 } = this.getProps();
      if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      let next2 = this.originPoint[axis] + offset2[axis];
      if (this.constraints && this.constraints[axis]) {
        next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next2);
    }
    resolveConstraints() {
      const { dragConstraints, dragElastic } = this.getProps();
      const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
      const prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout2) {
          this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
        eachAxis((axis) => {
          if (this.constraints !== false && this.getAxisMotionValue(axis)) {
            this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
          }
        });
      }
    }
    resolveRefConstraints() {
      const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
      if (!constraints || !isRefObject(constraints))
        return false;
      const constraintsElement = constraints.current;
      const { projection } = this.visualElement;
      if (!projection || !projection.layout)
        return false;
      const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
      if (onMeasureDragConstraints) {
        const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    }
    startAnimation(velocity) {
      const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
      const constraints = this.constraints || {};
      const momentumAnimations = eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, this.currentDirection)) {
          return;
        }
        let transition = constraints && constraints[axis] || {};
        if (dragSnapToOrigin)
          transition = { min: 0, max: 0 };
        const bounceStiffness = dragElastic ? 200 : 1e6;
        const bounceDamping = dragElastic ? 40 : 1e7;
        const inertia2 = {
          type: "inertia",
          velocity: dragMomentum ? velocity[axis] : 0,
          bounceStiffness,
          bounceDamping,
          timeConstant: 750,
          restDelta: 1,
          restSpeed: 10,
          ...dragTransition,
          ...transition
        };
        return this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    }
    startAxisValueAnimation(axis, transition) {
      const axisValue = this.getAxisMotionValue(axis);
      addValueToWillChange(this.visualElement, axis);
      return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
    }
    stopAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).stop());
    }
    pauseAnimation() {
      eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
    }
    getAnimationState(axis) {
      return this.getAxisMotionValue(axis).animation?.state;
    }
getAxisMotionValue(axis) {
      const dragKey = `_drag${axis.toUpperCase()}`;
      const props = this.visualElement.getProps();
      const externalMotionValue = props[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
    }
    snapToCursor(point) {
      eachAxis((axis) => {
        const { drag: drag2 } = this.getProps();
        if (!shouldDrag(axis, drag2, this.currentDirection))
          return;
        const { projection } = this.visualElement;
        const axisValue = this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
          axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
        }
      });
    }
scalePositionWithinConstraints() {
      if (!this.visualElement.current)
        return;
      const { drag: drag2, dragConstraints } = this.getProps();
      const { projection } = this.visualElement;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      const boxProgress = { x: 0, y: 0 };
      eachAxis((axis) => {
        const axisValue = this.getAxisMotionValue(axis);
        if (axisValue && this.constraints !== false) {
          const latest = axisValue.get();
          boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
        }
      });
      const { transformTemplate } = this.visualElement.getProps();
      this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis((axis) => {
        if (!shouldDrag(axis, drag2, null))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        const { min: min2, max: max2 } = this.constraints[axis];
        axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
      });
    }
    addListeners() {
      if (!this.visualElement.current)
        return;
      elementDragControls.set(this.visualElement, this);
      const element = this.visualElement.current;
      const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
        const { drag: drag2, dragListener = true } = this.getProps();
        drag2 && dragListener && this.start(event);
      });
      const measureDragConstraints = () => {
        const { dragConstraints } = this.getProps();
        if (isRefObject(dragConstraints) && dragConstraints.current) {
          this.constraints = this.resolveRefConstraints();
        }
      };
      const { projection } = this.visualElement;
      const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
      }
      frame.read(measureDragConstraints);
      const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
      const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          this.visualElement.render();
        }
      }));
      return () => {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
        stopLayoutUpdateListener && stopLayoutUpdateListener();
      };
    }
    getProps() {
      const props = this.visualElement.getProps();
      const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
      return {
        ...props,
        drag: drag2,
        dragDirectionLock,
        dragPropagation,
        dragConstraints,
        dragElastic,
        dragMomentum
      };
    }
  }
  function shouldDrag(direction, drag2, currentDirection) {
    return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
  }
  function getCurrentDirection(offset2, lockThreshold = 10) {
    let direction = null;
    if (Math.abs(offset2.y) > lockThreshold) {
      direction = "y";
    } else if (Math.abs(offset2.x) > lockThreshold) {
      direction = "x";
    }
    return direction;
  }
  class DragGesture extends Feature {
    constructor(node2) {
      super(node2);
      this.removeGroupControls = noop;
      this.removeListeners = noop;
      this.controls = new VisualElementDragControls(node2);
    }
    mount() {
      const { dragControls } = this.node.getProps();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
      this.removeListeners = this.controls.addListeners() || noop;
    }
    unmount() {
      this.removeGroupControls();
      this.removeListeners();
    }
  }
  const asyncHandler = (handler) => (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments);
      this.removePointerDownListener = noop;
    }
    onPointerDown(pointerDownEvent) {
      this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node)
      });
    }
    createPanHandlers() {
      const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(onPanSessionStart),
        onStart: asyncHandler(onPanStart),
        onMove: onPan,
        onEnd: (event, info) => {
          delete this.session;
          if (onPanEnd) {
            frame.postRender(() => onPanEnd(event, info));
          }
        }
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener();
      this.session && this.session.end();
    }
  }
  const globalProjectionState = {
hasAnimatedSinceResize: true,
hasEverUpdated: false
  };
  function pixelsToPercent(pixels, axis) {
    if (axis.max === axis.min)
      return 0;
    return pixels / (axis.max - axis.min) * 100;
  }
  const correctBorderRadius = {
    correct: (latest, node2) => {
      if (!node2.target)
        return latest;
      if (typeof latest === "string") {
        if (px.test(latest)) {
          latest = parseFloat(latest);
        } else {
          return latest;
        }
      }
      const x2 = pixelsToPercent(latest, node2.target.x);
      const y = pixelsToPercent(latest, node2.target.y);
      return `${x2}% ${y}%`;
    }
  };
  const correctBoxShadow = {
    correct: (latest, { treeScale, projectionDelta }) => {
      const original = latest;
      const shadow = complex.parse(latest);
      if (shadow.length > 5)
        return original;
      const template = complex.createTransformer(latest);
      const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
      const xScale = projectionDelta.x.scale * treeScale.x;
      const yScale = projectionDelta.y.scale * treeScale.y;
      shadow[0 + offset2] /= xScale;
      shadow[1 + offset2] /= yScale;
      const averageScale = mixNumber$1(xScale, yScale, 0.5);
      if (typeof shadow[2 + offset2] === "number")
        shadow[2 + offset2] /= averageScale;
      if (typeof shadow[3 + offset2] === "number")
        shadow[3 + offset2] /= averageScale;
      return template(shadow);
    }
  };
  let hasTakenAnySnapshot = false;
  class MeasureLayoutWithContext extends reactExports.Component {
componentDidMount() {
      const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
      const { projection } = visualElement;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup.group)
          layoutGroup.group.add(projection);
        if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
          switchLayoutGroup.register(projection);
        }
        if (hasTakenAnySnapshot) {
          projection.root.didUpdate();
        }
        projection.addEventListener("animationComplete", () => {
          this.safeToRemove();
        });
        projection.setOptions({
          ...projection.options,
          onExitComplete: () => this.safeToRemove()
        });
      }
      globalProjectionState.hasEverUpdated = true;
    }
    getSnapshotBeforeUpdate(prevProps) {
      const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
      const { projection } = visualElement;
      if (!projection)
        return null;
      projection.isPresent = isPresent;
      hasTakenAnySnapshot = true;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent) {
        if (isPresent) {
          projection.promote();
        } else if (!projection.relegate()) {
          frame.postRender(() => {
            const stack = projection.getStack();
            if (!stack || !stack.members.length) {
              this.safeToRemove();
            }
          });
        }
      }
      return null;
    }
    componentDidUpdate() {
      const { projection } = this.props.visualElement;
      if (projection) {
        projection.root.didUpdate();
        microtask.postRender(() => {
          if (!projection.currentAnimation && projection.isLead()) {
            this.safeToRemove();
          }
        });
      }
    }
    componentWillUnmount() {
      const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
      const { projection } = visualElement;
      hasTakenAnySnapshot = true;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup && layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext && promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    }
    safeToRemove() {
      const { safeToRemove } = this.props;
      safeToRemove && safeToRemove();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(props) {
    const [isPresent, safeToRemove] = usePresence();
    const layoutGroup = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
  }
  const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
  };
  function animateSingleValue(value, keyframes2, options) {
    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
    return motionValue$1.animation;
  }
  const compareByDepth = (a, b2) => a.depth - b2.depth;
  class FlatTree {
    constructor() {
      this.children = [];
      this.isDirty = false;
    }
    add(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    }
    remove(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    }
    forEach(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    }
  }
  function delay(callback, timeout) {
    const start = time.now();
    const checkElapsed = ({ timestamp }) => {
      const elapsed = timestamp - start;
      if (elapsed >= timeout) {
        cancelFrame(checkElapsed);
        callback(elapsed - timeout);
      }
    };
    frame.setup(checkElapsed, true);
    return () => cancelFrame(checkElapsed);
  }
  const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
  const numBorders = borders.length;
  const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
  const isPx = (value) => typeof value === "number" || px.test(value);
  function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
    if (shouldCrossfadeOpacity) {
      target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
      target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
    } else if (isOnlyMember) {
      target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
    }
    for (let i = 0; i < numBorders; i++) {
      const borderLabel = `border${borders[i]}Radius`;
      let followRadius = getRadius(follow, borderLabel);
      let leadRadius = getRadius(lead, borderLabel);
      if (followRadius === void 0 && leadRadius === void 0)
        continue;
      followRadius || (followRadius = 0);
      leadRadius || (leadRadius = 0);
      const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
      if (canMix) {
        target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
        if (percent.test(leadRadius) || percent.test(followRadius)) {
          target[borderLabel] += "%";
        }
      } else {
        target[borderLabel] = leadRadius;
      }
    }
    if (follow.rotate || lead.rotate) {
      target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
    }
  }
  function getRadius(values, radiusName) {
    return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
  }
  const easeCrossfadeIn = compress(0, 0.5, circOut);
  const easeCrossfadeOut = compress(0.5, 0.95, noop);
  function compress(min2, max2, easing) {
    return (p) => {
      if (p < min2)
        return 0;
      if (p > max2)
        return 1;
      return easing( progress(min2, max2, p));
    };
  }
  function copyAxisInto(axis, originAxis) {
    axis.min = originAxis.min;
    axis.max = originAxis.max;
  }
  function copyBoxInto(box, originBox) {
    copyAxisInto(box.x, originBox.x);
    copyAxisInto(box.y, originBox.y);
  }
  function copyAxisDeltaInto(delta, originDelta) {
    delta.translate = originDelta.translate;
    delta.scale = originDelta.scale;
    delta.originPoint = originDelta.originPoint;
    delta.origin = originDelta.origin;
  }
  function removePointDelta(point, translate, scale2, originPoint, boxScale) {
    point -= translate;
    point = scalePoint(point, 1 / scale2, originPoint);
    if (boxScale !== void 0) {
      point = scalePoint(point, 1 / boxScale, originPoint);
    }
    return point;
  }
  function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
    if (percent.test(translate)) {
      translate = parseFloat(translate);
      const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
      translate = relativeProgress - sourceAxis.min;
    }
    if (typeof translate !== "number")
      return;
    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
    if (axis === originAxis)
      originPoint -= translate;
    axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
    axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
  }
  function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
  }
  const xKeys = ["x", "scaleX", "originX"];
  const yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(box, transforms, originBox, sourceBox) {
    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
  }
  function isAxisDeltaZero(delta) {
    return delta.translate === 0 && delta.scale === 1;
  }
  function isDeltaZero(delta) {
    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
  }
  function axisEquals(a, b2) {
    return a.min === b2.min && a.max === b2.max;
  }
  function boxEquals(a, b2) {
    return axisEquals(a.x, b2.x) && axisEquals(a.y, b2.y);
  }
  function axisEqualsRounded(a, b2) {
    return Math.round(a.min) === Math.round(b2.min) && Math.round(a.max) === Math.round(b2.max);
  }
  function boxEqualsRounded(a, b2) {
    return axisEqualsRounded(a.x, b2.x) && axisEqualsRounded(a.y, b2.y);
  }
  function aspectRatio(box) {
    return calcLength(box.x) / calcLength(box.y);
  }
  function axisDeltaEquals(a, b2) {
    return a.translate === b2.translate && a.scale === b2.scale && a.originPoint === b2.originPoint;
  }
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(node2) {
      addUniqueItem(this.members, node2);
      node2.scheduleRender();
    }
    remove(node2) {
      removeItem(this.members, node2);
      if (node2 === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node2 === this.lead) {
        const prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    }
    relegate(node2) {
      const indexOfNode = this.members.findIndex((member) => node2 === member);
      if (indexOfNode === 0)
        return false;
      let prevLead;
      for (let i = indexOfNode; i >= 0; i--) {
        const member = this.members[i];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    }
    promote(node2, preserveFollowOpacity) {
      const prevLead = this.lead;
      if (node2 === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node2;
      node2.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node2.scheduleRender();
        node2.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node2.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node2.snapshot = prevLead.snapshot;
          node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node2.root && node2.root.isUpdating) {
          node2.isLayoutDirty = true;
        }
        const { crossfade } = node2.options;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    }
    exitAnimationComplete() {
      this.members.forEach((node2) => {
        const { options, resumingFrom } = node2;
        options.onExitComplete && options.onExitComplete();
        if (resumingFrom) {
          resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
        }
      });
    }
    scheduleRender() {
      this.members.forEach((node2) => {
        node2.instance && node2.scheduleRender(false);
      });
    }
removeLeadSnapshot() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    }
  }
  function buildProjectionTransform(delta, treeScale, latestTransform) {
    let transform = "";
    const xTranslate = delta.x.translate / treeScale.x;
    const yTranslate = delta.y.translate / treeScale.y;
    const zTranslate = latestTransform?.z || 0;
    if (xTranslate || yTranslate || zTranslate) {
      transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
    }
    if (treeScale.x !== 1 || treeScale.y !== 1) {
      transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
    }
    if (latestTransform) {
      const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
      if (transformPerspective)
        transform = `perspective(${transformPerspective}px) ${transform}`;
      if (rotate2)
        transform += `rotate(${rotate2}deg) `;
      if (rotateX)
        transform += `rotateX(${rotateX}deg) `;
      if (rotateY)
        transform += `rotateY(${rotateY}deg) `;
      if (skewX)
        transform += `skewX(${skewX}deg) `;
      if (skewY)
        transform += `skewY(${skewY}deg) `;
    }
    const elementScaleX = delta.x.scale * treeScale.x;
    const elementScaleY = delta.y.scale * treeScale.y;
    if (elementScaleX !== 1 || elementScaleY !== 1) {
      transform += `scale(${elementScaleX}, ${elementScaleY})`;
    }
    return transform || "none";
  }
  const transformAxes = ["", "X", "Y", "Z"];
  const animationTarget = 1e3;
  let id = 0;
  function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
    const { latestValues } = visualElement;
    if (latestValues[key]) {
      values[key] = latestValues[key];
      visualElement.setStaticValue(key, 0);
      if (sharedAnimationValues) {
        sharedAnimationValues[key] = 0;
      }
    }
  }
  function cancelTreeOptimisedTransformAnimations(projectionNode) {
    projectionNode.hasCheckedOptimisedAppear = true;
    if (projectionNode.root === projectionNode)
      return;
    const { visualElement } = projectionNode.options;
    if (!visualElement)
      return;
    const appearId = getOptimisedAppearId(visualElement);
    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
      const { layout: layout2, layoutId } = projectionNode.options;
      window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
    }
    const { parent } = projectionNode;
    if (parent && !parent.hasCheckedOptimisedAppear) {
      cancelTreeOptimisedTransformAnimations(parent);
    }
  }
  function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
    return class ProjectionNode {
      constructor(latestValues = {}, parent = defaultParent?.()) {
        this.id = id++;
        this.animationId = 0;
        this.animationCommitId = 0;
        this.children = new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.isProjectionDirty = false;
        this.isSharedProjectionDirty = false;
        this.isTransformDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.hasCheckedOptimisedAppear = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = new Map();
        this.hasTreeAnimated = false;
        this.layoutVersion = 0;
        this.updateScheduled = false;
        this.scheduleUpdate = () => this.update();
        this.projectionUpdateScheduled = false;
        this.checkUpdateFailed = () => {
          if (this.isUpdating) {
            this.isUpdating = false;
            this.clearAllSnapshots();
          }
        };
        this.updateProjection = () => {
          this.projectionUpdateScheduled = false;
          this.nodes.forEach(propagateDirtyNodes);
          this.nodes.forEach(resolveTargetDelta);
          this.nodes.forEach(calcProjection);
          this.nodes.forEach(cleanDirtyNodes);
        };
        this.resolvedRelativeTargetAt = 0;
        this.linkedParentVersion = 0;
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = new Map();
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? [...parent.path, parent] : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        for (let i = 0; i < this.path.length; i++) {
          this.path[i].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      addEventListener(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      }
      notifyListeners(name, ...args) {
        const subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager && subscriptionManager.notify(...args);
      }
      hasListeners(name) {
        return this.eventHandlers.has(name);
      }
mount(instance) {
        if (this.instance)
          return;
        this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
        this.instance = instance;
        const { layoutId, layout: layout2, visualElement } = this.options;
        if (visualElement && !visualElement.current) {
          visualElement.mount(instance);
        }
        this.root.nodes.add(this);
        this.parent && this.parent.children.add(this);
        if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          let cancelDelay;
          let innerWidth = 0;
          const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
          frame.read(() => {
            innerWidth = window.innerWidth;
          });
          attachResizeListener(instance, () => {
            const newInnerWidth = window.innerWidth;
            if (newInnerWidth === innerWidth)
              return;
            innerWidth = newInnerWidth;
            this.root.updateBlockedByResize = true;
            cancelDelay && cancelDelay();
            cancelDelay = delay(resizeUnblockUpdate, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
          this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
            if (this.isTreeAnimationBlocked()) {
              this.target = void 0;
              this.relativeTarget = void 0;
              return;
            }
            const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
            const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
            const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
            const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
            if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
              if (this.resumeFrom) {
                this.resumingFrom = this.resumeFrom;
                this.resumingFrom.resumingFrom = void 0;
              }
              const animationOptions = {
                ...getValueTransition(layoutTransition, "layout"),
                onPlay: onLayoutAnimationStart,
                onComplete: onLayoutAnimationComplete
              };
              if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              this.startAnimation(animationOptions);
              this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            } else {
              if (!hasLayoutChanged) {
                finishAnimation(this);
              }
              if (this.isLead() && this.options.onExitComplete) {
                this.options.onExitComplete();
              }
            }
            this.targetLayout = newLayout;
          });
        }
      }
      unmount() {
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        const stack = this.getStack();
        stack && stack.remove(this);
        this.parent && this.parent.children.delete(this);
        this.instance = void 0;
        this.eventHandlers.clear();
        cancelFrame(this.updateProjection);
      }
blockUpdate() {
        this.updateManuallyBlocked = true;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = false;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
      }
startUpdate() {
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        this.nodes && this.nodes.forEach(resetSkewAndRotation);
        this.animationId++;
      }
      getTransformTemplate() {
        const { visualElement } = this.options;
        return visualElement && visualElement.getProps().transformTemplate;
      }
      willUpdate(shouldNotifyListeners = true) {
        this.root.hasTreeAnimated = true;
        if (this.root.isUpdateBlocked()) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(this);
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          node2.shouldResetTransform = true;
          node2.updateScroll("snapshot");
          if (node2.options.layoutRoot) {
            node2.willUpdate(false);
          }
        }
        const { layoutId, layout: layout2 } = this.options;
        if (layoutId === void 0 && !layout2)
          return;
        const transformTemplate = this.getTransformTemplate();
        this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      }
      update() {
        this.updateScheduled = false;
        const updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        this.animationCommitId = this.animationId;
        if (!this.isUpdating) {
          this.nodes.forEach(clearIsLayoutDirty);
        } else {
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
        }
        this.clearAllSnapshots();
        const now2 = time.now();
        frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
        frameData.timestamp = now2;
        frameData.isProcessing = true;
        frameSteps.update.process(frameData);
        frameSteps.preRender.process(frameData);
        frameSteps.render.process(frameData);
        frameData.isProcessing = false;
      }
      didUpdate() {
        if (!this.updateScheduled) {
          this.updateScheduled = true;
          microtask.read(this.scheduleUpdate);
        }
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        if (!this.projectionUpdateScheduled) {
          this.projectionUpdateScheduled = true;
          frame.preRender(this.updateProjection, false, true);
        }
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          if (this.isLayoutDirty) {
            this.root.didUpdate();
          } else {
            this.root.checkUpdateFailed();
          }
        });
      }
updateSnapshot() {
        if (this.snapshot || !this.instance)
          return;
        this.snapshot = this.measure();
        if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
          this.snapshot = void 0;
        }
      }
      updateLayout() {
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (let i = 0; i < this.path.length; i++) {
            const node2 = this.path[i];
            node2.updateScroll();
          }
        }
        const prevLayout = this.layout;
        this.layout = this.measure(false);
        this.layoutVersion++;
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement } = this.options;
        visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
      }
      updateScroll(phase = "measure") {
        let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
        if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
          needsMeasurement = false;
        }
        if (needsMeasurement && this.instance) {
          const isRoot = checkIsScrollRoot(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase,
            isRoot,
            offset: measureScroll(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : isRoot
          };
        }
      }
      resetTransform() {
        if (!resetTransform)
          return;
        const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
        const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        const transformTemplate = this.getTransformTemplate();
        const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
        const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      }
      measure(removeTransform = true) {
        const pageBox = this.measurePageBox();
        let layoutBox = this.removeElementScroll(pageBox);
        if (removeTransform) {
          layoutBox = this.removeTransform(layoutBox);
        }
        roundBox(layoutBox);
        return {
          animationId: this.root.animationId,
          measuredBox: pageBox,
          layoutBox,
          latestValues: {},
          source: this.id
        };
      }
      measurePageBox() {
        const { visualElement } = this.options;
        if (!visualElement)
          return createBox();
        const box = visualElement.measureViewportBox();
        const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
        if (!wasInScrollRoot) {
          const { scroll } = this.root;
          if (scroll) {
            translateAxis(box.x, scroll.offset.x);
            translateAxis(box.y, scroll.offset.y);
          }
        }
        return box;
      }
      removeElementScroll(box) {
        const boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        if (this.scroll?.wasRoot) {
          return boxWithoutScroll;
        }
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          const { scroll, options } = node2;
          if (node2 !== this.root && scroll && options.layoutScroll) {
            if (scroll.wasRoot) {
              copyBoxInto(boxWithoutScroll, box);
            }
            translateAxis(boxWithoutScroll.x, scroll.offset.x);
            translateAxis(boxWithoutScroll.y, scroll.offset.y);
          }
        }
        return boxWithoutScroll;
      }
      applyTransform(box, transformOnly = false) {
        const withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
            transformBox(withTransforms, {
              x: -node2.scroll.offset.x,
              y: -node2.scroll.offset.y
            });
          }
          if (!hasTransform(node2.latestValues))
            continue;
          transformBox(withTransforms, node2.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      }
      removeTransform(box) {
        const boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (let i = 0; i < this.path.length; i++) {
          const node2 = this.path[i];
          if (!node2.instance)
            continue;
          if (!hasTransform(node2.latestValues))
            continue;
          hasScale(node2.latestValues) && node2.updateSnapshot();
          const sourceBox = createBox();
          const nodeBox = node2.measurePageBox();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      }
      setTargetDelta(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
        this.isProjectionDirty = true;
      }
      setOptions(options) {
        this.options = {
          ...this.options,
          ...options,
          crossfade: options.crossfade !== void 0 ? options.crossfade : true
        };
      }
      clearMeasurements() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      }
      forceRelativeParentToResolveTarget() {
        if (!this.relativeParent)
          return;
        if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
          this.relativeParent.resolveTargetDelta(true);
        }
      }
      resolveTargetDelta(forceRecalculation = false) {
        const lead = this.getLead();
        this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
        this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
        this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        if (!this.layout || !(layout2 || layoutId))
          return;
        this.resolvedRelativeTargetAt = frameData.timestamp;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot) {
          this.removeRelativeTarget();
        }
        if (!this.targetDelta && !this.relativeTarget) {
          if (relativeParent && relativeParent.layout) {
            this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox);
          } else {
            this.removeRelativeTarget();
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
          this.forceRelativeParentToResolveTarget();
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.layoutBox);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
            this.createRelativeTarget(relativeParent, this.target, relativeParent.target);
          } else {
            this.relativeParent = this.relativeTarget = void 0;
          }
        }
      }
      getClosestProjectingParent() {
        if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
          return void 0;
        }
        if (this.parent.isProjecting()) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      }
      isProjecting() {
        return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
      }
      createRelativeTarget(relativeParent, layout2, parentLayout) {
        this.relativeParent = relativeParent;
        this.linkedParentVersion = relativeParent.layoutVersion;
        this.forceRelativeParentToResolveTarget();
        this.relativeTarget = createBox();
        this.relativeTargetOrigin = createBox();
        calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout);
        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
      }
      removeRelativeTarget() {
        this.relativeParent = this.relativeTarget = void 0;
      }
      calcProjection() {
        const lead = this.getLead();
        const isShared = Boolean(this.resumingFrom) || this !== lead;
        let canSkip = true;
        if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
          canSkip = false;
        }
        if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
          canSkip = false;
        }
        if (this.resolvedRelativeTargetAt === frameData.timestamp) {
          canSkip = false;
        }
        if (canSkip)
          return;
        const { layout: layout2, layoutId } = this.options;
        this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout2 || layoutId))
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const prevTreeScaleX = this.treeScale.x;
        const prevTreeScaleY = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
        if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
          lead.target = lead.layout.layoutBox;
          lead.targetWithTransforms = createBox();
        }
        const { target } = lead;
        if (!target) {
          if (this.prevProjectionDelta) {
            this.createProjectionDeltas();
            this.scheduleRender();
          }
          return;
        }
        if (!this.projectionDelta || !this.prevProjectionDelta) {
          this.createProjectionDeltas();
        } else {
          copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
          copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
        }
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      }
      hide() {
        this.isVisible = false;
      }
      show() {
        this.isVisible = true;
      }
      scheduleRender(notifyAll = true) {
        this.options.visualElement?.scheduleRender();
        if (notifyAll) {
          const stack = this.getStack();
          stack && stack.scheduleRender();
        }
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      }
      createProjectionDeltas() {
        this.prevProjectionDelta = createDelta();
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
        const snapshot = this.snapshot;
        const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
        const mixedValues = { ...this.latestValues };
        const targetDelta = createDelta();
        if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
          this.relativeTarget = this.relativeTargetOrigin = void 0;
        }
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        const relativeLayout = createBox();
        const snapshotSource = snapshot ? snapshot.source : void 0;
        const layoutSource = this.layout ? this.layout.source : void 0;
        const isSharedLayoutAnimation = snapshotSource !== layoutSource;
        const stack = this.getStack();
        const isOnlyMember = !stack || stack.members.length <= 1;
        const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        let prevRelativeTarget;
        this.mixTargetDelta = (latest) => {
          const progress2 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress2);
          mixAxisDelta(targetDelta.y, delta.y, progress2);
          this.setTargetDelta(targetDelta);
          if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
            calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
            mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
            if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
              this.isProjectionDirty = false;
            }
            if (!prevRelativeTarget)
              prevRelativeTarget = createBox();
            copyBoxInto(prevRelativeTarget, this.relativeTarget);
          }
          if (isSharedLayoutAnimation) {
            this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
          }
          this.root.scheduleUpdateProjection();
          this.scheduleRender();
          this.animationProgress = progress2;
        };
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(options) {
        this.notifyListeners("animationStart");
        this.currentAnimation?.stop();
        this.resumingFrom?.currentAnimation?.stop();
        if (this.pendingAnimation) {
          cancelFrame(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = frame.update(() => {
          globalProjectionState.hasAnimatedSinceResize = true;
          this.motionValue || (this.motionValue = motionValue(0));
          this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
            ...options,
            velocity: 0,
            isSync: true,
            onUpdate: (latest) => {
              this.mixTargetDelta(latest);
              options.onUpdate && options.onUpdate(latest);
            },
            onStop: () => {
            },
            onComplete: () => {
              options.onComplete && options.onComplete();
              this.completeAnimation();
            }
          });
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = this.currentAnimation;
          }
          this.pendingAnimation = void 0;
        });
      }
      completeAnimation() {
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        const stack = this.getStack();
        stack && stack.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        if (this.currentAnimation) {
          this.mixTargetDelta && this.mixTargetDelta(animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      }
      applyTransformsToTarget() {
        const lead = this.getLead();
        let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
        if (!targetWithTransforms || !target || !layout2)
          return;
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target.x.min = lead.target.x.min;
          target.x.max = target.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target.y.min = lead.target.y.min;
          target.y.max = target.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
      registerSharedNode(layoutId, node2) {
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        const stack = this.sharedNodes.get(layoutId);
        stack.add(node2);
        const config = node2.options.initialPromotionConfig;
        node2.promote({
          transition: config ? config.transition : void 0,
          preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
        });
      }
      isLead() {
        const stack = this.getStack();
        return stack ? stack.lead === this : true;
      }
      getLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId } = this.options;
        return layoutId ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId } = this.options;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      }
      promote({ needsReset, transition, preserveFollowOpacity } = {}) {
        const stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition)
          this.setOptions({ transition });
      }
      relegate() {
        const stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      }
      resetSkewAndRotation() {
        const { visualElement } = this.options;
        if (!visualElement)
          return;
        let hasDistortingTransform = false;
        const { latestValues } = visualElement;
        if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
          hasDistortingTransform = true;
        }
        if (!hasDistortingTransform)
          return;
        const resetValues = {};
        if (latestValues.z) {
          resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
        }
        for (let i = 0; i < transformAxes.length; i++) {
          resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
          resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        }
        visualElement.render();
        for (const key in resetValues) {
          visualElement.setStaticValue(key, resetValues[key]);
          if (this.animationValues) {
            this.animationValues[key] = resetValues[key];
          }
        }
        visualElement.scheduleRender();
      }
      applyProjectionStyles(targetStyle, styleProp) {
        if (!this.instance || this.isSVG)
          return;
        if (!this.isVisible) {
          targetStyle.visibility = "hidden";
          return;
        }
        const transformTemplate = this.getTransformTemplate();
        if (this.needsReset) {
          this.needsReset = false;
          targetStyle.visibility = "";
          targetStyle.opacity = "";
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return;
        }
        const lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          if (this.options.layoutId) {
            targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
            targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return;
        }
        targetStyle.visibility = "";
        const valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          transform = transformTemplate(valuesToRender, transform);
        }
        targetStyle.transform = transform;
        const { x: x2, y } = this.projectionDelta;
        targetStyle.transformOrigin = `${x2.origin * 100}% ${y.origin * 100}% 0`;
        if (lead.animationValues) {
          targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
        }
        for (const key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
          const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
          if (applyTo) {
            const num = applyTo.length;
            for (let i = 0; i < num; i++) {
              targetStyle[applyTo[i]] = corrected;
            }
          } else {
            if (isCSSVariable) {
              this.options.visualElement.renderState.vars[key] = corrected;
            } else {
              targetStyle[key] = corrected;
            }
          }
        }
        if (this.options.layoutId) {
          targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
        }
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
resetTree() {
        this.root.nodes.forEach((node2) => node2.currentAnimation?.stop());
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(node2) {
    node2.updateLayout();
  }
  function notifyLayoutUpdate(node2) {
    const snapshot = node2.resumeFrom?.snapshot || node2.snapshot;
    if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
      const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
      const { animationType } = node2.options;
      const isShared = snapshot.source !== node2.layout.source;
      if (animationType === "size") {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length2 = calcLength(axisSnapshot);
          axisSnapshot.min = layout2[axis].min;
          axisSnapshot.max = axisSnapshot.min + length2;
        });
      } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
        eachAxis((axis) => {
          const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
          const length2 = calcLength(layout2[axis]);
          axisSnapshot.max = axisSnapshot.min + length2;
          if (node2.relativeTarget && !node2.currentAnimation) {
            node2.isProjectionDirty = true;
            node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
          }
        });
      }
      const layoutDelta = createDelta();
      calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
      const visualDelta = createDelta();
      if (isShared) {
        calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
      } else {
        calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
      }
      const hasLayoutChanged = !isDeltaZero(layoutDelta);
      let hasRelativeLayoutChanged = false;
      if (!node2.resumeFrom) {
        const relativeParent = node2.getClosestProjectingParent();
        if (relativeParent && !relativeParent.resumeFrom) {
          const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
          if (parentSnapshot && parentLayout) {
            const relativeSnapshot = createBox();
            calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
            const relativeLayout = createBox();
            calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
            if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
              hasRelativeLayoutChanged = true;
            }
            if (relativeParent.options.layoutRoot) {
              node2.relativeTarget = relativeLayout;
              node2.relativeTargetOrigin = relativeSnapshot;
              node2.relativeParent = relativeParent;
            }
          }
        }
      }
      node2.notifyListeners("didUpdate", {
        layout: layout2,
        snapshot,
        delta: visualDelta,
        layoutDelta,
        hasLayoutChanged,
        hasRelativeLayoutChanged
      });
    } else if (node2.isLead()) {
      const { onExitComplete } = node2.options;
      onExitComplete && onExitComplete();
    }
    node2.options.transition = void 0;
  }
  function propagateDirtyNodes(node2) {
    if (!node2.parent)
      return;
    if (!node2.isProjecting()) {
      node2.isProjectionDirty = node2.parent.isProjectionDirty;
    }
    node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
    node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
  }
  function cleanDirtyNodes(node2) {
    node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
  }
  function clearSnapshot(node2) {
    node2.clearSnapshot();
  }
  function clearMeasurements(node2) {
    node2.clearMeasurements();
  }
  function clearIsLayoutDirty(node2) {
    node2.isLayoutDirty = false;
  }
  function resetTransformStyle(node2) {
    const { visualElement } = node2.options;
    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
      visualElement.notify("BeforeLayoutMeasure");
    }
    node2.resetTransform();
  }
  function finishAnimation(node2) {
    node2.finishAnimation();
    node2.targetDelta = node2.relativeTarget = node2.target = void 0;
    node2.isProjectionDirty = true;
  }
  function resolveTargetDelta(node2) {
    node2.resolveTargetDelta();
  }
  function calcProjection(node2) {
    node2.calcProjection();
  }
  function resetSkewAndRotation(node2) {
    node2.resetSkewAndRotation();
  }
  function removeLeadSnapshots(stack) {
    stack.removeLeadSnapshot();
  }
  function mixAxisDelta(output, delta, p) {
    output.translate = mixNumber$1(delta.translate, 0, p);
    output.scale = mixNumber$1(delta.scale, 1, p);
    output.origin = delta.origin;
    output.originPoint = delta.originPoint;
  }
  function mixAxis(output, from2, to, p) {
    output.min = mixNumber$1(from2.min, to.min, p);
    output.max = mixNumber$1(from2.max, to.max, p);
  }
  function mixBox(output, from2, to, p) {
    mixAxis(output.x, from2.x, to.x, p);
    mixAxis(output.y, from2.y, to.y, p);
  }
  function hasOpacityCrossfade(node2) {
    return node2.animationValues && node2.animationValues.opacityExit !== void 0;
  }
  const defaultLayoutTransition = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1]
  };
  const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
  const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
  function roundAxis(axis) {
    axis.min = roundPoint(axis.min);
    axis.max = roundPoint(axis.max);
  }
  function roundBox(box) {
    roundAxis(box.x);
    roundAxis(box.y);
  }
  function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
    return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
  }
  function checkNodeWasScrollRoot(node2) {
    return node2 !== node2.root && node2.scroll?.wasRoot;
  }
  const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => true
  });
  const rootProjectionNode = {
    current: void 0
  };
  const HTMLProjectionNode = createProjectionNode({
    measureScroll: (instance) => ({
      x: instance.scrollLeft,
      y: instance.scrollTop
    }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const documentNode = new DocumentProjectionNode({});
        documentNode.mount(window);
        documentNode.setOptions({ layoutScroll: true });
        rootProjectionNode.current = documentNode;
      }
      return rootProjectionNode.current;
    },
    resetTransform: (instance, value) => {
      instance.style.transform = value !== void 0 ? value : "none";
    },
    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
  });
  const drag = {
    pan: {
      Feature: PanGesture
    },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  function handleHoverEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.animationState && props.whileHover) {
      node2.animationState.setActive("whileHover", lifecycle === "Start");
    }
    const eventName = "onHover" + lifecycle;
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class HoverGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = hover(current, (_element, startEvent) => {
        handleHoverEvent(this.node, startEvent, "Start");
        return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
      });
    }
    unmount() {
    }
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments);
      this.isActive = false;
    }
    onFocus() {
      let isFocusVisible2 = false;
      try {
        isFocusVisible2 = this.node.current.matches(":focus-visible");
      } catch (e) {
        isFocusVisible2 = true;
      }
      if (!isFocusVisible2 || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", true);
      this.isActive = true;
    }
    onBlur() {
      if (!this.isActive || !this.node.animationState)
        return;
      this.node.animationState.setActive("whileFocus", false);
      this.isActive = false;
    }
    mount() {
      this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
    }
    unmount() {
    }
  }
  function handlePressEvent(node2, event, lifecycle) {
    const { props } = node2;
    if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
      return;
    }
    if (node2.animationState && props.whileTap) {
      node2.animationState.setActive("whileTap", lifecycle === "Start");
    }
    const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
    const callback = props[eventName];
    if (callback) {
      frame.postRender(() => callback(event, extractEventInfo(event)));
    }
  }
  class PressGesture extends Feature {
    mount() {
      const { current } = this.node;
      if (!current)
        return;
      this.unmount = press(current, (_element, startEvent) => {
        handlePressEvent(this.node, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
      }, { useGlobalTarget: this.node.props.globalTapTarget });
    }
    unmount() {
    }
  }
  const observerCallbacks = new WeakMap();
  const observers = new WeakMap();
  const fireObserverCallback = (entry) => {
    const callback = observerCallbacks.get(entry.target);
    callback && callback(entry);
  };
  const fireAllObserverCallbacks = (entries) => {
    entries.forEach(fireObserverCallback);
  };
  function initIntersectionObserver({ root: root2, ...options }) {
    const lookupRoot = root2 || document;
    if (!observers.has(lookupRoot)) {
      observers.set(lookupRoot, {});
    }
    const rootObservers = observers.get(lookupRoot);
    const key = JSON.stringify(options);
    if (!rootObservers[key]) {
      rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
    }
    return rootObservers[key];
  }
  function observeIntersection(element, options, callback) {
    const rootInteresectionObserver = initIntersectionObserver(options);
    observerCallbacks.set(element, callback);
    rootInteresectionObserver.observe(element);
    return () => {
      observerCallbacks.delete(element);
      rootInteresectionObserver.unobserve(element);
    };
  }
  const thresholdNames = {
    some: 0,
    all: 1
  };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments);
      this.hasEnteredView = false;
      this.isInView = false;
    }
    startObserver() {
      this.unmount();
      const { viewport = {} } = this.node.getProps();
      const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
      const options = {
        root: root2 ? root2.current : void 0,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholdNames[amount]
      };
      const onIntersectionUpdate = (entry) => {
        const { isIntersecting } = entry;
        if (this.isInView === isIntersecting)
          return;
        this.isInView = isIntersecting;
        if (once && !isIntersecting && this.hasEnteredView) {
          return;
        } else if (isIntersecting) {
          this.hasEnteredView = true;
        }
        if (this.node.animationState) {
          this.node.animationState.setActive("whileInView", isIntersecting);
        }
        const { onViewportEnter, onViewportLeave } = this.node.getProps();
        const callback = isIntersecting ? onViewportEnter : onViewportLeave;
        callback && callback(entry);
      };
      return observeIntersection(this.node.current, options, onIntersectionUpdate);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver === "undefined")
        return;
      const { props, prevProps } = this.node;
      const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
      if (hasOptionsChanged) {
        this.startObserver();
      }
    }
    unmount() {
    }
  }
  function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
    return (name) => viewport[name] !== prevViewport[name];
  }
  const gestureAnimations = {
    inView: {
      Feature: InViewFeature
    },
    tap: {
      Feature: PressGesture
    },
    focus: {
      Feature: FocusGesture
    },
    hover: {
      Feature: HoverGesture
    }
  };
  const layout = {
    layout: {
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout
    }
  };
  const featureBundle = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
  };
  const motion = createMotionProxy(featureBundle, createDomVisualElement);
  const NameProviderId = {
    CRM_BIZPROC_TASK: "  CRM (-)",
    CRM_TODO: "  ",
    VOXIMPLANT_CALL: "",
    CRM_TASKS_TASK: "  CRM (  )",
    TASKS: "",
    CRM_EMAIL: "",
    CRM_MEETING: "",
    CRM_WEBFORM: "-",
    CALL_LIST: " ",
    IMOPENLINES_SESSION: " "
  };
  const ProviderIdToUrl = (Task) => {
    switch (Task.providerID) {
      case "IMOPENLINES_SESSION":
        return "#";
      case "CRM_WEBFORM":
        return "#";
      case "CALL_LIST":
        return "#";
      case "CRM_EMAIL":
        return "#";
      case "CRM_MEETING":
        if (Task.ownerType === "DEAL") {
          return `${Task.ownerUrl}`;
        }
        return `#`;
      case "TASKS":
        return `${Task.responsibleUrl}tasks/task/view/${Task.associatedEntityID}/`;
      case "CRM_TASKS_TASK":
        return `${Task.responsibleUrl}tasks/task/view/${Task.associatedEntityID}/`;
      case "CRM_TODO":
        if (Task.ownerType === "DEAL") {
          return `${Task.ownerUrl}`;
        }
        if (Task.ownerType === "LEAD") {
          return `${Task.ownerUrl}`;
        }
        return `/crm/contact/details/${Task.ownerID}`;
      case "CRM_BIZPROC_TASK":
        return `${Task.ownerUrl}`;
      case "VOXIMPLANT_CALL":
        return `/crm/contact/details/${Task.ownerID}`;
      default:
        return "#";
    }
  };
  const ProviderIdOnClick = (TaskItem) => {
    switch (TaskItem.providerID) {
      case "IMOPENLINES_SESSION":
      case "CRM_EMAIL":
      case "CALL_LIST":
      case "CRM_WEBFORM":
        return () => {
          window.BX.CrmActivityEditor.items["MY_ACTIVITIES_crm_activity_grid_editor"].viewActivity(TaskItem.ID, {});
        };
    }
  };
  const DaysName = ["", "", "", "", "", "", ""];
  const FormatNumber = (num) => {
    return Number(num) > 9 ? `${num}` : `0${num}`;
  };
  const DrawDayColor = (MinAndMax, TaskCount) => {
    const [min2, max2] = MinAndMax;
    if (max2 <= min2) return "rgb(0,255,0)";
    const t = Math.min(Math.max((TaskCount - min2) / (max2 - min2), 0), 1);
    let r = 0, g = 0, b2 = 0;
    if (t <= 0.5) {
      const k = t / 0.5;
      r = Math.round(255 * k);
      g = 255;
    } else {
      const k = (t - 0.5) / 0.5;
      r = 255;
      g = Math.round(255 * (1 - k));
    }
    return `rgb(${r}, ${g}, ${b2})`;
  };
  const RenderMonthName = (t0) => {
    const $ = compilerRuntimeExports.c(11);
    const {
      cursor: cursor2
    } = t0;
    let t1;
    let t2;
    if ($[0] !== cursor2.dayIndex || $[1] !== cursor2.month || $[2] !== cursor2.year) {
      const date = new Date(cursor2.year, cursor2.month, cursor2.dayIndex + 1);
      const monthName = date.toLocaleDateString("ru", {
        month: "long"
      });
      t1 = monthName.charAt(0).toUpperCase();
      t2 = monthName.slice(1);
      $[0] = cursor2.dayIndex;
      $[1] = cursor2.month;
      $[2] = cursor2.year;
      $[3] = t1;
      $[4] = t2;
    } else {
      t1 = $[3];
      t2 = $[4];
    }
    const MonthName = t1 + t2;
    let t3;
    if ($[5] === Symbol.for("react.memo_cache_sentinel")) {
      t3 = jsxRuntimeExports.jsx(Separator, { flex: "1", variant: "solid", bg: "white" });
      $[5] = t3;
    } else {
      t3 = $[5];
    }
    let t4;
    if ($[6] !== MonthName) {
      t4 = jsxRuntimeExports.jsx(Heading, { as: "h2", children: MonthName });
      $[6] = MonthName;
      $[7] = t4;
    } else {
      t4 = $[7];
    }
    let t5;
    if ($[8] === Symbol.for("react.memo_cache_sentinel")) {
      t5 = jsxRuntimeExports.jsx(Separator, { flex: "1", variant: "solid" });
      $[8] = t5;
    } else {
      t5 = $[8];
    }
    let t6;
    if ($[9] !== t4) {
      t6 = jsxRuntimeExports.jsxs(HStack, { children: [
        t3,
        t4,
        t5
      ] });
      $[9] = t4;
      $[10] = t6;
    } else {
      t6 = $[10];
    }
    return t6;
  };
  const isToday = (daysString) => {
    const Today = new Date();
    const [day, month, year] = daysString.split(".").map(Number);
    return year === Today.getFullYear() && month === Today.getMonth() + 1 && day === Today.getDate();
  };
  const RenderMonth = (t0) => {
    const $ = compilerRuntimeExports.c(32);
    const {
      deals,
      cursor: cursor2,
      MinAndMaxTasks,
      goToDay
    } = t0;
    let T0;
    let T1;
    let t1;
    let t2;
    let t3;
    let t4;
    let t5;
    let t6;
    if ($[0] !== cursor2.month || $[1] !== cursor2.year) {
      const daysInMonth = getDaysInMonth(cursor2.year, cursor2.month);
      const firstDay = new Date(cursor2.year, cursor2.month, 1).getDay();
      const offset2 = (firstDay + 6) % 7;
      T1 = Box;
      t2 = "grid";
      t3 = "repeat(7, 1fr)";
      t4 = "1";
      t5 = "100%";
      let t72;
      if ($[10] !== offset2) {
        t72 = Array(offset2).fill(null);
        $[10] = offset2;
        $[11] = t72;
      } else {
        t72 = $[11];
      }
      if ($[12] !== t72) {
        t6 = jsxRuntimeExports.jsx(For, { each: t72, children: _temp$1 });
        $[12] = t72;
        $[13] = t6;
      } else {
        t6 = $[13];
      }
      T0 = For;
      t1 = Array(daysInMonth).fill(0);
      $[0] = cursor2.month;
      $[1] = cursor2.year;
      $[2] = T0;
      $[3] = T1;
      $[4] = t1;
      $[5] = t2;
      $[6] = t3;
      $[7] = t4;
      $[8] = t5;
      $[9] = t6;
    } else {
      T0 = $[2];
      T1 = $[3];
      t1 = $[4];
      t2 = $[5];
      t3 = $[6];
      t4 = $[7];
      t5 = $[8];
      t6 = $[9];
    }
    let t7;
    if ($[14] !== MinAndMaxTasks || $[15] !== cursor2.month || $[16] !== cursor2.year || $[17] !== deals || $[18] !== goToDay) {
      t7 = (value, index_0) => {
        const day = index_0 + 1;
        const key = `${FormatNumber(day)}.${FormatNumber(cursor2.month + 1)}.${cursor2.year}`;
        const listTodo = [...deals.get(key)?.keys().map((_key) => `${NameProviderId[_key] ?? _key}: ${deals.get(key)?.get(_key)?.length}`) ?? []];
        const countTodo = deals.get(key)?.entries().reduce(_temp2$1, 0) ?? 0;
        return jsxRuntimeExports.jsxs(Cell, { bg: isWeekend(cursor2.year, cursor2.month, day) ? "linear-gradient(135deg, rgba(255,0,0,0.12), rgba(255,0,0,0.04))" : "whiteAlpha.500", boxShadow: "4px 4px 8px 0px rgba(34, 60, 80, 0.2)", outline: isToday(key) ? "2px solid red" : "none", overflow: "scroll", marginTop: "1px", onClick: () => {
          console.log(day, cursor2.year, cursor2.month);
          goToDay(day, cursor2.year, cursor2.month);
        }, children: [
jsxRuntimeExports.jsx(HStack, { justifyContent: "space-between", children: jsxRuntimeExports.jsx(Box, { bg: "white", boxSize: "30px", rounded: "full", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "14px", fontWeight: "bold", color: "black", bgColor: DrawDayColor(MinAndMaxTasks, countTodo), children: day }) }),
jsxRuntimeExports.jsxs(Show, { when: deals.has(key), children: [
jsxRuntimeExports.jsx(Text, { children: ` : ${countTodo}` }),
jsxRuntimeExports.jsx(Separator, {}),
jsxRuntimeExports.jsx(VStack, { h: "5", alignItems: "flex-start", children: jsxRuntimeExports.jsx(For, { each: listTodo, children: _temp3 }) })
          ] })
        ] }, `day-${day}`);
      };
      $[14] = MinAndMaxTasks;
      $[15] = cursor2.month;
      $[16] = cursor2.year;
      $[17] = deals;
      $[18] = goToDay;
      $[19] = t7;
    } else {
      t7 = $[19];
    }
    let t8;
    if ($[20] !== T0 || $[21] !== t1 || $[22] !== t7) {
      t8 = jsxRuntimeExports.jsx(T0, { each: t1, children: t7 });
      $[20] = T0;
      $[21] = t1;
      $[22] = t7;
      $[23] = t8;
    } else {
      t8 = $[23];
    }
    let t9;
    if ($[24] !== T1 || $[25] !== t2 || $[26] !== t3 || $[27] !== t4 || $[28] !== t5 || $[29] !== t6 || $[30] !== t8) {
      t9 = jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(T1, { display: t2, gridTemplateColumns: t3, gap: t4, w: t5, children: [
        t6,
        t8
      ] }) });
      $[24] = T1;
      $[25] = t2;
      $[26] = t3;
      $[27] = t4;
      $[28] = t5;
      $[29] = t6;
      $[30] = t8;
      $[31] = t9;
    } else {
      t9 = $[31];
    }
    return t9;
  };
  const RenderDaysName = (t0) => {
    const $ = compilerRuntimeExports.c(5);
    const {
      cursor: cursor2,
      view
    } = t0;
    let t1;
    if ($[0] !== cursor2 || $[1] !== view) {
      t1 = view === "month" ? DaysName : getDaysInWeekUnderCursor(cursor2).map(_temp4);
      $[0] = cursor2;
      $[1] = view;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    const _DaysName = t1;
    let t2;
    if ($[3] !== _DaysName) {
      t2 = jsxRuntimeExports.jsx(Box, { display: "grid", gridTemplateColumns: "repeat(7, 1fr)", gap: "1", w: "100%", h: "auto", children: jsxRuntimeExports.jsx(For, { each: _DaysName, children: _temp5 }) });
      $[3] = _DaysName;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    return t2;
  };
  const RenderWeek = (t0) => {
    const $ = compilerRuntimeExports.c(8);
    const {
      deals,
      cursor: cursor2,
      MinAndMaxTasks
    } = t0;
    let t1;
    if ($[0] !== cursor2) {
      t1 = getDaysInWeekUnderCursor(cursor2);
      $[0] = cursor2;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const daysInWeek = t1;
    let t2;
    if ($[2] !== MinAndMaxTasks || $[3] !== deals) {
      t2 = (date, index) => {
        const key = `${FormatNumber(date.getDate())}.${FormatNumber(date.getMonth() + 1)}.${date.getFullYear()}`;
        const countTodo = deals.get(key)?.entries().reduce(_temp6, 0) ?? 0;
        return jsxRuntimeExports.jsxs(Cell, { bg: "whiteAlpha.500", outline: isToday(key) ? "2px solid red" : "none", h: "auto", margin: "2px", children: [
jsxRuntimeExports.jsxs(Box, { position: "sticky", top: 0, bg: "blue.400", children: [
jsxRuntimeExports.jsx(Box, { bg: "white", rounded: "2xl", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "14px", fontWeight: "bold", color: "black", marginBottom: "1", bgColor: DrawDayColor(MinAndMaxTasks, countTodo), children: key }),
jsxRuntimeExports.jsxs(Box, { bg: "white", rounded: "2xl", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "14px", fontWeight: "bold", color: "black", marginBottom: "1", children: [
jsxRuntimeExports.jsx(Show, { when: countTodo > 0, children: jsxRuntimeExports.jsx(Mark, { variant: "plain", children: jsxRuntimeExports.jsx(Text, { children: ` : ${countTodo}` }) }) }),
jsxRuntimeExports.jsx(Show, { when: countTodo == 0, children: jsxRuntimeExports.jsx(Text, { color: "blackAlpha.400", children: " " }) })
            ] })
          ] }),
jsxRuntimeExports.jsx(For, { each: Array(24).fill(null), children: (_2, hour) => {
            const keyAndHour = `${FormatNumber(date.getDate())}.${FormatNumber(date.getMonth() + 1)}.${date.getFullYear()} ${FormatNumber(hour)}`;
            const TaskByDate = deals.get(key);
            const TaskByHour = TaskByDate ? Array.from(TaskByDate.values()).flat().filter((task) => typeof task.deadline === "string" && task.deadline.startsWith(keyAndHour)) : [];
            return jsxRuntimeExports.jsxs(Flex, { justifyContent: "start", alignItems: "center", h: "100px", maxW: "250px", outline: "1px solid white", children: [
jsxRuntimeExports.jsx(Show, { when: index == 0, children: jsxRuntimeExports.jsx(Box, { writingMode: "sideways-lr", textAlign: "center", h: "100%", bg: "green.500", outline: "1px solid white", children: jsxRuntimeExports.jsx(Text, { children: `${FormatNumber(hour)}:00` }) }) }),
jsxRuntimeExports.jsx(VStack, { alignItems: "flex-start", justifyContent: "flex-start", h: "100%", w: "100%", overflow: "auto", scrollBehavior: "smooth", children: jsxRuntimeExports.jsx(For, { each: TaskByHour, children: _temp7 }) })
            ] }, `hour-${hour}`);
          } })
        ] }, `Day-${index}`);
      };
      $[2] = MinAndMaxTasks;
      $[3] = deals;
      $[4] = t2;
    } else {
      t2 = $[4];
    }
    let t3;
    if ($[5] !== daysInWeek || $[6] !== t2) {
      t3 = jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx(Box, { display: "grid", gridTemplateColumns: "repeat(7, 1fr)", gridTemplateRows: "repeat(1, 1fr)", gap: "1", w: "100%", h: "max-content", marginTop: "1px", children: jsxRuntimeExports.jsx(For, { each: daysInWeek, children: t2 }) }) });
      $[5] = daysInWeek;
      $[6] = t2;
      $[7] = t3;
    } else {
      t3 = $[7];
    }
    return t3;
  };
  const RenderDay = (t0) => {
    const $ = compilerRuntimeExports.c(95);
    const {
      deals,
      cursor: cursor2,
      MinAndMaxTasks
    } = t0;
    let CurrentDays;
    let t1;
    let t2;
    let t3;
    if ($[0] !== cursor2.dayIndex || $[1] !== cursor2.month || $[2] !== cursor2.year) {
      CurrentDays = new Date(cursor2.year, cursor2.month, cursor2.dayIndex, 0, 0, 0);
      t1 = FormatNumber(CurrentDays.getDate());
      const t42 = CurrentDays.getMonth() + 1;
      if ($[7] !== t42) {
        t2 = FormatNumber(t42);
        $[7] = t42;
        $[8] = t2;
      } else {
        t2 = $[8];
      }
      t3 = CurrentDays.getFullYear();
      $[0] = cursor2.dayIndex;
      $[1] = cursor2.month;
      $[2] = cursor2.year;
      $[3] = CurrentDays;
      $[4] = t1;
      $[5] = t2;
      $[6] = t3;
    } else {
      CurrentDays = $[3];
      t1 = $[4];
      t2 = $[5];
      t3 = $[6];
    }
    const key = `${t1}.${t2}.${t3}`;
    let T0;
    let T1;
    let T2;
    let T3;
    let countTodo;
    let t10;
    let t11;
    let t12;
    let t13;
    let t14;
    let t15;
    let t16;
    let t17;
    let t18;
    let t19;
    let t20;
    let t21;
    let t22;
    let t23;
    let t24;
    let t25;
    let t26;
    let t27;
    let t4;
    let t5;
    let t6;
    let t7;
    let t8;
    let t9;
    if ($[9] !== MinAndMaxTasks || $[10] !== deals || $[11] !== key) {
      countTodo = deals.get(key)?.entries().reduce(_temp8, 0) ?? 0;
      console.log(deals);
      T3 = Box;
      t21 = "grid";
      t22 = "1";
      t23 = "100%";
      t24 = "70dvh";
      t25 = "1px";
      t26 = "auto";
      t27 = "smooth";
      T2 = Cell;
      t17 = "whiteAlpha.500";
      t18 = isToday(key) ? "2px solid red" : "none";
      t19 = "auto";
      t20 = "2px";
      T1 = Box;
      t14 = "sticky";
      t15 = 0;
      t16 = "blue.400";
      T0 = Box;
      t4 = "white";
      t5 = "2xl";
      t6 = "flex";
      t7 = "center";
      t8 = "center";
      t9 = "14px";
      t10 = "bold";
      t11 = "black";
      t12 = "1";
      t13 = DrawDayColor(MinAndMaxTasks, countTodo);
      $[9] = MinAndMaxTasks;
      $[10] = deals;
      $[11] = key;
      $[12] = T0;
      $[13] = T1;
      $[14] = T2;
      $[15] = T3;
      $[16] = countTodo;
      $[17] = t10;
      $[18] = t11;
      $[19] = t12;
      $[20] = t13;
      $[21] = t14;
      $[22] = t15;
      $[23] = t16;
      $[24] = t17;
      $[25] = t18;
      $[26] = t19;
      $[27] = t20;
      $[28] = t21;
      $[29] = t22;
      $[30] = t23;
      $[31] = t24;
      $[32] = t25;
      $[33] = t26;
      $[34] = t27;
      $[35] = t4;
      $[36] = t5;
      $[37] = t6;
      $[38] = t7;
      $[39] = t8;
      $[40] = t9;
    } else {
      T0 = $[12];
      T1 = $[13];
      T2 = $[14];
      T3 = $[15];
      countTodo = $[16];
      t10 = $[17];
      t11 = $[18];
      t12 = $[19];
      t13 = $[20];
      t14 = $[21];
      t15 = $[22];
      t16 = $[23];
      t17 = $[24];
      t18 = $[25];
      t19 = $[26];
      t20 = $[27];
      t21 = $[28];
      t22 = $[29];
      t23 = $[30];
      t24 = $[31];
      t25 = $[32];
      t26 = $[33];
      t27 = $[34];
      t4 = $[35];
      t5 = $[36];
      t6 = $[37];
      t7 = $[38];
      t8 = $[39];
      t9 = $[40];
    }
    let t28;
    if ($[41] !== T0 || $[42] !== key || $[43] !== t10 || $[44] !== t11 || $[45] !== t12 || $[46] !== t13 || $[47] !== t4 || $[48] !== t5 || $[49] !== t6 || $[50] !== t7 || $[51] !== t8 || $[52] !== t9) {
      t28 = jsxRuntimeExports.jsx(T0, { bg: t4, rounded: t5, display: t6, alignItems: t7, justifyContent: t8, fontSize: t9, fontWeight: t10, color: t11, marginBottom: t12, bgColor: t13, children: key });
      $[41] = T0;
      $[42] = key;
      $[43] = t10;
      $[44] = t11;
      $[45] = t12;
      $[46] = t13;
      $[47] = t4;
      $[48] = t5;
      $[49] = t6;
      $[50] = t7;
      $[51] = t8;
      $[52] = t9;
      $[53] = t28;
    } else {
      t28 = $[53];
    }
    const t29 = countTodo > 0;
    const t30 = ` : ${countTodo}`;
    let t31;
    if ($[54] !== t30) {
      t31 = jsxRuntimeExports.jsx(Mark, { variant: "plain", children: jsxRuntimeExports.jsx(Text, { children: t30 }) });
      $[54] = t30;
      $[55] = t31;
    } else {
      t31 = $[55];
    }
    let t32;
    if ($[56] !== t29 || $[57] !== t31) {
      t32 = jsxRuntimeExports.jsx(Show, { when: t29, children: t31 });
      $[56] = t29;
      $[57] = t31;
      $[58] = t32;
    } else {
      t32 = $[58];
    }
    const t33 = countTodo == 0;
    let t34;
    if ($[59] === Symbol.for("react.memo_cache_sentinel")) {
      t34 = jsxRuntimeExports.jsx(Text, { color: "blackAlpha.400", children: " " });
      $[59] = t34;
    } else {
      t34 = $[59];
    }
    let t35;
    if ($[60] !== t33) {
      t35 = jsxRuntimeExports.jsx(Show, { when: t33, children: t34 });
      $[60] = t33;
      $[61] = t35;
    } else {
      t35 = $[61];
    }
    let t36;
    if ($[62] !== t32 || $[63] !== t35) {
      t36 = jsxRuntimeExports.jsxs(Box, { bg: "white", rounded: "2xl", display: "flex", alignItems: "center", justifyContent: "center", fontSize: "14px", fontWeight: "bold", color: "black", marginBottom: "1", children: [
        t32,
        t35
      ] });
      $[62] = t32;
      $[63] = t35;
      $[64] = t36;
    } else {
      t36 = $[64];
    }
    let t37;
    if ($[65] !== T1 || $[66] !== t14 || $[67] !== t15 || $[68] !== t16 || $[69] !== t28 || $[70] !== t36) {
      t37 = jsxRuntimeExports.jsxs(T1, { position: t14, top: t15, bg: t16, children: [
        t28,
        t36
      ] });
      $[65] = T1;
      $[66] = t14;
      $[67] = t15;
      $[68] = t16;
      $[69] = t28;
      $[70] = t36;
      $[71] = t37;
    } else {
      t37 = $[71];
    }
    let t38;
    if ($[72] === Symbol.for("react.memo_cache_sentinel")) {
      t38 = Array(24).fill(null);
      $[72] = t38;
    } else {
      t38 = $[72];
    }
    let t39;
    if ($[73] !== CurrentDays || $[74] !== deals || $[75] !== key) {
      t39 = jsxRuntimeExports.jsx(For, { each: t38, children: (_2, hour) => {
        const keyAndHour = `${FormatNumber(CurrentDays.getDate())}.${FormatNumber(CurrentDays.getMonth() + 1)}.${CurrentDays.getFullYear()} ${FormatNumber(hour)}`;
        const TaskByDate = deals.get(key);
        const TaskByHour = TaskByDate ? Array.from(TaskByDate.values()).flat().filter((task) => typeof task.deadline === "string" && task.deadline.startsWith(keyAndHour)) : [];
        return jsxRuntimeExports.jsxs(Flex, { justifyContent: "start", alignItems: "center", h: TaskByHour.length > 0 ? "150px" : "50px", outline: "1px solid white", children: [
jsxRuntimeExports.jsx(Box, { writingMode: "sideways-lr", textAlign: "center", h: "100%", bg: "green.500", outline: "1px solid white", children: jsxRuntimeExports.jsx(Text, { children: `${FormatNumber(hour)}:00` }) }),
jsxRuntimeExports.jsx(ScrollAreaRoot, { h: TaskByHour.length > 2 ? "150px" : "50px", children: jsxRuntimeExports.jsx(ScrollAreaViewport, { css: {
            "--scroll-shadow-size": "2rem",
            maskImage: "linear-gradient(#000,#000,transparent 0,#000 var(--scroll-shadow-size),#000 calc(100% - var(--scroll-shadow-size)),transparent)",
            "&[data-at-top]": {
              maskImage: "linear-gradient(180deg,#000 calc(100% - var(--scroll-shadow-size)),transparent)"
            },
            "&[data-at-bottom]": {
              maskImage: "linear-gradient(0deg,#000 calc(100% - var(--scroll-shadow-size)),transparent)"
            }
          }, children: jsxRuntimeExports.jsx(ScrollAreaContent, { spaceY: "4", children: jsxRuntimeExports.jsx(VStack, { alignItems: "flex-start", justifyContent: "flex-start", h: "100%", w: "100%", overflow: "auto", scrollBehavior: "smooth", children: jsxRuntimeExports.jsx(For, { each: TaskByHour, children: _temp9 }) }) }) }) })
        ] }, `hour-${hour}`);
      } });
      $[73] = CurrentDays;
      $[74] = deals;
      $[75] = key;
      $[76] = t39;
    } else {
      t39 = $[76];
    }
    let t40;
    if ($[77] !== T2 || $[78] !== t17 || $[79] !== t18 || $[80] !== t19 || $[81] !== t20 || $[82] !== t37 || $[83] !== t39) {
      t40 = jsxRuntimeExports.jsxs(T2, { bg: t17, outline: t18, h: t19, margin: t20, children: [
        t37,
        t39
      ] });
      $[77] = T2;
      $[78] = t17;
      $[79] = t18;
      $[80] = t19;
      $[81] = t20;
      $[82] = t37;
      $[83] = t39;
      $[84] = t40;
    } else {
      t40 = $[84];
    }
    let t41;
    if ($[85] !== T3 || $[86] !== t21 || $[87] !== t22 || $[88] !== t23 || $[89] !== t24 || $[90] !== t25 || $[91] !== t26 || $[92] !== t27 || $[93] !== t40) {
      t41 = jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx(T3, { display: t21, gap: t22, w: t23, h: t24, marginTop: t25, overflow: t26, scrollBehavior: t27, children: t40 }) });
      $[85] = T3;
      $[86] = t21;
      $[87] = t22;
      $[88] = t23;
      $[89] = t24;
      $[90] = t25;
      $[91] = t26;
      $[92] = t27;
      $[93] = t40;
      $[94] = t41;
    } else {
      t41 = $[94];
    }
    return t41;
  };
  const CalendarGrid = (t0) => {
    const $ = compilerRuntimeExports.c(104);
    const {
      deals
    } = t0;
    const {
      view,
      cursor: cursor2,
      next: next2,
      prev: prev2,
      setView,
      goToDay
    } = useCalendarNavigator();
    const [direction, setDirection] = reactExports.useState(0);
    let t1;
    if ($[0] !== next2) {
      t1 = () => {
        setDirection(1);
        next2();
      };
      $[0] = next2;
      $[1] = t1;
    } else {
      t1 = $[1];
    }
    const handleNext = t1;
    let t2;
    if ($[2] !== prev2) {
      t2 = () => {
        setDirection(-1);
        prev2();
      };
      $[2] = prev2;
      $[3] = t2;
    } else {
      t2 = $[3];
    }
    const handlePrev = t2;
    let MinAndMaxTasks;
    let TaskByDaysAndProviderId;
    if ($[4] !== deals) {
      const TasksByDays = new Map();
      deals.forEach((task) => {
        const day = task.deadline.split(" ")[0];
        if (TasksByDays.has(day)) {
          TasksByDays.get(day)?.push(task);
        } else {
          TasksByDays.set(day, [task]);
        }
      });
      TaskByDaysAndProviderId = new Map();
      MinAndMaxTasks = [0, 0];
      TasksByDays.forEach((tasks, day_0) => {
        const newMap = new Map();
        tasks.forEach((task_0) => {
          if (newMap.has(task_0.providerID)) {
            newMap.get(task_0.providerID)?.push(task_0);
          } else {
            newMap.set(task_0.providerID, [task_0]);
          }
        });
        TaskByDaysAndProviderId.set(day_0, newMap);
      });
      TasksByDays.forEach((tasks_0, day_1) => {
        const CountTask = tasks_0.length;
        MinAndMaxTasks[0] = CountTask < MinAndMaxTasks[0] ? CountTask : MinAndMaxTasks[0];
        MinAndMaxTasks[1] = CountTask > MinAndMaxTasks[1] ? CountTask : MinAndMaxTasks[1];
      });
      $[4] = deals;
      $[5] = MinAndMaxTasks;
      $[6] = TaskByDaysAndProviderId;
    } else {
      MinAndMaxTasks = $[5];
      TaskByDaysAndProviderId = $[6];
    }
    const t3 = deals.size !== 0;
    let t4;
    if ($[7] === Symbol.for("react.memo_cache_sentinel")) {
      t4 = jsxRuntimeExports.jsx(Flex, { justifyContent: "center", alignItems: "center", w: "full", h: "full", children: jsxRuntimeExports.jsxs(VStack, { children: [
jsxRuntimeExports.jsx(Heading, { children: "...." }),
jsxRuntimeExports.jsx(Spinner, { size: "xl" })
      ] }) });
      $[7] = t4;
    } else {
      t4 = $[7];
    }
    let t5;
    if ($[8] !== view) {
      t5 = jsxRuntimeExports.jsxs(Text, { children: [
        ": ",
        view
      ] });
      $[8] = view;
      $[9] = t5;
    } else {
      t5 = $[9];
    }
    let t6;
    if ($[10] !== cursor2.year) {
      t6 = jsxRuntimeExports.jsxs(Text, { children: [
        ": ",
        cursor2.year
      ] });
      $[10] = cursor2.year;
      $[11] = t6;
    } else {
      t6 = $[11];
    }
    let t7;
    if ($[12] !== cursor2.month) {
      t7 = jsxRuntimeExports.jsxs(Text, { children: [
        ": ",
        cursor2.month
      ] });
      $[12] = cursor2.month;
      $[13] = t7;
    } else {
      t7 = $[13];
    }
    let t8;
    if ($[14] !== cursor2.weekIndex) {
      t8 = jsxRuntimeExports.jsxs(Text, { children: [
        ": ",
        cursor2.weekIndex
      ] });
      $[14] = cursor2.weekIndex;
      $[15] = t8;
    } else {
      t8 = $[15];
    }
    let t9;
    if ($[16] !== cursor2.dayIndex) {
      t9 = jsxRuntimeExports.jsxs(Text, { children: [
        ": ",
        cursor2.dayIndex
      ] });
      $[16] = cursor2.dayIndex;
      $[17] = t9;
    } else {
      t9 = $[17];
    }
    let t10;
    if ($[18] !== handlePrev) {
      t10 = jsxRuntimeExports.jsx(Button, { onClick: handlePrev, children: "<-" });
      $[18] = handlePrev;
      $[19] = t10;
    } else {
      t10 = $[19];
    }
    let t11;
    if ($[20] !== handleNext) {
      t11 = jsxRuntimeExports.jsx(Button, { onClick: handleNext, children: "->" });
      $[20] = handleNext;
      $[21] = t11;
    } else {
      t11 = $[21];
    }
    let t12;
    if ($[22] !== t10 || $[23] !== t11) {
      t12 = jsxRuntimeExports.jsxs(HStack, { children: [
        t10,
        t11
      ] });
      $[22] = t10;
      $[23] = t11;
      $[24] = t12;
    } else {
      t12 = $[24];
    }
    let t13;
    if ($[25] !== setView) {
      t13 = (details) => {
        console.log(details);
        setView(details.value);
      };
      $[25] = setView;
      $[26] = t13;
    } else {
      t13 = $[26];
    }
    let t14;
    if ($[27] === Symbol.for("react.memo_cache_sentinel")) {
      t14 = jsxRuntimeExports.jsxs(TabsList, { bg: "bg.muted", rounded: "l3", p: "1", children: [
jsxRuntimeExports.jsx(TabsTrigger, { value: "month", children: "" }),
jsxRuntimeExports.jsx(TabsTrigger, { value: "week", children: "" }),
jsxRuntimeExports.jsx(TabsTrigger, { value: "day", children: "" }),
jsxRuntimeExports.jsx(TabsIndicator, { rounded: "l2" })
      ] });
      $[27] = t14;
    } else {
      t14 = $[27];
    }
    let t15;
    let t16;
    if ($[28] === Symbol.for("react.memo_cache_sentinel")) {
      t15 = jsxRuntimeExports.jsx(Heading, { as: "h1", color: "white", children: " " });
      t16 = jsxRuntimeExports.jsx(Separator, {});
      $[28] = t15;
      $[29] = t16;
    } else {
      t15 = $[28];
      t16 = $[29];
    }
    let t17;
    if ($[30] !== cursor2) {
      t17 = jsxRuntimeExports.jsx(RenderMonthName, { cursor: cursor2 });
      $[30] = cursor2;
      $[31] = t17;
    } else {
      t17 = $[31];
    }
    let t18;
    if ($[32] !== cursor2 || $[33] !== view) {
      t18 = jsxRuntimeExports.jsx(RenderDaysName, { cursor: cursor2, view });
      $[32] = cursor2;
      $[33] = view;
      $[34] = t18;
    } else {
      t18 = $[34];
    }
    const t19 = `${cursor2.year}-${cursor2.month}-${cursor2.weekIndex}-${cursor2.dayIndex}`;
    const t20 = direction > 0 ? 300 : -300;
    let t21;
    if ($[35] !== t20) {
      t21 = {
        x: t20,
        opacity: 0
      };
      $[35] = t20;
      $[36] = t21;
    } else {
      t21 = $[36];
    }
    let t22;
    if ($[37] === Symbol.for("react.memo_cache_sentinel")) {
      t22 = {
        x: 0,
        opacity: 1
      };
      $[37] = t22;
    } else {
      t22 = $[37];
    }
    const t23 = direction > 0 ? -300 : 300;
    let t24;
    if ($[38] !== t23) {
      t24 = {
        x: t23,
        opacity: 0
      };
      $[38] = t23;
      $[39] = t24;
    } else {
      t24 = $[39];
    }
    let t25;
    let t26;
    if ($[40] === Symbol.for("react.memo_cache_sentinel")) {
      t25 = {
        type: "tween",
        duration: 0.3
      };
      t26 = {
        width: "100%",
        height: "60dvh",
        overflow: "scroll"
      };
      $[40] = t25;
      $[41] = t26;
    } else {
      t25 = $[40];
      t26 = $[41];
    }
    let t27;
    if ($[42] !== MinAndMaxTasks || $[43] !== TaskByDaysAndProviderId || $[44] !== cursor2 || $[45] !== goToDay) {
      t27 = jsxRuntimeExports.jsx(RenderMonth, { deals: TaskByDaysAndProviderId, cursor: cursor2, MinAndMaxTasks, goToDay });
      $[42] = MinAndMaxTasks;
      $[43] = TaskByDaysAndProviderId;
      $[44] = cursor2;
      $[45] = goToDay;
      $[46] = t27;
    } else {
      t27 = $[46];
    }
    let t28;
    if ($[47] !== t19 || $[48] !== t21 || $[49] !== t24 || $[50] !== t27) {
      t28 = jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: jsxRuntimeExports.jsx(motion.div, { initial: t21, animate: t22, exit: t24, transition: t25, style: t26, children: t27 }, t19) });
      $[47] = t19;
      $[48] = t21;
      $[49] = t24;
      $[50] = t27;
      $[51] = t28;
    } else {
      t28 = $[51];
    }
    let t29;
    if ($[52] !== t17 || $[53] !== t18 || $[54] !== t28) {
      t29 = jsxRuntimeExports.jsx(TabsContent, { value: "month", children: jsxRuntimeExports.jsxs(VStack, { bg: "AccentColor", children: [
        t15,
        t16,
        t17,
        t18,
        t28
      ] }) });
      $[52] = t17;
      $[53] = t18;
      $[54] = t28;
      $[55] = t29;
    } else {
      t29 = $[55];
    }
    let t30;
    let t31;
    if ($[56] === Symbol.for("react.memo_cache_sentinel")) {
      t30 = jsxRuntimeExports.jsx(Heading, { as: "h1", children: " " });
      t31 = jsxRuntimeExports.jsx(Separator, {});
      $[56] = t30;
      $[57] = t31;
    } else {
      t30 = $[56];
      t31 = $[57];
    }
    let t32;
    if ($[58] !== cursor2) {
      t32 = jsxRuntimeExports.jsx(RenderMonthName, { cursor: cursor2 });
      $[58] = cursor2;
      $[59] = t32;
    } else {
      t32 = $[59];
    }
    let t33;
    if ($[60] !== cursor2 || $[61] !== view) {
      t33 = jsxRuntimeExports.jsx(RenderDaysName, { cursor: cursor2, view });
      $[60] = cursor2;
      $[61] = view;
      $[62] = t33;
    } else {
      t33 = $[62];
    }
    const t34 = `${cursor2.year}-${cursor2.month}-${cursor2.weekIndex}-${cursor2.dayIndex}`;
    const t35 = direction > 0 ? 300 : -300;
    let t36;
    if ($[63] !== t35) {
      t36 = {
        x: t35,
        opacity: 0
      };
      $[63] = t35;
      $[64] = t36;
    } else {
      t36 = $[64];
    }
    let t37;
    if ($[65] === Symbol.for("react.memo_cache_sentinel")) {
      t37 = {
        x: 0,
        opacity: 1
      };
      $[65] = t37;
    } else {
      t37 = $[65];
    }
    const t38 = direction > 0 ? -300 : 300;
    let t39;
    if ($[66] !== t38) {
      t39 = {
        x: t38,
        opacity: 0
      };
      $[66] = t38;
      $[67] = t39;
    } else {
      t39 = $[67];
    }
    let t40;
    let t41;
    if ($[68] === Symbol.for("react.memo_cache_sentinel")) {
      t40 = {
        type: "tween",
        duration: 0.3
      };
      t41 = {
        width: "100%",
        height: "60dvh",
        overflowY: "scroll"
      };
      $[68] = t40;
      $[69] = t41;
    } else {
      t40 = $[68];
      t41 = $[69];
    }
    let t42;
    if ($[70] !== MinAndMaxTasks || $[71] !== TaskByDaysAndProviderId || $[72] !== cursor2) {
      t42 = jsxRuntimeExports.jsx(RenderWeek, { deals: TaskByDaysAndProviderId, cursor: cursor2, MinAndMaxTasks });
      $[70] = MinAndMaxTasks;
      $[71] = TaskByDaysAndProviderId;
      $[72] = cursor2;
      $[73] = t42;
    } else {
      t42 = $[73];
    }
    let t43;
    if ($[74] !== t34 || $[75] !== t36 || $[76] !== t39 || $[77] !== t42) {
      t43 = jsxRuntimeExports.jsx(AnimatePresence, { mode: "wait", children: jsxRuntimeExports.jsx(motion.div, { initial: t36, animate: t37, exit: t39, transition: t40, style: t41, children: t42 }, t34) });
      $[74] = t34;
      $[75] = t36;
      $[76] = t39;
      $[77] = t42;
      $[78] = t43;
    } else {
      t43 = $[78];
    }
    let t44;
    if ($[79] !== t32 || $[80] !== t33 || $[81] !== t43) {
      t44 = jsxRuntimeExports.jsx(TabsContent, { value: "week", children: jsxRuntimeExports.jsxs(VStack, { bg: "AccentColor", children: [
        t30,
        t31,
        t32,
        t33,
        t43
      ] }) });
      $[79] = t32;
      $[80] = t33;
      $[81] = t43;
      $[82] = t44;
    } else {
      t44 = $[82];
    }
    let t45;
    if ($[83] !== MinAndMaxTasks || $[84] !== TaskByDaysAndProviderId || $[85] !== cursor2) {
      t45 = jsxRuntimeExports.jsx(TabsContent, { value: "day", children: jsxRuntimeExports.jsx(RenderDay, { deals: TaskByDaysAndProviderId, cursor: cursor2, MinAndMaxTasks }) });
      $[83] = MinAndMaxTasks;
      $[84] = TaskByDaysAndProviderId;
      $[85] = cursor2;
      $[86] = t45;
    } else {
      t45 = $[86];
    }
    let t46;
    if ($[87] !== t13 || $[88] !== t29 || $[89] !== t44 || $[90] !== t45 || $[91] !== view) {
      t46 = jsxRuntimeExports.jsxs(TabsRoot, { w: "100%", defaultValue: "month", variant: "subtle", onValueChange: t13, value: view, children: [
        t14,
        t29,
        t44,
        t45
      ] });
      $[87] = t13;
      $[88] = t29;
      $[89] = t44;
      $[90] = t45;
      $[91] = view;
      $[92] = t46;
    } else {
      t46 = $[92];
    }
    let t47;
    if ($[93] !== t12 || $[94] !== t46 || $[95] !== t5 || $[96] !== t6 || $[97] !== t7 || $[98] !== t8 || $[99] !== t9) {
      t47 = jsxRuntimeExports.jsxs(VStack, { children: [
        t5,
        t6,
        t7,
        t8,
        t9,
        t12,
        t46
      ] });
      $[93] = t12;
      $[94] = t46;
      $[95] = t5;
      $[96] = t6;
      $[97] = t7;
      $[98] = t8;
      $[99] = t9;
      $[100] = t47;
    } else {
      t47 = $[100];
    }
    let t48;
    if ($[101] !== t3 || $[102] !== t47) {
      t48 = jsxRuntimeExports.jsx(Box, { zIndex: 1e3, top: 0, position: "fixed", w: "100dvw", h: "100dvh", p: "1.5", background: "AccentColor", color: "AccentColorText", children: jsxRuntimeExports.jsx(Show, { when: t3, fallback: t4, children: t47 }) });
      $[101] = t3;
      $[102] = t47;
      $[103] = t48;
    } else {
      t48 = $[103];
    }
    return t48;
  };
  function _temp$1(_2, index) {
    return jsxRuntimeExports.jsx(Cell, { bg: "transparent" }, `empty-${index}`);
  }
  function _temp2$1(acc, entry) {
    return acc + entry[1].length;
  }
  function _temp3(item) {
    return jsxRuntimeExports.jsx(Text, { children: item }, item);
  }
  function _temp4(d) {
    const monthName = d.toLocaleDateString("ru", {
      weekday: "long"
    });
    return monthName.charAt(0).toUpperCase() + monthName.slice(1);
  }
  function _temp5(day, index) {
    return jsxRuntimeExports.jsx(Box, { outline: "solid", bg: "green.400", children: jsxRuntimeExports.jsx(Heading, { textAlign: "center", children: day }) }, `DayName-${day}-${index}`);
  }
  function _temp6(acc, entry) {
    return acc + entry[1].length;
  }
  function _temp7(task_0) {
    return jsxRuntimeExports.jsx(Link, { variant: "underline", href: ProviderIdToUrl(task_0), onClick: ProviderIdOnClick(task_0), color: "white", _hover: {
      color: "whiteAlpha.500"
    }, children: jsxRuntimeExports.jsx(Text, { lineClamp: "2", children: `${task_0.ID} - ${task_0.subject}-${task_0.description}` }) });
  }
  function _temp8(acc, entry) {
    return acc + entry[1].length;
  }
  function _temp9(task_0) {
    return jsxRuntimeExports.jsx(Link, { variant: "underline", href: ProviderIdToUrl(task_0), onClick: ProviderIdOnClick(task_0), color: "white", _hover: {
      color: "whiteAlpha.500"
    }, children: jsxRuntimeExports.jsx(Text, { lineClamp: "2", children: `${task_0.ID} - ${task_0.subject}-${task_0.description}` }) });
  }
  function MainPage() {
    const $ = compilerRuntimeExports.c(3);
    const [deals] = useGetTaskList();
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = [];
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    reactExports.useEffect(_temp2, t0);
    let t1;
    if ($[1] !== deals) {
      t1 = jsxRuntimeExports.jsx(CalendarGrid, { deals });
      $[1] = deals;
      $[2] = t1;
    } else {
      t1 = $[2];
    }
    return t1;
  }
  function _temp2() {
    const BX = window.BX;
    if (!BX?.CrmActivityEditor) {
      return;
    }
    if (BX.CrmActivityEditor.__SubscribeBitrixUIMainUiFilterFind) {
      return;
    }
    BX.CrmActivityEditor.__SubscribeBitrixUIMainUiFilterFind = true;
    const unsubscribe = SubscribeBitrixUI(["main-ui-filter-find", "ui-btn-primary"], _temp);
    return () => unsubscribe();
  }
  function _temp(btn, event) {
    window.location.reload();
  }
  var M = (e, i, s, u, m, a, l, h) => {
    let d = document.documentElement, w = ["light", "dark"];
    function p(n) {
      (Array.isArray(e) ? e : [e]).forEach((y) => {
        let k = y === "class", S = k && a ? m.map((f) => a[f] || f) : m;
        k ? (d.classList.remove(...S), d.classList.add(a && a[n] ? a[n] : n)) : d.setAttribute(y, n);
      }), R(n);
    }
    function R(n) {
      h && w.includes(n) && (d.style.colorScheme = n);
    }
    function c() {
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    if (u) p(u);
    else try {
      let n = localStorage.getItem(i) || s, y = l && n === "system" ? c() : n;
      p(y);
    } catch (n) {
    }
  };
  var b = ["light", "dark"], I = "(prefers-color-scheme: dark)", O = typeof window == "undefined", x = reactExports.createContext(void 0), U = { setTheme: (e) => {
  }, themes: [] }, z = () => {
    var e;
    return (e = reactExports.useContext(x)) != null ? e : U;
  }, J = (e) => reactExports.useContext(x) ? reactExports.createElement(reactExports.Fragment, null, e.children) : reactExports.createElement(V, { ...e }), N = ["light", "dark"], V = ({ forcedTheme: e, disableTransitionOnChange: i = false, enableSystem: s = true, enableColorScheme: u = true, storageKey: m = "theme", themes: a = N, defaultTheme: l = s ? "system" : "light", attribute: h = "data-theme", value: d, children: w, nonce: p, scriptProps: R }) => {
    let [c, n] = reactExports.useState(() => H(m, l)), [T, y] = reactExports.useState(() => c === "system" ? E() : c), k = d ? Object.values(d) : a, S = reactExports.useCallback((o) => {
      let r = o;
      if (!r) return;
      o === "system" && s && (r = E());
      let v = d ? d[r] : r, C = i ? W(p) : null, P = document.documentElement, L = (g) => {
        g === "class" ? (P.classList.remove(...k), v && P.classList.add(v)) : g.startsWith("data-") && (v ? P.setAttribute(g, v) : P.removeAttribute(g));
      };
      if (Array.isArray(h) ? h.forEach(L) : L(h), u) {
        let g = b.includes(l) ? l : null, D = b.includes(r) ? r : g;
        P.style.colorScheme = D;
      }
      C == null || C();
    }, [p]), f = reactExports.useCallback((o) => {
      let r = typeof o == "function" ? o(c) : o;
      n(r);
      try {
        localStorage.setItem(m, r);
      } catch (v) {
      }
    }, [c]), A = reactExports.useCallback((o) => {
      let r = E(o);
      y(r), c === "system" && s && !e && S("system");
    }, [c, e]);
    reactExports.useEffect(() => {
      let o = window.matchMedia(I);
      return o.addListener(A), A(o), () => o.removeListener(A);
    }, [A]), reactExports.useEffect(() => {
      let o = (r) => {
        r.key === m && (r.newValue ? n(r.newValue) : f(l));
      };
      return window.addEventListener("storage", o), () => window.removeEventListener("storage", o);
    }, [f]), reactExports.useEffect(() => {
      S(e != null ? e : c);
    }, [e, c]);
    let Q = reactExports.useMemo(() => ({ theme: c, setTheme: f, forcedTheme: e, resolvedTheme: c === "system" ? T : c, themes: s ? [...a, "system"] : a, systemTheme: s ? T : void 0 }), [c, f, e, T, s, a]);
    return reactExports.createElement(x.Provider, { value: Q }, reactExports.createElement(_, { forcedTheme: e, storageKey: m, attribute: h, enableSystem: s, enableColorScheme: u, defaultTheme: l, value: d, themes: a, nonce: p, scriptProps: R }), w);
  }, _ = reactExports.memo(({ forcedTheme: e, storageKey: i, attribute: s, enableSystem: u, enableColorScheme: m, defaultTheme: a, value: l, themes: h, nonce: d, scriptProps: w }) => {
    let p = JSON.stringify([s, i, a, e, h, l, u, m]).slice(1, -1);
    return reactExports.createElement("script", { ...w, suppressHydrationWarning: true, nonce: typeof window == "undefined" ? d : "", dangerouslySetInnerHTML: { __html: `(${M.toString()})(${p})` } });
  }), H = (e, i) => {
    if (O) return;
    let s;
    try {
      s = localStorage.getItem(e) || void 0;
    } catch (u) {
    }
    return s || i;
  }, W = (e) => {
    let i = document.createElement("style");
    return e && i.setAttribute("nonce", e), i.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), document.head.appendChild(i), () => {
      window.getComputedStyle(document.body), setTimeout(() => {
        document.head.removeChild(i);
      }, 1);
    };
  }, E = (e) => (e || (e = window.matchMedia(I)), e.matches ? "dark" : "light");
  var DefaultContext = {
    color: void 0,
    size: void 0,
    className: void 0,
    style: void 0,
    attr: void 0
  };
  var IconContext = React.createContext && React.createContext(DefaultContext);
  var _excluded = ["attr", "size", "title"];
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r);
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function Tree2Element(tree) {
    return tree && tree.map((node2, i) => React.createElement(node2.tag, _objectSpread({
      key: i
    }, node2.attr), Tree2Element(node2.child)));
  }
  function GenIcon(data) {
    return (props) => React.createElement(IconBase, _extends({
      attr: _objectSpread({}, data.attr)
    }, props), Tree2Element(data.child));
  }
  function IconBase(props) {
    var elem = (conf) => {
      var {
        attr,
        size: size2,
        title
      } = props, svgProps = _objectWithoutProperties(props, _excluded);
      var computedSize = size2 || conf.size || "1em";
      var className;
      if (conf.className) className = conf.className;
      if (props.className) className = (className ? className + " " : "") + props.className;
      return React.createElement("svg", _extends({
        stroke: "currentColor",
        fill: "currentColor",
        strokeWidth: "0"
      }, conf.attr, attr, svgProps, {
        className,
        style: _objectSpread(_objectSpread({
          color: props.color || conf.color
        }, conf.style), props.style),
        height: computedSize,
        width: computedSize,
        xmlns: "http://www.w3.org/2000/svg"
      }), title && React.createElement("title", null, title), props.children);
    };
    return IconContext !== void 0 ? React.createElement(IconContext.Consumer, null, (conf) => elem(conf)) : elem(DefaultContext);
  }
  function LuMoon(props) {
    return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "path", "attr": { "d": "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" }, "child": [] }] })(props);
  }
  function LuSun(props) {
    return GenIcon({ "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "4" }, "child": [] }, { "tag": "path", "attr": { "d": "M12 2v2" }, "child": [] }, { "tag": "path", "attr": { "d": "M12 20v2" }, "child": [] }, { "tag": "path", "attr": { "d": "m4.93 4.93 1.41 1.41" }, "child": [] }, { "tag": "path", "attr": { "d": "m17.66 17.66 1.41 1.41" }, "child": [] }, { "tag": "path", "attr": { "d": "M2 12h2" }, "child": [] }, { "tag": "path", "attr": { "d": "M20 12h2" }, "child": [] }, { "tag": "path", "attr": { "d": "m6.34 17.66-1.41 1.41" }, "child": [] }, { "tag": "path", "attr": { "d": "m19.07 4.93-1.41 1.41" }, "child": [] }] })(props);
  }
  function ColorModeProvider(props) {
    const $ = compilerRuntimeExports.c(2);
    let t0;
    if ($[0] !== props) {
      t0 = jsxRuntimeExports.jsx(J, { attribute: "class", disableTransitionOnChange: true, ...props });
      $[0] = props;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  }
  function useColorMode() {
    const $ = compilerRuntimeExports.c(7);
    const {
      resolvedTheme,
      setTheme,
      forcedTheme
    } = z();
    const colorMode = forcedTheme || resolvedTheme;
    let t0;
    if ($[0] !== resolvedTheme || $[1] !== setTheme) {
      t0 = () => {
        setTheme(resolvedTheme === "dark" ? "light" : "dark");
      };
      $[0] = resolvedTheme;
      $[1] = setTheme;
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    const toggleColorMode = t0;
    const t1 = colorMode;
    let t2;
    if ($[3] !== setTheme || $[4] !== t1 || $[5] !== toggleColorMode) {
      t2 = {
        colorMode: t1,
        setColorMode: setTheme,
        toggleColorMode
      };
      $[3] = setTheme;
      $[4] = t1;
      $[5] = toggleColorMode;
      $[6] = t2;
    } else {
      t2 = $[6];
    }
    return t2;
  }
  function ColorModeIcon() {
    const $ = compilerRuntimeExports.c(2);
    const {
      colorMode
    } = useColorMode();
    let t0;
    if ($[0] !== colorMode) {
      t0 = colorMode === "dark" ? jsxRuntimeExports.jsx(LuMoon, {}) : jsxRuntimeExports.jsx(LuSun, {});
      $[0] = colorMode;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  }
  reactExports.forwardRef(function ColorModeButton2(props, ref) {
    const $ = compilerRuntimeExports.c(7);
    const {
      toggleColorMode
    } = useColorMode();
    let t0;
    if ($[0] === Symbol.for("react.memo_cache_sentinel")) {
      t0 = jsxRuntimeExports.jsx(Skeleton, { boxSize: "9" });
      $[0] = t0;
    } else {
      t0 = $[0];
    }
    let t1;
    let t2;
    if ($[1] === Symbol.for("react.memo_cache_sentinel")) {
      t1 = {
        _icon: {
          width: "5",
          height: "5"
        }
      };
      t2 = jsxRuntimeExports.jsx(ColorModeIcon, {});
      $[1] = t1;
      $[2] = t2;
    } else {
      t1 = $[1];
      t2 = $[2];
    }
    let t3;
    if ($[3] !== props || $[4] !== ref || $[5] !== toggleColorMode) {
      t3 = jsxRuntimeExports.jsx(ClientOnly, { fallback: t0, children: jsxRuntimeExports.jsx(IconButton, { onClick: toggleColorMode, variant: "ghost", "aria-label": "Toggle color mode", size: "sm", ref, ...props, css: t1, children: t2 }) });
      $[3] = props;
      $[4] = ref;
      $[5] = toggleColorMode;
      $[6] = t3;
    } else {
      t3 = $[6];
    }
    return t3;
  });
  const LightMode = reactExports.forwardRef(function LightMode2(props, ref) {
    const $ = compilerRuntimeExports.c(3);
    let t0;
    if ($[0] !== props || $[1] !== ref) {
      t0 = jsxRuntimeExports.jsx(Span, { color: "fg", display: "contents", className: "chakra-theme light", colorPalette: "gray", colorScheme: "light", ref, ...props });
      $[0] = props;
      $[1] = ref;
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    return t0;
  });
  reactExports.forwardRef(function DarkMode2(props, ref) {
    const $ = compilerRuntimeExports.c(3);
    let t0;
    if ($[0] !== props || $[1] !== ref) {
      t0 = jsxRuntimeExports.jsx(Span, { color: "fg", display: "contents", className: "chakra-theme dark", colorPalette: "gray", colorScheme: "dark", ref, ...props });
      $[0] = props;
      $[1] = ref;
      $[2] = t0;
    } else {
      t0 = $[2];
    }
    return t0;
  });
  function Provider(props) {
    const $ = compilerRuntimeExports.c(2);
    let t0;
    if ($[0] !== props) {
      t0 = jsxRuntimeExports.jsx(ChakraProvider, { value: defaultSystem, children: jsxRuntimeExports.jsx(ColorModeProvider, { ...props }) });
      $[0] = props;
      $[1] = t0;
    } else {
      t0 = $[1];
    }
    return t0;
  }
  const app = document.createElement("div");
  app.id = "ActivityRebuild";
  document.body.append(app);
  const root = ReactDOM.createRoot(app);
  function destroyApp() {
    root.unmount();
    app.remove();
  }
  addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      destroyApp();
    }
  });
  root.render( jsxRuntimeExports.jsx(React.StrictMode, { children: jsxRuntimeExports.jsx(Provider, { children: jsxRuntimeExports.jsx(ClientOnly, { fallback: jsxRuntimeExports.jsx("div", { children: "Loading..." }), children: jsxRuntimeExports.jsx(LightMode, { children: jsxRuntimeExports.jsx(MainPage, {}) }) }) }) }));

})();